<!doctype html>
<html lang="fr">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Pac-Mania 3D LEGO Style</title>
  <!-- IMPORT FONTE ARCADE -->
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet" />

  <!-- THREE.JS CORE -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

  <!-- THREE.JS POST-PROCESSING -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>

  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #111;
      font-family: "Press Start 2P", cursive;
      user-select: none;
    }

    /* --- CLASSE POUR LE FLOU OU ASSOMBRISEMENT (Selon Qualité) --- */
    body.paused.high-quality #game-canvas,
    body.paused.high-quality #ui-layer,
    body.paused.high-quality #level-indicator,
    body.paused.high-quality #view-mode-indicator {
      filter: blur(8px) grayscale(90%);
      transform: scale(1.02);
    }

    body.paused.low-med-quality #game-canvas {
      filter: brightness(0.3) grayscale(50%);
      transform: scale(1);
    }

    body.paused.low-med-quality #ui-layer,
    body.paused.low-med-quality #level-indicator,
    body.paused.low-med-quality #view-mode-indicator {
      /* UI reste brillante mais peut-être un peu moins affectée */
    }

    /* Transition douce pour l'effet */
    #game-canvas,
    #ui-layer,
    #level-indicator,
    #view-mode-indicator {
      transition:
        filter 0.4s ease,
        transform 0.4s ease;
    }

    #ui-layer {
      position: absolute;
      top: 20px;
      left: 20px;
      color: #ffd700;
      font-size: 16px;
      font-weight: normal;
      text-shadow: 2px 2px #000;
      z-index: 10;
      line-height: 1.5;
    }

    #level-indicator {
      position: absolute;
      top: 20px;
      right: 20px;
      color: #ffffff;
      font-size: 16px;
      text-shadow: 2px 2px #000;
      z-index: 10;
    }

    /* --- VIEW MODE INDICATOR --- */
    #view-mode-indicator {
      position: absolute;
      bottom: 20px;
      left: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
      z-index: 15;
      pointer-events: none;
      opacity: 0.9;
      transition: transform 0.2s ease;
    }

    #view-icon {
      width: 60px;
      height: 60px;
      margin-bottom: 5px;
      filter: drop-shadow(0 0 5px rgba(0, 0, 0, 0.8));
    }

    #game-version {
      color: rgba(255, 255, 255, 0.4);
      font-size: 8px;
      font-family: "Press Start 2P", cursive;
      text-shadow: 1px 1px #000;
      letter-spacing: 1px;
      margin-top: 5px;
    }

    /* --- DEBUG & EDITOR OVERLAY --- */
    #debug-overlay {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.95);
      border: 4px solid #00ff00;
      padding: 20px;
      z-index: 100;
      display: none;
      flex-direction: column;
      align-items: center;
      color: #00ff00;
      box-shadow: 0 0 20px rgba(0, 255, 0, 0.2);
      max-height: 90vh;
      overflow-y: auto;
      font-family: "Courier New", monospace;
    }

    #debug-canvas {
      background-color: #000;
      border: 1px solid #333;
      image-rendering: pixelated;
      cursor: crosshair;
    }

    #debug-info {
      margin-bottom: 10px;
      font-size: 18px;
      text-align: center;
      font-family: "Press Start 2P", cursive;
      line-height: 1.5;
    }

    /* Styles de l'éditeur */
    #editor-controls {
      display: none;
      flex-direction: column;
      align-items: center;
      width: 100%;
      margin-bottom: 10px;
    }

    .palette {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 5px;
      margin-bottom: 10px;
      background: #222;
      padding: 5px;
      border-radius: 4px;
    }

    .palette-item {
      width: 30px;
      height: 30px;
      border: 2px solid #555;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 8px;
      font-family: "Press Start 2P", cursive;
      font-weight: bold;
      color: white;
      text-shadow: 1px 1px 0 #000;
    }

    .palette-item.selected {
      border-color: #00ff00;
      box-shadow: 0 0 5px #00ff00;
      transform: scale(1.1);
    }

    .editor-btn {
      background: #333;
      color: #fff;
      border: 2px solid #555;
      padding: 8px 12px;
      margin: 2px;
      cursor: pointer;
      font-family: "Press Start 2P", cursive;
      font-size: 10px;
    }

    .editor-btn:hover {
      background: #444;
      border-color: #fff;
    }

    .editor-btn:active {
      background: #555;
    }

    .grid-controls {
      display: flex;
      gap: 10px;
      margin-bottom: 10px;
    }

    .action-row {
      display: flex;
      gap: 10px;
      margin-top: 10px;
    }

    /* --- TITLE SCREEN (OVERLAY) --- */
    #overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.4);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      color: white;
      z-index: 20;
      text-align: center;
      cursor: pointer;
    }

    /* --- INITIALS ENTRY SCREEN --- */
    #initials-screen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.9);
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      color: white;
      z-index: 30;
      text-align: center;
    }

    .initials-container {
      display: flex;
      gap: 30px;
      margin: 40px 0;
    }

    .initial-char {
      font-size: 40px;
      /* Réduit pour arcade font */
      color: #ffd700;
      text-shadow: 4px 4px #ff0000;
      width: 50px;
      border-bottom: 4px solid #333;
      padding-bottom: 10px;
    }

    .initial-char.active {
      color: #ffffff;
      border-bottom: 4px solid #00ffff;
      animation: blinkChar 0.5s infinite alternate;
    }

    @keyframes blinkChar {
      from {
        transform: scale(1);
      }

      to {
        transform: scale(1.1);
      }
    }

    /* --- HIGH SCORE SCREEN --- */
    #highscore-screen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.85);
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      z-index: 25;
      padding-top: 40px;
      cursor: pointer;
      }

      #highscore-footer {
        margin-top: 20px;
        margin-bottom: 40px;
        max-width: 800px;
        font-family: "Courier New", monospace;
        font-size: 11px;
        color: #aaa;
        text-align: center;
        line-height: 1.6;
        padding: 0 20px;
        text-transform: none; /* Le texte de base est en caps via la font pixel, ici on veut du texte normal */
        font-weight: bold;
    }

    #highscore-logo {
      max-width: 400px;
      width: 50%;
      height: auto;
      margin-bottom: 30px;
      filter: drop-shadow(0 0 10px rgba(255, 255, 0, 0.5));
    }

    #highscore-canvas {
      background: transparent;
        flex-shrink: 0; /* Empêche le canvas de rétrécir */
    }

    #info-screen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.9);
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      z-index: 25;
      cursor: pointer;
    }

    #confetti-canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 50;
    }

    .blinking {
      animation: blink 1s infinite;
    }

    @keyframes blink {
      0% {
        opacity: 1;
      }

      50% {
        opacity: 0;
      }

      100% {
        opacity: 1;
      }
    }

    h1 {
      font-size: 40px;
      margin: 0 0 30px 0;
      color: #ffd700;
      text-shadow: 4px 4px #ff0000;
      letter-spacing: 2px;
      line-height: 1.4;
    }

    .floating-score {
      position: absolute;
      color: #00ffff;
      font-size: 32px;
      pointer-events: none;
      text-shadow: 2px 2px #000;
      z-index: 15;
      transition: opacity 1s ease-out;
      font-family: "Press Start 2P", cursive;
    }

    #game-logo {
      max-width: 90%;
      width: 600px;
      height: auto;
      margin-bottom: 20px;
      filter: drop-shadow(0 0 20px rgba(0, 0, 0, 0.5));
      animation: floatLogo 3s ease-in-out infinite;
    }

    @keyframes floatLogo {

      0%,
      100% {
        transform: translateY(0);
      }

      50% {
        transform: translateY(-10px);
      }
    }
  </style>
</head>

<body>
  <canvas id="confetti-canvas"></canvas>

  <div id="ui-layer">
    SCORE: <span id="score">0</span><br />
    LIFES: <span id="lives">3</span>
  </div>
  <div id="level-indicator">LEVEL <span id="level">1</span></div>

  <!-- VIEW MODE INDICATOR -->
  <div id="view-mode-indicator">
    <div id="view-icon"></div>
    <div id="game-version">v2.9.4</div>
  </div>

  <!-- DEBUG UI -->
  <div id="debug-overlay">
    <div id="debug-info">
      DEBUG MODE<br />
      <span id="debug-help" style="
            font-size: 10px;
            color: #aaa;
            font-family: &quot;Courier New&quot;, monospace;
          ">LEFT / RIGHT KEYS to change level, 'P' to continu</span><br />
      LEVEL PREVIEW <span id="debug-level-num">1</span>
    </div>

    <!-- EDITOR CONTROLS -->
    <div id="editor-controls">
      <div class="palette" id="tile-palette">
        <!-- Généré par JS -->
      </div>

      <div class="grid-controls">
        <div>
          ROWS:
          <button class="editor-btn" onclick="resizeMap(0, 1)">+</button>
          <button class="editor-btn" onclick="resizeMap(0, -1)">-</button>
        </div>
        <div>
          COLUMNS:
          <button class="editor-btn" onclick="resizeMap(1, 0)">+</button>
          <button class="editor-btn" onclick="resizeMap(-1, 0)">-</button>
        </div>
      </div>
    </div>

    <canvas id="debug-canvas" width="400" height="400"></canvas>

    <div class="action-row">
      <button id="btn-edit-mode" class="editor-btn" style="font-size: 12px; padding: 10px 20px">
        MODIFY
      </button>
      <button id="btn-export" class="editor-btn" style="display: none; font-size: 12px; color: #00ffff">
        COPY JSON
      </button>
    </div>
  </div>

  <!-- TITLE SCREEN -->
  <div id="overlay">
    <img id="game-logo"
      src="data:image/webp;base64,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"
      alt="LOGO PAC-MANIA" />
    <h1 id="overlay-title" style="display: none"></h1>
    <!-- Message ajusté pour la nouvelle fonte -->
    <div id="overlay-msg" class="blinking" style="font-size: 16px; line-height: 2">
      PRESS SPACEBAR TO PLAY
    </div>
    <div style="margin-top: 40px; font-size: 10px; color: #aaa; line-height: 2">
      Key arrow to move<br />SPACE to jump<br />V: switch View | M: Ms
      Pac-Man<br />P: Debug
    </div>
  </div>

  <!-- INITIALS ENTRY SCREEN -->
  <div id="initials-screen">
    <h2 style="
          color: #00ffff;
          font-size: 24px;
          margin-bottom: 20px;
          text-shadow: 2px 2px #000;
        ">
      NEW RECORD!
    </h2>
    <p style="font-size: 12px; color: #aaa; margin-bottom: 10px">
      ENTER YOUR NAME
    </p>

    <div class="initials-container">
      <div id="init-0" class="initial-char active">A</div>
      <div id="init-1" class="initial-char">A</div>
      <div id="init-2" class="initial-char">A</div>
    </div>

    <p style="font-size: 10px; color: #888; margin-top: 20px; line-height: 1.8">
      TOP/BOTTOM : Change letter<br />
      LEFT/RIGHT : Change Position<br />
      ENTER : Validate
    </p>
  </div>

  <!-- HIGH SCORE SCREEN -->
  <div id="highscore-screen">
    <!-- Placeholder pour logo highscore (à remplacer par base64) -->
    <img id="highscore-logo"
      src="data:image/webp;base64,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"
      alt="HIGH SCORES" />
    <h2 style="
          color: #ffd700;
          margin-top: 0px;
          margin-bottom: 0px;
          font-size: 32px;
          text-shadow: 2px 2px #000;
        ">
      TOP 10 SCORES
    </h2>
    <canvas id="highscore-canvas" width="400" height="350"></canvas>
    <div id="highscore-footer">
      Hello, this game is a demonstration of vibe coding. It is inspired by Pacmania. However tactics and logics differs a bit from this game.  hope you will get as much fun to play through the 16 levels of this game as I had to build it. Feel free to enhance/fix what is needed as this game is far from being perfect, but the main idea was to have a taste of vibe coding. From a technical perspective, Gemini 3 Pro, Claude and Antigravity have been my way to go. I attempted to get everything in a single HTML file (musics, samples, graphics ... encoded in base64). Musics come from the X68000 version of Pacmania and are played through a Yamaha emulator. A few samples have been used as well. Enjoy!
    </div>
  </div>

  <!-- INFO / SCORING SCREEN (NOUVEAU) -->
  <div id="info-screen">
    <h2 style="
          color: #00ffff;
          margin-bottom: 30px;
          font-size: 32px;
          text-shadow: 2px 2px #000;
          margin-top: 40px;
        ">
      HIGHSCORES
    </h2>
    <canvas id="info-canvas" width="500" height="600"></canvas>
  </div>

  <script>
    // --- DEFINITION DU TILT-SHIFT SHADER (CUSTOM) ---
    // Ce shader ignore la profondeur 3D et floute simplement en fonction de la position Y à l'écran.
    const TiltShiftShader = {
      uniforms: {
        tDiffuse: { value: null },
        blurRadius: { value: 0.0045 }, // Force du flou
        gradientRadius: { value: 0.3 }, // Zone de transition
        start: { value: 0.5 }, // Centre de la netteté (0.5 = milieu de l'écran)
        screenSize: {
          value: new THREE.Vector2(window.innerWidth, window.innerHeight),
        },
      },
      vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
                }
            `,
      fragmentShader: `
                uniform sampler2D tDiffuse;
                uniform float blurRadius;
                uniform float gradientRadius;
                uniform float start;
                uniform vec2 screenSize;
                varying vec2 vUv;

                // Fonction de bruit pseudo-aléatoire pour éviter le "banding"
                float random(vec3 scale, float seed) {
                    return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);
                }

                void main() {
                    vec4 color = vec4(0.0);
                    float total = 0.0;
                    
                    // Calcul de la distance par rapport au centre horizontal (Y=0.5)
                    // abs(vUv.y - start) donne la distance.
                    // On veut que ce soit 0 au centre et augmente vers les bords.
                    float offset = abs(vUv.y - start);
                    
                    // On applique un seuil : si on est proche du centre (< 0.2), offset = 0 (net)
                    // Sinon, ça augmente progressivement.
                    // smoothstep(edge0, edge1, x) : si x < edge0 -> 0. si x > edge1 -> 1.
                    
                    // Zone nette large : 25% de l'écran au centre (0.125 de chaque coté de 0.5)
                    float focusArea = 0.15; 
                    float blurAmount = smoothstep(focusArea, 0.5, offset);
                    
                    // Si on est dans la zone nette, pas de calcul couteux
                    if (blurAmount < 0.01) {
                        gl_FragColor = texture2D(tDiffuse, vUv);
                        return;
                    }
                    
                    // Application du flou (itération simple pour simuler un flou gaussien)
                    // Plus on est loin du centre, plus 'step' est grand
                    float step = blurRadius * blurAmount;

                    // Échantillonnage simple en spirale/grille pour le flou
                    for (float x = -2.0; x <= 2.0; x++) {
                        for (float y = -2.0; y <= 2.0; y++) {
                            // Décalage UV
                            vec2 d = vec2(x, y);
                            
                            // Poids (Gaussien approximatif : plus fort au centre du kernel)
                            float weight = 1.0 - length(d) / 2.8; 
                            
                            // On ajoute un tout petit peu de bruit pour casser les lignes
                            // float noise = random(vec3(12.9898, 78.233, 151.7182), 0.0);
                            
                            color += texture2D(tDiffuse, vUv + d * step) * weight;
                            total += weight;
                        }
                    }

                    gl_FragColor = color / total;
                }
            `,
    };

    // --- CONFIGURATION DU JEU ---
    const CONFIG = {
      GAME: {
        TILE_SIZE: 10,
        START_LEVEL: 1,
        LIVES: 3,
        NEXT_LIFE_THRESHOLD_START: 5000,
        NEXT_LIFE_THRESHOLD_STEP: 7500,
        TITLE_DURATION: 5000,
        MAX_SCORES: 10,
        LS_KEY: "pacmania_lego_scores",
        ENABLE_NIGHT_DAY_CYCLE: true,
      },
      SPEEDS: {
        PACMAN_NORMAL_BASE: 0.34,
        PACMAN_EATING_BASE: 0.24,
        GHOST_NORMAL_BASE: 0.28,
        GHOST_SCARED: 0.15,
        GHOST_DEAD: 0.6,
        PACMAN_NORMAL_MAX: 0.45,
        PACMAN_EATING_MAX: 0.35,
        GHOST_NORMAL_MAX: 0.45,
        EATING_DELAY_SHORT: 90,
        EATING_DELAY_LONG: 750,
      },
      DURATIONS: {
        POWER_PELLET_BASE: 10000,
        POWER_PELLET_MIN: 3000,
        JUMP: 600,
        BOUNCE: 200,
        GHOST_RELEASE_DELAY: 1000,
        GHOST_LEAVING_HOUSE: 2000,
        COLLISION_COOLDOWN: 500,
      },
      PHYSICS: {
        JUMP_HEIGHT: 10,
        BOUNCE_HEIGHT: 3,
        WALL_HEIGHT: 5,
      },
      COLORS: {
        LEGO_BLUE: 0x0055bf,
        LEGO_RED: 0xc91a09,
        LEGO_YELLOW: 0xf2cd37,
        LEGO_WHITE: 0xffffff,
        LEGO_ORANGE: 0xfe8a18,
        LEGO_CYAN: 0x9ba19d,
        LEGO_PINK: 0x923978,
        LEGO_GREEN: 0x008f9b,
        BG_ISO: 0x111111,
        BG_FPS: 0x87ceeb,
      },
      CAMERA: {
        // MODIFICATION : REMPLACEMENT DES FOV PAR UNE TAILLE DE VUE ORTHOGRAPHIQUE
        VIEW_SIZE: 60, // Hauteur visible en unités (approx 60 correspond à l'ancien zoom ISO)
        ISO_OFFSET: 500,
        PACMANIA_OFFSET: 250,
      },
      PALETTE: [
        { type: 1, label: "WALL", color: "#0000FF" },
        { type: 0, label: "GUM", color: "#000000" },
        { type: 2, label: "SPpGUM", color: "#FFFFFF" },
        { type: 6, label: "WARP", color: "#FF00FF" },
        { type: 7, label: "PAC", color: "#FFFF00" },
        { type: 8, label: "GHOST", color: "#FF0000" },
        { type: 9, label: "VOID", color: "#333333" },
      ],
      GHOSTS: [
        { color: 0xff0000, name: "Blinky" },
        { color: 0xffb8ff, name: "Pinky" },
        { color: 0x00ffff, name: "Inky" },
        { color: 0xffb852, name: "Clyde" },
        { color: 0x00ff00, name: "Funky" },
        { color: 0x800080, name: "Sue" },
      ],
      GRAPHICS: {
        QUALITY_TIER: "HIGH", // HIGH, MEDIUM, LOW
        SEGMENTS: 32, // Resolution géométrie (High=32, Med=16, Low=12)
        USE_FLOOR_STUDS: true,
        USE_WALL_STUDS: true,
        SHADOW_MAP_SIZE: 2048,
        PARTICLE_COUNT: 150,
        FLOOR_SIZE: 520,
      },
    };

    const TILE_SIZE = CONFIG.GAME.TILE_SIZE;
    let currentLevel = CONFIG.GAME.START_LEVEL;

    // Vitesses
    let PACMAN_SPEED_NORMAL = CONFIG.SPEEDS.PACMAN_NORMAL_BASE;
    let PACMAN_SPEED_EATING = CONFIG.SPEEDS.PACMAN_EATING_BASE;
    let GHOST_SPEED = CONFIG.SPEEDS.GHOST_NORMAL_BASE;
    let POWER_PELLET_DURATION = CONFIG.DURATIONS.POWER_PELLET_BASE;

    const JUMP_HEIGHT = CONFIG.PHYSICS.JUMP_HEIGHT;
    const JUMP_DURATION = CONFIG.DURATIONS.JUMP;
    const BOUNCE_HEIGHT = CONFIG.PHYSICS.BOUNCE_HEIGHT;
    const BOUNCE_DURATION = CONFIG.DURATIONS.BOUNCE;

    // Délai de ralentissement quand on mange
    // MODIFICATION: Variable dynamique pour gérer les chaînes de gommes
    // 90ms = Reprise rapide (fin de ligne)
    // 750ms = Maintien lent (milieu de ligne)
    let currentEatingDelay = CONFIG.SPEEDS.EATING_DELAY_SHORT;

    const GHOST_SPEED_SCARED = CONFIG.SPEEDS.GHOST_SCARED;
    const GHOST_SPEED_DEAD = CONFIG.SPEEDS.GHOST_DEAD;

    const LEGO_BLUE = CONFIG.COLORS.LEGO_BLUE;
    const LEGO_RED = CONFIG.COLORS.LEGO_RED;
    const LEGO_YELLOW = CONFIG.COLORS.LEGO_YELLOW;
    const LEGO_WHITE = CONFIG.COLORS.LEGO_WHITE;
    const LEGO_ORANGE = CONFIG.COLORS.LEGO_ORANGE;
    const LEGO_CYAN = CONFIG.COLORS.LEGO_CYAN;
    const LEGO_PINK = CONFIG.COLORS.LEGO_PINK;
    const LEGO_GREEN = CONFIG.COLORS.LEGO_GREEN;

    const viewMode_0_DEFAULT_OFFSET = CONFIG.CAMERA.ISO_OFFSET;

    // --- GESTION DES ÉTATS DE JEU ---
    const STATE_TITLE = 0;
    const STATE_HIGHSCORE = 1;
    const STATE_GAME = 2;
    const STATE_INITIALS = 3;
    const STATE_INFO = 4;

    let gameState = STATE_TITLE;
    let titleScreenTimer = 0;
    let highScoreTimer = 0;
    let infoScreenTimer = 0;
    const TITLE_DURATION = CONFIG.GAME.TITLE_DURATION;

    // --- HIGH SCORES ---
    let highScores = [];
    const MAX_SCORES = CONFIG.GAME.MAX_SCORES;
    const LS_KEY = CONFIG.GAME.LS_KEY;

    // --- OPTIMIZATION GLOBALS (Reduce GC) ---
    const _tempVec = new THREE.Vector3();
    const _tempVec2 = new THREE.Vector3();
    const _tempVec3 = new THREE.Vector3();
    const _tempVec4 = new THREE.Vector3();
    const _tempVec5 = new THREE.Vector3();
    const _tempColor = new THREE.Color();
    const _tempLightOffset = new THREE.Vector3(60, 120, 40);

    // --- INITIALS VARIABLES ---
    let initialsChars = [65, 65, 65]; // ASCII 'A'
    let currentInitialIdx = 0;

    // --- CONFIG NIVEAUX (DEDUPLICATION) ---
    // Definition des palettes et entrées maison pour chaque index de map (1 à 16)
    const MAP_CONFIGS = [
      {
        id: 1,
        house: { x: 10, z: 9 },
        colors: ["LEGO_BLUE", "LEGO_RED", "LEGO_WHITE"],
      },
      {
        id: 2,
        house: { x: 9, z: 8 },
        colors: ["LEGO_BLUE", "LEGO_GREEN", "LEGO_PINK"],
      },
      {
        id: 3,
        house: { x: 9, z: 9 },
        colors: ["LEGO_PINK", "LEGO_ORANGE", "LEGO_PINK"],
      },
      {
        id: 4,
        house: { x: 9, z: 8 },
        colors: ["LEGO_GREEN", "LEGO_CYAN", "LEGO_BLUE"],
      },
      {
        id: 5,
        house: { x: 9, z: 19 },
        colors: ["LEGO_PINK", "LEGO_ORANGE", "LEGO_PINK"],
      },
      {
        id: 6,
        house: { x: 9, z: 8 },
        colors: ["LEGO_YELLOW", "LEGO_ORANGE", "LEGO_RED"],
      },
      {
        id: 7,
        house: { x: 10, z: 9 },
        colors: ["LEGO_WHITE", "LEGO_WHITE", "LEGO_WHITE"],
      },
      {
        id: 8,
        house: { x: 13, z: 7 },
        colors: ["LEGO_GREEN", "LEGO_PINK", "LEGO_RED"],
      },
      {
        id: 9,
        house: { x: 18, z: 8 },
        colors: ["LEGO_WHITE", "LEGO_ORANGE", "LEGO_CYAN"],
      },
      {
        id: 10,
        house: { x: 13, z: 10 },
        colors: ["LEGO_BLUE", "LEGO_BLUE", "LEGO_BLUE"],
      },
      {
        id: 11,
        house: { x: 8, z: 6 },
        colors: ["LEGO_GREEN", "LEGO_ORANGE", "LEGO_CYAN"],
      },
      {
        id: 12,
        house: { x: 10, z: 8 },
        colors: ["LEGO_YELLOW", "LEGO_PINK", "LEGO_CYAN"],
      },
      {
        id: 13,
        house: { x: 20, z: 2 },
        colors: ["LEGO_BLUE", "LEGO_GREEN", "LEGO_YELLOW"],
      },
      {
        id: 14,
        house: { x: 15, z: 12 },
        colors: ["LEGO_GREEN", "LEGO_PINK", "LEGO_RED"],
      },
      {
        id: 15,
        house: { x: 11, z: 13 },
        colors: ["LEGO_GREEN", "LEGO_PINK", "LEGO_RED"],
      },
      {
        id: 16,
        house: { x: 8, z: 12 },
        colors: ["LEGO_GREEN", "LEGO_PINK", "LEGO_RED"],
      },
    ];

    // --- GLOBALS ---
    // Coordonnées de l'entrée de la maison (pour le retour des fantômes)
    let houseEntrance = { x: 0, z: 0 };

    /**
     * MAP_DESIGN LEVEL 1 (Hardcoded)
     * 1 = Mur
     * 0 = Chemin
     * 2 = Super Pac-Gomme
     * 6 = Tunnel
     * 7 = Spawn Pacman
     * 8 = Spawn Fantôme
     * 9 = Maison/Vide (Navigable mais sans gommes)
     */
    const LEVEL_1_MAP = [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1],[1,0,1,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,1,0,1],[1,2,1,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,1,2,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,0,1],[1,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,1],[1,1,1,1,1,0,1,1,1,9,1,9,1,1,1,0,1,1,1,1,1],[1,1,1,1,1,0,1,9,9,9,9,9,9,9,1,0,1,1,1,1,1],[1,1,1,1,1,0,1,9,1,1,9,1,1,9,1,0,1,1,1,1,1],[6,6,6,6,6,0,9,9,1,8,8,8,1,9,9,0,6,6,6,6,6],[1,1,1,1,1,0,1,9,1,8,8,8,1,9,1,0,1,1,1,1,1],[1,1,1,1,1,0,1,9,1,1,1,1,1,9,1,0,1,1,1,1,1],[1,1,1,1,1,0,1,9,9,9,7,9,9,9,1,0,1,1,1,1,1],[1,1,1,1,1,0,1,9,1,1,1,1,1,9,1,0,1,1,1,1,1],[1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1],[1,0,1,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,1,0,1],[1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1],[1,1,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,0,1,1,1],[1,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,1],[1,2,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,1,2,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]];
    const LEVEL_2_MAP = [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [6, 6, 6, 6, 6, 1, 0, 0, 0, 0, 0, 0, 0, 1, 6, 6, 6, 6, 6], [1, 1, 1, 1, 6, 1, 0, 1, 1, 1, 1, 1, 0, 1, 6, 1, 1, 1, 1], [1, 2, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 1], [1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1], [1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1], [1, 0, 1, 0, 1, 1, 9, 1, 1, 1, 1, 1, 9, 1, 1, 0, 1, 0, 1], [1, 0, 0, 0, 0, 1, 9, 9, 9, 9, 9, 9, 9, 1, 0, 0, 0, 0, 1], [1, 1, 1, 1, 0, 1, 9, 1, 1, 9, 1, 1, 9, 1, 0, 1, 1, 1, 1], [1, 0, 0, 0, 0, 1, 9, 1, 8, 8, 8, 1, 9, 1, 0, 0, 0, 0, 1], [1, 0, 1, 1, 0, 1, 9, 1, 8, 8, 8, 1, 9, 1, 0, 1, 1, 0, 1], [1, 0, 0, 1, 0, 9, 9, 1, 1, 1, 1, 1, 9, 9, 0, 1, 0, 0, 1], [1, 1, 0, 1, 0, 1, 9, 9, 9, 9, 9, 9, 9, 1, 0, 1, 0, 1, 1], [1, 1, 0, 1, 0, 1, 1, 9, 1, 1, 1, 9, 1, 1, 0, 1, 0, 1, 1], [1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1], [1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1], [6, 6, 0, 0, 0, 1, 0, 0, 0, 7, 0, 0, 0, 1, 0, 0, 0, 6, 6], [1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1], [1, 2, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 2, 1], [1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]];
    const LEVEL_3_MAP = [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1], [1, 2, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 2, 1], [1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1], [1, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1], [1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1], [6, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 6], [1, 0, 1, 0, 1, 1, 9, 1, 1, 1, 1, 1, 9, 1, 1, 0, 1, 0, 1], [1, 0, 1, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 1, 0, 1], [1, 0, 1, 1, 0, 1, 9, 1, 1, 9, 1, 1, 9, 1, 0, 1, 1, 0, 1], [1, 0, 1, 1, 0, 1, 9, 1, 8, 8, 8, 1, 9, 1, 0, 1, 1, 0, 1], [1, 0, 0, 0, 0, 1, 9, 1, 8, 8, 8, 1, 9, 1, 0, 0, 0, 0, 1], [1, 0, 1, 0, 1, 1, 9, 1, 1, 1, 1, 1, 9, 1, 1, 0, 1, 0, 1], [1, 0, 1, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 1, 0, 1], [1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1], [1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1], [1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1], [1, 2, 0, 1, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 1, 0, 2, 1], [1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1], [1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1], [1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1], [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]];
    const LEVEL_4_MAP = [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1], [1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1], [1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1], [1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1], [1, 2, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 2, 1], [1, 0, 0, 0, 0, 1, 9, 9, 9, 9, 9, 9, 9, 1, 0, 0, 0, 0, 1], [1, 1, 1, 1, 0, 1, 9, 1, 1, 9, 1, 1, 9, 1, 0, 1, 1, 1, 1], [6, 6, 6, 6, 0, 9, 9, 1, 8, 8, 8, 1, 9, 9, 0, 6, 6, 6, 6], [1, 1, 1, 1, 0, 1, 9, 1, 8, 8, 8, 1, 9, 1, 0, 1, 1, 1, 1], [1, 1, 1, 1, 0, 1, 9, 1, 1, 1, 1, 1, 9, 1, 0, 1, 1, 1, 1], [1, 0, 0, 0, 0, 1, 9, 9, 9, 9, 9, 9, 9, 1, 0, 0, 0, 0, 1], [1, 0, 1, 1, 0, 1, 1, 1, 9, 1, 9, 1, 1, 1, 0, 1, 1, 0, 1], [1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 1], [1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1], [1, 0, 1, 0, 0, 0, 0, 1, 0, 7, 0, 1, 0, 0, 0, 0, 1, 0, 1], [1, 2, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 2, 1], [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1], [1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1], [1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]];
    const LEVEL_5_MAP = [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [6, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 6], [1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1], [1, 1, 1, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 1, 0, 1, 1, 1], [1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1], [1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1], [1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1], [1, 0, 0, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 1], [1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1], [1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1], [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1], [1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1], [1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1], [1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1], [1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1], [1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1], [1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1], [1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1], [1, 1, 0, 1, 1, 1, 0, 9, 9, 9, 9, 9, 0, 1, 1, 1, 0, 1, 1], [1, 1, 0, 2, 0, 1, 0, 1, 1, 9, 1, 1, 0, 1, 0, 2, 0, 1, 1], [1, 1, 0, 1, 0, 1, 0, 1, 8, 8, 8, 1, 0, 1, 0, 1, 0, 1, 1], [6, 0, 0, 0, 0, 0, 0, 1, 8, 8, 8, 1, 0, 0, 0, 0, 0, 0, 6], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]];
    const LEVEL_6_MAP = [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,1],[1,2,1,1,1,1,1,0,1,1,1,0,1,1,1,1,1,2,1],[1,0,1,0,0,0,0,0,1,1,1,0,0,0,0,0,1,0,1],[1,0,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,0,1],[1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1],[1,0,1,0,1,1,1,9,1,1,1,9,1,1,1,0,1,0,1],[1,0,0,0,0,0,9,9,9,9,9,9,9,0,0,0,0,0,1],[1,1,1,1,1,1,9,1,1,9,1,1,9,1,1,1,1,1,1],[1,1,1,1,1,1,9,1,8,8,8,1,9,1,1,1,1,1,1],[6,6,6,6,6,6,9,1,8,8,8,1,9,6,6,6,6,6,6],[1,1,1,1,1,1,9,1,1,1,1,1,9,1,1,1,1,1,1],[1,0,0,0,0,1,9,9,9,7,9,9,9,1,0,0,0,0,1],[1,0,1,1,0,1,1,9,1,1,1,9,1,1,0,1,1,0,1],[1,0,0,0,0,1,1,0,0,0,0,0,1,1,0,0,0,0,1],[1,1,1,1,0,1,1,0,1,1,0,1,1,1,0,1,1,1,1],[1,0,0,0,0,1,1,0,0,0,0,0,1,1,0,0,0,0,1],[1,0,1,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,1,1,1,1,1,1,2,1,1,1,2,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]];
    const LEVEL_7_MAP = [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,1],[1,0,1,1,1,1,1,0,1,0,1,0,1,0,1,1,1,1,1,0,1],[1,0,1,2,0,0,0,0,1,0,1,0,1,0,0,0,0,2,1,0,1],[1,0,1,0,1,1,1,0,1,0,1,0,1,0,1,1,1,0,1,0,1],[1,0,1,0,1,0,0,0,1,0,1,0,1,0,0,0,1,0,1,0,1],[1,0,1,0,1,0,1,0,0,0,0,0,0,0,1,0,1,0,1,0,1],[6,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,6],[1,1,0,1,1,1,1,9,9,9,9,9,9,9,1,1,1,1,0,1,1],[1,1,0,0,0,0,0,9,1,1,9,1,1,9,0,0,0,0,0,1,1],[1,1,0,1,1,1,1,9,1,8,8,8,1,9,1,1,1,1,0,1,1],[1,1,0,1,0,0,0,9,1,8,8,8,1,9,0,0,0,1,0,1,1],[1,1,0,1,0,1,1,9,1,1,1,1,1,9,1,1,0,1,0,1,1],[1,1,0,1,0,1,1,9,9,9,9,9,9,9,1,1,0,1,0,1,1],[1,1,0,1,0,0,0,9,1,1,1,1,1,9,0,0,0,1,0,1,1],[1,1,0,1,1,1,1,9,1,0,0,0,1,9,1,1,1,1,0,1,1],[6,0,0,0,0,0,0,0,1,0,1,0,1,0,0,0,0,0,0,0,6],[1,0,1,0,1,0,1,0,0,0,1,0,0,0,1,0,1,0,1,0,1],[1,0,1,0,1,0,0,0,1,0,1,0,1,0,0,0,1,0,1,0,1],[1,0,1,0,1,1,1,0,1,0,1,0,1,0,1,1,1,0,1,0,1],[1,0,1,2,0,0,0,0,1,0,1,0,1,0,0,0,0,2,1,0,1],[1,0,1,1,1,1,1,0,1,0,1,0,1,0,1,1,1,1,1,0,1],[1,0,0,0,0,0,0,0,1,0,7,0,1,0,0,0,0,0,0,0,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]];
    const LEVEL_8_MAP = [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 1], [1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1], [6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6], [1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1], [1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 9, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1], [1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 9, 9, 9, 9, 9, 9, 9, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1], [1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 9, 1, 1, 9, 1, 1, 9, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1], [1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 9, 1, 8, 8, 8, 1, 9, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1], [1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 9, 1, 8, 8, 8, 1, 9, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1], [1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 9, 1, 1, 1, 1, 1, 9, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1], [1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 9, 9, 9, 9, 9, 9, 9, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1], [1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 7, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1], [6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6], [1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1], [1, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]];
    const LEVEL_9_MAP = [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1],[1,0,1,0,1,1,1,0,1,0,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,0,1,0,1,0,1,1,1,0,1,0,1],[1,2,1,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,1,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,1,2,1],[1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,0,1,0,1,0,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,0,1],[1,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,1],[1,1,1,0,1,1,1,0,0,0,0,0,1,1,1,9,1,1,1,1,1,9,1,1,1,0,0,0,0,0,1,1,1,0,1,1,1],[1,1,1,0,0,0,1,0,1,1,1,0,1,9,9,9,9,9,9,9,9,9,9,9,1,0,1,1,1,0,1,0,0,0,1,1,1],[1,1,1,1,1,0,1,0,1,0,0,0,1,9,1,1,1,1,9,1,1,1,1,9,1,0,0,0,1,0,1,0,1,1,1,1,1],[1,1,1,1,1,0,0,0,1,0,1,0,1,9,1,9,1,8,8,8,1,9,1,9,1,0,1,0,1,0,0,0,1,1,1,1,1],[1,1,1,1,1,1,1,0,1,0,1,0,9,9,1,9,1,8,8,8,1,9,1,9,9,0,1,0,1,0,1,1,1,1,1,1,1],[6,6,6,0,0,0,0,0,1,0,0,0,1,9,1,1,1,1,1,1,1,1,1,9,1,0,0,0,1,0,0,0,0,0,6,6,6],[1,1,1,0,1,1,1,0,1,0,1,0,1,9,9,9,9,9,9,9,9,9,9,9,1,0,1,0,1,0,1,1,1,0,1,1,1],[1,1,1,0,0,0,1,0,1,0,1,0,1,1,9,1,1,1,1,1,1,1,9,1,1,0,1,0,1,0,1,0,0,0,1,1,1],[1,1,1,1,1,0,1,0,1,0,1,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,1,0,1,0,1,0,1,1,1,1,1],[1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1,1,1,1,1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,1,0,1,1,1,0,1,1,1,0,1,0,1,0,0,0,1,0,0,0,1,0,1,0,1,1,1,0,1,1,1,0,1,0,1],[1,2,1,0,1,0,0,0,0,0,0,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,1,0,1,2,1],[1,0,1,0,1,0,1,1,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,1,1,0,1,0,1,0,1],[1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]];
    const LEVEL_10_MAP = [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [6, 6, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 6, 6], [1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1], [6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6], [1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1], [6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6], [1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1], [6, 6, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 6, 6], [1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 9, 1, 1, 1, 9, 1, 1], [6, 6, 0, 0, 0, 0, 0, 0, 0, 9, 9, 9, 9, 9, 9, 6, 6], [1, 1, 2, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 9, 1, 1, 1], [1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 8, 8, 8, 1, 1], [1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 8, 8, 8, 1, 1], [1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 2, 1, 1, 1, 1, 1, 1], [6, 6, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 6, 6], [1, 1, 1, 1, 1, 1, 1, 9, 9, 9, 1, 1, 1, 1, 1, 1, 1]];
    const LEVEL_11_MAP = [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,1],[1,1,1,0,0,0,0,1,0,1,0,0,0,0,1,1,1],[1,1,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1],[1,0,0,0,0,0,1,1,0,1,1,0,0,0,0,0,1],[1,0,1,1,1,2,9,9,9,9,9,2,1,1,1,0,1],[6,0,1,0,0,9,1,1,9,1,1,9,0,0,1,0,6],[1,1,1,0,1,9,1,8,8,8,1,9,1,0,1,1,1],[1,0,0,0,0,9,1,8,8,8,1,9,0,0,0,0,1],[1,0,1,1,1,9,1,1,1,1,1,9,1,1,1,0,1],[1,0,1,1,1,2,9,9,9,9,9,2,1,1,1,0,1],[1,0,1,0,0,0,1,0,1,0,1,0,0,0,1,0,1],[1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,0,1],[1,0,1,0,1,0,0,0,7,0,0,0,1,0,1,0,1],[1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1],[1,0,1,0,1,0,0,0,0,0,0,0,1,0,1,0,1],[1,0,1,0,1,0,1,0,1,1,1,0,1,0,1,0,1],[1,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,1],[1,1,1,1,1,0,1,1,1,0,1,0,1,1,1,1,1],[1,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,1],[1,0,1,0,1,0,1,0,1,1,1,0,1,0,1,0,1],[1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]];
    const LEVEL_12_MAP = [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1], [1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1], [1, 2, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 2, 1], [1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1], [1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1], [1, 0, 1, 0, 1, 0, 9, 9, 1, 1, 1, 1, 1, 9, 9, 0, 1, 0, 1, 0, 1], [1, 0, 1, 0, 1, 0, 1, 9, 9, 9, 9, 9, 9, 9, 1, 0, 1, 0, 1, 0, 1], [1, 0, 0, 0, 0, 0, 1, 9, 1, 1, 9, 1, 1, 9, 1, 0, 0, 0, 0, 0, 1], [1, 1, 1, 0, 1, 1, 1, 9, 1, 8, 8, 8, 1, 9, 1, 1, 1, 0, 1, 1, 1], [1, 0, 0, 0, 0, 0, 1, 9, 1, 8, 8, 8, 1, 9, 1, 0, 0, 0, 0, 0, 1], [1, 0, 1, 1, 1, 0, 1, 9, 1, 1, 1, 1, 1, 9, 1, 0, 1, 1, 1, 0, 1], [1, 0, 0, 0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0, 0, 1], [1, 0, 1, 1, 0, 1, 1, 1, 9, 1, 1, 1, 9, 1, 1, 1, 0, 1, 1, 0, 1], [1, 0, 1, 1, 0, 1, 1, 1, 0, 0, 7, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1], [1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1], [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], [1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1], [1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1], [1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1], [1, 1, 1, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]];
    const LEVEL_13_MAP = [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 9, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [1, 2, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 9, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 2, 1], [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 8, 8, 8, 1, 0, 1, 0, 1, 9, 1, 0, 0, 0, 0, 1], [1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 8, 8, 8, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1], [6, 6, 6, 6, 0, 1, 0, 0, 1, 0, 1, 9, 1, 0, 1, 9, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 6, 6, 6, 6], [1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1], [1, 2, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 2, 1], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]];
    const LEVEL_14_MAP = [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,2,0,1],[1,0,1,0,0,2,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0,1,0,1,1,1,1,1,1,0,1,0,1],[1,0,1,0,1,0,0,0,0,0,0,0,0,1,0,1,0,1,0,1,0,0,0,1,0,0,0,0,1,0,1,0,1],[1,0,1,0,1,1,1,0,1,1,0,1,0,1,0,1,0,1,0,1,1,1,0,1,0,1,1,0,1,0,1,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,1,1,9,1,1,1,9,1,1,1,9,1,1,1,9,1,1,1,1,1,9,1,1,1,9,1,1,1,9,1,1,1],[1,1,1,9,1,9,1,9,9,9,1,9,1,9,9,9,1,9,9,9,1,9,9,9,1,9,1,9,1,9,1,1,1],[6,6,6,9,1,9,1,9,1,1,1,9,1,7,1,1,1,9,1,9,1,9,1,1,1,9,1,9,1,9,6,6,6],[1,1,1,9,1,1,1,9,1,9,1,9,1,9,9,9,1,9,1,9,1,9,1,9,1,9,9,9,1,9,1,1,1],[1,1,1,9,1,9,9,9,1,1,1,9,1,1,1,9,1,9,1,9,1,9,1,1,1,9,1,9,1,9,1,1,1],[1,0,0,0,0,0,1,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,0,1,1],[1,0,1,1,1,0,1,1,1,1,1,1,0,1,1,9,1,1,0,1,1,1,1,1,0,1,1,1,0,1,0,1,1],[1,0,1,9,1,0,0,0,0,0,2,0,0,1,8,8,8,1,0,1,0,2,0,1,0,0,0,0,0,1,0,1,1],[1,0,1,1,1,0,1,1,1,1,1,1,0,1,8,8,8,1,0,1,0,1,0,1,0,1,1,1,1,1,0,0,1],[1,0,1,0,0,0,0,0,1,9,9,1,0,1,1,1,1,1,0,1,0,1,0,1,0,1,9,9,9,9,1,0,1],[1,0,1,0,1,1,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,1],[1,0,1,2,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,0,1],[1,0,1,0,1,1,1,0,1,1,1,1,0,1,0,0,0,1,0,0,0,0,0,1,0,1,1,1,1,1,1,0,1],[1,0,1,0,1,9,1,0,0,0,0,0,0,1,0,1,0,1,0,1,1,1,0,1,0,1,0,0,2,0,1,0,1],[1,0,1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,0,0,0,0,1,0,1,1,0,1,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,9,9,9,1,1,1,1,1,1,1,1,1]];
    const LEVEL_15_MAP = [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,9,1,1,1,1,1,1,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,9,1,0,0,0,0,0,1],[1,0,1,0,1,1,0,1,0,1,0,1,1,0,1,1,1,0,1,1,1,0,1],[1,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,1],[1,0,1,0,1,0,1,1,0,1,1,0,1,1,0,1,0,1,1,1,1,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,1,0,1,1,1,0,1],[1,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,1],[1,1,1,1,1,1,0,1,0,1,0,1,1,1,1,0,1,1,1,0,1,1,1],[1,0,0,0,0,0,0,0,0,9,9,9,9,1,1,0,0,1,1,0,0,0,1],[1,0,1,0,1,1,1,1,1,9,1,1,9,2,0,1,0,0,1,0,1,0,1],[1,0,1,0,0,0,0,1,1,9,1,1,9,1,0,1,1,0,0,0,1,0,1],[1,0,1,1,1,1,0,1,0,9,9,7,9,2,0,0,1,0,1,0,1,0,1],[1,0,0,0,0,0,0,1,0,1,1,9,1,1,1,0,0,0,0,0,0,0,1],[1,1,0,1,0,1,0,0,0,1,8,8,8,1,1,1,1,0,1,1,1,0,1],[9,1,0,0,0,1,0,1,0,1,8,8,8,1,1,1,1,0,0,1,0,0,1],[9,1,0,1,1,1,0,1,0,1,1,1,1,1,1,1,1,1,0,1,2,1,1],[9,1,0,0,0,0,0,1,0,1,1,1,1,1,1,1,0,0,0,0,0,1,9],[9,1,1,0,1,1,0,1,0,0,0,1,0,0,0,1,0,1,1,1,1,1,9],[9,9,1,0,1,1,0,1,0,1,0,1,0,1,0,1,0,1,9,9,9,9,9],[9,9,1,2,0,0,0,0,0,1,0,0,0,1,0,0,0,1,9,9,9,9,9],[9,9,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,9,9,9,9,9]];
    const LEVEL_16_MAP = [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,2,0,0,0,0,0,0,0,0,0,0,0,0,0,2,1],[1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1],[1,0,1,9,1,9,1,1,0,7,0,1,1,1,1,0,1],[1,0,1,1,9,1,9,1,0,1,0,1,1,1,1,0,1],[1,0,1,9,1,9,1,1,0,1,0,1,1,1,1,0,1],[1,0,1,1,1,1,1,1,0,1,0,1,1,1,1,0,1],[1,0,0,0,0,2,0,0,0,1,0,0,0,0,0,0,1],[1,0,1,1,1,1,1,1,0,1,0,1,1,1,1,0,1],[1,0,1,0,0,0,0,0,0,1,0,0,0,0,1,0,1],[1,0,1,0,1,1,1,1,9,1,9,1,1,0,1,0,1],[1,0,0,0,1,9,9,9,9,9,9,9,1,0,1,0,1],[1,0,1,0,1,9,1,1,9,1,1,9,1,0,0,0,1],[1,0,1,0,1,9,1,8,8,8,1,9,1,0,1,0,1],[1,0,1,0,9,9,1,8,8,8,1,9,1,0,1,0,1],[1,0,1,0,1,9,1,1,1,1,1,9,1,0,1,0,1],[1,0,0,0,1,9,9,9,9,9,9,9,9,0,1,0,1],[1,0,1,0,1,9,1,1,1,1,9,1,1,0,1,0,1],[1,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1],[1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1],[1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1],[1,1,0,1,0,1,0,1,0,1,1,0,1,1,0,1,1],[1,0,0,1,0,1,0,1,0,1,0,0,1,0,0,0,1],[1,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1],[1,0,0,0,0,0,0,1,2,0,0,0,0,0,0,0,1],[1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1],[1,0,1,9,9,9,9,9,9,9,9,9,9,9,1,0,1],[1,0,1,9,9,9,9,9,9,9,9,9,9,9,1,0,1],[1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1],[1,2,0,0,0,0,0,0,0,0,0,0,0,0,0,2,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]];
    let currentMap = [];

    // --- VARIABLES GLOBALES ---
    let scene, camera, renderer, dirLight, ambientLight;
    let pacmanLight; // SpotLight pour Pac-Man la nuit
    let pacman,
      ghosts = [];
    let pellets = [];
    let walls = [];
    let score = 0;
    let lives = CONFIG.GAME.LIVES;
    let nextLifeThreshold = CONFIG.GAME.NEXT_LIFE_THRESHOLD_START;
    let isGameRunning = false;
    let isGameOver = false;
    let isTransitioning = false; // Nouvelle variable pour bloquer les inputs pendant la transition
    let isDebugMode = false;
    let debugLevelIndex = 1;
    let isMsPacman = false; // <--- MODE MS PACMAN

    // --- DAY/NIGHT CYCLE VARIABLES ---
    let dayNightCycle = 0; // 0 = Jour, augmente vers 1 (nuit)
    const DAY_NIGHT_DURATION = 90000; // Durée d'un cycle complet (ms) - 90 secondes
    let dayNightStartTime = 0;
    let isNight = false;

    // POST PROCESSING VARS
    let composer, tiltShiftPass;

    // EDITOR VARS
    let isEditorMode = false;
    let currentDebugMapData = [];
    let selectedTileType = 1;
    let isMouseDownOnCanvas = false;

    let currentDir = new THREE.Vector3(0, 0, 0);
    let nextDir = new THREE.Vector3(0, 0, 0);
    // NOUVEAU: Mémorise la dernière direction de mouvement pour les contrôles relatifs
    let lastMovingDir = new THREE.Vector3(-1, 0, 0);
    let levelMapOffsetX = 0;
    let levelMapOffsetZ = 0;

    let isJumping = false;
    let jumpStartTime = 0;
    let isBouncing = false;
    let bounceStartTime = 0;
    let eatingTimer = 0;
    let powerModeEndTime = 0;
    let ghostsEatenCount = 0;
    let activeFloatingScores = [];
    let isDying = false;
    let deathStartTime = 0;
    let deathDuration = 0; // Durée variable selon le son
    let ghostReleaseTimer = 0;

    // Victoire
    let totalPellets = 0;
    let pelletsEatenCount = 0;

    // --- PARTICLE SYSTEM (FEUX D'ARTIFICE) ---
    const confettiCanvas = document.getElementById("confetti-canvas");
    let particles = [];
    let fireworkInterval = null;

    // --- DEFINITION DE LA PALETTE D'EDITION ---
    const EDITOR_PALETTE = CONFIG.PALETTE;

    // --- GESTION DES HIGH SCORES (Fonctions) ---
    function loadHighScores() {
      const stored = localStorage.getItem(LS_KEY);
      if (stored) {
        try {
          highScores = JSON.parse(stored);
        } catch (e) {
          console.error("Err parsing high scores", e);
        }
      }
      // Remplir si vide avec des scores bidons
      if (highScores.length < MAX_SCORES) {
        const defaults = [
          { name: "PAC", score: 25000, level: 10 },
          { name: "MAN", score: 20000, level: 9 },
          { name: "GHO", score: 15000, level: 8 },
          { name: "STS", score: 12000, level: 7 },
          { name: "EAT", score: 10000, level: 6 },
          { name: "YOU", score: 9000, level: 5 },
          { name: "RUN", score: 7500, level: 4 },
          { name: "AWY", score: 5000, level: 3 },
          { name: "NOW", score: 2500, level: 2 },
          { name: "PLZ", score: 1000, level: 1 },
        ];
        // Ajouter ceux qui manquent
        for (let i = highScores.length; i < MAX_SCORES; i++) {
          highScores.push(
            defaults[i] || { name: "AAA", score: 500, level: 1 },
          );
        }
        highScores.sort((a, b) => b.score - a.score);
      }
    }

    function saveScore(name, newScore, level) {
      // Ajouter un score avec le niveau
      highScores.push({ name: name, score: newScore, level: level || 1 });
      highScores.sort((a, b) => b.score - a.score);
      highScores = highScores.slice(0, MAX_SCORES);
      localStorage.setItem(LS_KEY, JSON.stringify(highScores));
    }

    // Vérifie si le score actuel est un high score
    function checkHighScore(scoreToCheck) {
      if (highScores.length < MAX_SCORES) return true;
      return scoreToCheck > highScores[MAX_SCORES - 1].score;
    }

    // --- ANIMATIONS HIGH SCORE CANVAS ---
    function renderHighScores(elapsedTime) {
      const canvas = document.getElementById("highscore-canvas");
      const ctx = canvas.getContext("2d");
      const w = canvas.width;
      const h = canvas.height;

      ctx.clearRect(0, 0, w, h);

      // Hauteur de ligne
      const rowHeight = 32;
      const startY = 40;

      // CHANGEMENT FONTE CANVAS (Plus petite)
      ctx.font = '14px "Press Start 2P", cursive'; // Réduit légèrement pour faire tenir le niveau
      ctx.textBaseline = "middle";

      // Paramètres d'animation
      // On accélère un peu le tout pour que la poursuite soit nerveuse
      const durationPerLine = 3500;
      const activeLineIndex = Math.floor(elapsedTime / durationPerLine);
      const lineProgress = (elapsedTime % durationPerLine) / durationPerLine;

      highScores.forEach((entry, index) => {
        // Si la ligne n'est pas encore active, on ne fait rien
        if (index > activeLineIndex) return;

        const y = startY + index * rowHeight;

        // --- CALCUL DES POSITIONS ---
        // Ces variables serviront au clipping ET au dessin
        let clipX = 0;
        let clipWidth = 0;

        // Etat de la ligne (passée ou en cours)
        const isFinished = index < activeLineIndex;
        const p = isFinished ? 1 : lineProgress;

        // Variables pour le dessin (scope local à la ligne)
        let animPacX = 0;
        let animGhosts = []; // { x, type: 'NORMAL'|'DEAD'|'EYES', color }

        if (index % 2 === 0) {
          // --- SCÉNARIO 1 : GAUCHE -> DROITE (Fantômes pourchassent Pacman) ---
          // Logique : Les fantômes se rapprochent de plus en plus (accélération relative)

          const startX = -200;
          const endX = w + 200;
          const totalDist = endX - startX;

          // Pacman avance linéairement
          animPacX = startX + p * totalDist;

          // Le "Lag" (retard) des fantômes diminue avec le temps (ils rattrapent)
          // Au début (p=0), ils sont à 150px. À la fin (p=1), ils sont à 40px (très proches)
          const lagStart = 150;
          const lagEnd = 40;
          const currentLag = lagStart - (lagStart - lagEnd) * p;

          const ghostColors = [
            "#FF0000",
            "#FFB8FF",
            "#00FFFF",
            "#FFB852",
            "#00FF00",
            "#800080",
          ];
          for (let i = 0; i < 6; i++) {
            // MODIFICATION : Espacement augmenté à 35px pour plus de lisibilité
            const gX = animPacX - currentLag - i * 35;
            animGhosts.push({
              x: gX,
              type: "NORMAL",
              color: ghostColors[i],
              dir: 1,
            });
          }

          // Clipping : Révélé par la queue du train (le dernier fantôme)
          const tailX = animGhosts[5].x - 20; // Marge

          if (isFinished) {
            clipX = 0;
            clipWidth = w;
          } else {
            clipX = 0;
            clipWidth = Math.max(0, tailX);
          }
        } else {
          // --- SCÉNARIO 2 : DROITE -> GAUCHE (Pacman pourchasse Fantômes Bleus) ---
          // Logique : Pacman va un peu plus vite mais ne mange pas forcément tout le monde

          const startX = w + 200;
          const endX = -300;

          // Vitesse du groupe de fantômes (plus lente)
          const ghostTotalDist = endX - startX;
          const leadGhostX = startX + p * ghostTotalDist;

          // MODIFICATION VITESSE PACMAN
          // 3 Scénarios cycliques pour varier le spectacle :
          // 0 = Pacman ne rattrape personne (finit juste derrière)
          // 1 = Pacman mange 1 fantôme
          // 2 = Pacman mange 2 fantômes
          const scenario = index % 3;

          // Pacman part de plus loin (offset positif)
          const pacStartOffset = 300;

          // Offset de fin par rapport au LEADER fantôme (le plus à gauche)
          // Les fantômes sont à : Lead, Lead+30, Lead+60, Lead+90, Lead+120, Lead+150 (Queue)
          // On va vers la gauche (X diminue). Pour doubler (manger), PacmanX doit devenir < GhostX.
          // Si Pacman finit à Lead+180 (X plus grand que Queue), il est derrière -> 0 mangé.
          // Si Pacman finit à Lead+140 (X plus petit que Queue mais plus grand que le 5eme), il mange le dernier.
          let pacEndOffsetTarget = 0;
          if (scenario === 0)
            pacEndOffsetTarget = 140; // Reste derrière tout le monde
          else if (scenario === 1)
            pacEndOffsetTarget = 80; // Mange le dernier (Lead+150)
          else pacEndOffsetTarget = 40; // Mange les 2 derniers (Lead+120 et Lead+150)

          const pacStartX = startX + pacStartOffset;
          // Position de fin de Pacman = Position Fin Leader + Offset Cible
          const pacEndX = endX + pacEndOffsetTarget;

          animPacX = pacStartX + p * (pacEndX - pacStartX);

          // Calcul des fantômes
          for (let i = 0; i < 6; i++) {
            // Fantômes alignés derrière le leader (vers la droite car ils vont à gauche)
            const gOriginalX = leadGhostX + i * 30;

            // COLLISION : Si Pacman (qui vient de la droite) dépasse le fantôme
            // Comme on va vers la gauche (X diminue), dépasser veut dire (pacX < gX)
            let state = "SCARED"; // Bleu par défaut
            let displayX = gOriginalX;

            // Seuil de collision
            if (animPacX < gOriginalX + 5) {
              state = "EYES";
              // Si mangé, les yeux fuient très vite vers la gauche
              // On estime le moment de l'impact pour calculer la distance de fuite
              // Approximation : fuite relative à la distance parcourue par Pacman depuis le dépassement
              const distSinceDeath = (gOriginalX - animPacX) * 2.5; // Vitesse de fuite x2.5
              displayX = gOriginalX - distSinceDeath;
            }

            animGhosts.push({
              x: displayX,
              type: state,
              color: "#0000FF",
              dir: -1,
            });
          }

          // Clipping : Révélé par Pacman (qui est le "balai" qui efface/révèle)
          // Pacman révèle ce qui est à sa droite (puisqu'il va vers la gauche)
          const revealerX = animPacX + 20; // Marge derrière Pacman

          if (isFinished) {
            clipX = 0;
            clipWidth = w;
          } else {
            clipX = revealerX;
            clipWidth = w - revealerX;
          }
        }

        // --- 1. DESSINER LE TEXTE (AVEC CLIPPING) ---
        ctx.save();
        ctx.beginPath();
        ctx.rect(clipX, y - rowHeight / 2, clipWidth, rowHeight);
        ctx.clip();

        // On met une ombre pour que ce soit lisible
        ctx.shadowColor = "black";
        ctx.shadowBlur = 4;
        ctx.shadowOffsetX = 2;
        ctx.shadowOffsetY = 2;

        // Rank (Aligné Droite)
        ctx.fillStyle =
          index === 0
            ? "#FFD700"
            : index === 1
              ? "#CDA080"
              : index === 2
                ? "#CD7F32"
                : "#888888";
        ctx.textAlign = "right";
        ctx.fillText(index + 1 + ".", 50, y);

        // Score (Aligné Droite, décalé vers la gauche pour laisser place au niveau)
        ctx.textAlign = "right";
        ctx.fillStyle = "#00FFFF";
        ctx.fillText(entry.score, 190, y);

        // Niveau (Aligné Droite, couleur différente)
        ctx.textAlign = "right";
        ctx.fillStyle = "#AAAAAA";
        const lvlTxt = entry.level ? "LVL " + entry.level : "LVL 1";
        ctx.fillText(lvlTxt, 295, y);

        // Name (Aligné Gauche)
        ctx.textAlign = "left";
        ctx.fillStyle = "#FF00FF";
        ctx.fillText(entry.name, 320, y);

        ctx.restore(); // Retire le clipping

        // --- 2. DESSINER LES PERSONNAGES (LIGNE ACTIVE SEULEMENT) ---
        if (index === activeLineIndex) {
          // Helpers de dessin
          const drawPacman = (px, py, dir) => {
            const size = 10;
            const mouthOpen = Math.abs(Math.sin(elapsedTime * 0.02)) * 0.5; // Mache plus vite
            ctx.fillStyle = "#FFFF00";
            ctx.beginPath();
            if (dir === 1)
              ctx.arc(px, py, size, mouthOpen, Math.PI * 2 - mouthOpen);
            else
              ctx.arc(
                px,
                py,
                size,
                Math.PI + mouthOpen,
                Math.PI * 3 - mouthOpen,
              );
            ctx.lineTo(px, py);
            ctx.fill();
          };

          const drawGhost = (px, py, type, colorHex, lookDirX) => {
            const size = 10;

            if (type !== "EYES") {
              ctx.fillStyle = colorHex;
              // Corps
              ctx.beginPath();
              ctx.arc(px, py - 2, size, Math.PI, 0);
              ctx.lineTo(px + size, py + size);
              for (let k = 1; k <= 3; k++)
                ctx.lineTo(
                  px + size - ((2 * size) / 3) * k,
                  py + size - (k % 2 == 0 ? 0 : 3),
                );
              ctx.lineTo(px - size, py + size);
              ctx.lineTo(px - size, py - 2);
              ctx.fill();
            }

            // Yeux
            ctx.fillStyle = "white";
            const eyeY = type === "EYES" ? py : py - 2; // Yeux centrés si morts
            ctx.beginPath();
            ctx.arc(px - 3, eyeY, 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(px + 3, eyeY, 3, 0, Math.PI * 2);
            ctx.fill();

            // Pupilles
            ctx.fillStyle = "blue";
            const pupOff = type === "EYES" ? -2 : lookDirX * 1.5; // Si morts, regardent vers la fuite (gauche)
            ctx.beginPath();
            ctx.arc(px - 3 + pupOff, eyeY, 1.5, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(px + 3 + pupOff, eyeY, 1.5, 0, Math.PI * 2);
            ctx.fill();
          };

          // DESSIN DES ENTITÉS CALCULÉES

          // Ordre de dessin (Z-index) :
          // Si G->D : Pacman devant (dessiné en dernier ?) Non, Pacman est à droite, fantomes à gauche.
          // On dessine de gauche à droite pour superposition correcte si chevauchement.

          if (index % 2 === 0) {
            // G->D : Fantomes puis Pacman
            animGhosts.forEach((g) =>
              drawGhost(g.x, y, g.type, g.color, g.dir),
            );
            drawPacman(animPacX, y, 1);
          } else {
            // D->G : Pacman puis Fantomes (car Pacman mange et passe devant)
            // Les fantômes sont à gauche, Pacman à droite.
            // On dessine d'abord les fantômes (arrière plan) puis Pacman
            animGhosts.forEach((g) =>
              drawGhost(g.x, y, g.type, g.color, g.dir),
            );
            drawPacman(animPacX, y, -1);
          }
        }
      });
    }

    // --- NOUVELLE FONCTION : RENDU ECRAN INFO POINTS ---
    function renderInfoScreen(elapsedTime) {
      const canvas = document.getElementById("info-canvas");
      const ctx = canvas.getContext("2d");
      const w = canvas.width;
      const h = canvas.height;

      ctx.clearRect(0, 0, w, h);
      ctx.font = '16px "Press Start 2P", cursive';
      ctx.textBaseline = "middle";

      const startY = 50;
      const lineHeight = 60;

      // Helpers de dessin (Réutilisés pour cohérence visuelle)
      const drawPacman = (px, py, dir, scale = 1) => {
        const size = 12 * scale;
        const mouthOpen = Math.abs(Math.sin(elapsedTime * 0.005)) * 0.5;
        ctx.fillStyle = "#FFFF00";
        ctx.beginPath();
        if (dir === 1)
          ctx.arc(px, py, size, mouthOpen, Math.PI * 2 - mouthOpen);
        else
          ctx.arc(px, py, size, Math.PI + mouthOpen, Math.PI * 3 - mouthOpen);
        ctx.lineTo(px, py);
        ctx.fill();
      };

      const drawGhost = (px, py, colorHex, scale = 1) => {
        const size = 12 * scale;
        ctx.fillStyle = colorHex;
        // Corps
        ctx.beginPath();
        ctx.arc(px, py - 2 * scale, size, Math.PI, 0);
        ctx.lineTo(px + size, py + size);
        for (let k = 1; k <= 3; k++)
          ctx.lineTo(
            px + size - ((2 * size) / 3) * k,
            py + size - (k % 2 == 0 ? 0 : 3 * scale),
          );
        ctx.lineTo(px - size, py + size);
        ctx.lineTo(px - size, py - 2 * scale);
        ctx.fill();
        // Yeux
        ctx.fillStyle = "white";
        ctx.beginPath();
        ctx.arc(px - 4 * scale, py - 2 * scale, 3 * scale, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(px + 4 * scale, py - 2 * scale, 3 * scale, 0, Math.PI * 2);
        ctx.fill();
        // Pupilles (regardent Pacman qui serait à gauche)
        ctx.fillStyle = "blue";
        ctx.beginPath();
        ctx.arc(
          px - 4 * scale - 1,
          py - 2 * scale,
          1.5 * scale,
          0,
          Math.PI * 2,
        );
        ctx.fill();
        ctx.beginPath();
        ctx.arc(
          px + 4 * scale - 1,
          py - 2 * scale,
          1.5 * scale,
          0,
          Math.PI * 2,
        );
        ctx.fill();
      };

      const drawPellet = (px, py, isPower) => {
        ctx.fillStyle = isPower ? "#FFD700" : "#FFB8ae";
        if (isPower) {
          // Clignotement
          if (Math.floor(elapsedTime / 200) % 2 === 0)
            ctx.fillStyle = "#FFFFFF";
          ctx.beginPath();
          ctx.arc(px, py, 10, 0, Math.PI * 2);
          ctx.fill();
        } else {
          ctx.fillRect(px - 3, py - 3, 6, 6);
        }
      };

      // LIGNE 1 : PAC-GOMME
      let y = startY;
      drawPellet(100, y, false);
      ctx.fillStyle = "#FFFFFF";
      ctx.textAlign = "left";
      ctx.fillText("PAC-GUM ......... 10 PTS", 150, y);

      // LIGNE 2 : SUPER PAC-GOMME
      y += lineHeight;
      drawPellet(100, y, true);
      ctx.fillStyle = "#FFFFFF";
      ctx.fillText("SUPER GUM ....... 50 PTS", 150, y);

      // LIGNE 3 : FANTÔMES (Séquence)
      y += lineHeight * 1.5;
      ctx.fillStyle = "#00FFFF";
      ctx.textAlign = "center";
      ctx.fillText("GHOSTS BONUS", w / 2, y - 40);

      // Dessiner 6 fantômes bleus alignés avec scores progressifs
      // Formule actuelle du jeu : 100 + (n-1)*50
      const ghostScores = [150, 225, 300, 375, 450, 525];
      const startX = 80;
      const gapX = 80;

      ghostScores.forEach((pts, i) => {
        const gx = startX + i * gapX;
        // Fantôme apeuré (Bleu)
        drawGhost(gx, y, "#0000FF", 1.2);

        // Score en dessous
        ctx.fillStyle = "#FFB8FF";
        ctx.font = '12px "Press Start 2P"';
        ctx.fillText(pts, gx, y + 40);

        // Petit index (1er, 2e...)
        ctx.fillStyle = "#AAAAAA";
        ctx.font = '10px "Press Start 2P"';
      });

      ctx.font = '16px "Press Start 2P"'; // Reset font

      // LIGNE 4 : VIES SUPPLÉMENTAIRES
      y += lineHeight * 2.5;

      // Dessin Pacman 1UP
      drawPacman(80, y, 1, 1.5);
      ctx.fillStyle = "#FFFF00";
      ctx.textAlign = "left";
      ctx.fillText("BONUS LIFE", 130, y - 10);

      ctx.fillStyle = "#FFFFFF";
      ctx.font = '12px "Press Start 2P"';
      ctx.fillText(CONFIG.GAME.NEXT_LIFE_THRESHOLD_START + " PTS", 130, y + 15);
      ctx.fillStyle = "#AAAAAA";
      ctx.fillText("THEN EVERY " + CONFIG.GAME.NEXT_LIFE_THRESHOLD_STEP + " PTS", 130, y + 35);
    }

    function initEditorPalette() {
      const container = document.getElementById("tile-palette");
      container.innerHTML = "";
      EDITOR_PALETTE.forEach((item) => {
        const el = document.createElement("div");
        el.className = "palette-item";
        if (item.type === selectedTileType) el.classList.add("selected");
        el.style.backgroundColor = item.color;
        el.style.color = item.type === 2 || item.type === 7 ? "#000" : "#fff"; // Contraste texte
        el.innerText = item.label;
        el.onclick = () => {
          selectedTileType = item.type;
          document
            .querySelectorAll(".palette-item")
            .forEach((p) => p.classList.remove("selected"));
          el.classList.add("selected");
        };
        container.appendChild(el);
      });

      // Listeners pour bouton MODIFIER
      document.getElementById("btn-edit-mode").onclick = toggleEditorMode;
      document.getElementById("btn-export").onclick = exportMapJson;

      // Canvas interaction
      const canvas = document.getElementById("debug-canvas");
      canvas.addEventListener("mousedown", (e) => {
        if (!isEditorMode) return;
        isMouseDownOnCanvas = true;
        paintTile(e);
      });
      window.addEventListener("mouseup", () => (isMouseDownOnCanvas = false));
      canvas.addEventListener("mousemove", (e) => {
        if (isMouseDownOnCanvas && isEditorMode) paintTile(e);
      });
    }

    function paintTile(e) {
      const canvas = document.getElementById("debug-canvas");
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      if (!currentDebugMapData || currentDebugMapData.length === 0) return;

      const mapHeight = currentDebugMapData.length;
      const mapWidth = currentDebugMapData[0].length;
      // Calculer cellSize comme dans drawDebugMap
      const cellSize = Math.min(
        canvas.width / mapWidth,
        canvas.height / mapHeight,
      );

      // Centrage
      const offsetX = (canvas.width - mapWidth * cellSize) / 2;
      const offsetY = (canvas.height - mapHeight * cellSize) / 2;

      const gridX = Math.floor((x - offsetX) / cellSize);
      const gridY = Math.floor((y - offsetY) / cellSize);

      if (gridX >= 0 && gridX < mapWidth && gridY >= 0 && gridY < mapHeight) {
        // Modification
        currentDebugMapData[gridY][gridX] = selectedTileType;
        drawDebugMap(currentDebugMapData);
      }
    }

    function toggleEditorMode() {
      isEditorMode = !isEditorMode;
      const controls = document.getElementById("editor-controls");
      const btn = document.getElementById("btn-edit-mode");
      const btnExport = document.getElementById("btn-export");
      const helpText = document.getElementById("debug-help");

      if (isEditorMode) {
        controls.style.display = "flex";
        btn.innerText = "BACK";
        btnExport.style.display = "inline-block";
        helpText.innerText =
          "Clic/move your mouse to paint";
      } else {
        controls.style.display = "none";
        btn.innerText = "MODIFY";
        btnExport.style.display = "none";
        helpText.innerText =
          "LEFT / RIGHT KEYS to change level, 'P' to continu";
      }
    }

    function resizeMap(dx, dy) {
      if (!isEditorMode) return;
      const oldMap = currentDebugMapData;
      const h = oldMap.length;
      const w = oldMap[0].length;
      if (dy > 0) oldMap.push(new Array(w).fill(1));
      else if (dy < 0 && h > 5) oldMap.pop();
      else if (dx > 0) for (let r = 0; r < h; r++) oldMap[r].push(1);
      else if (dx < 0 && w > 5) for (let r = 0; r < h; r++) oldMap[r].pop();
      drawDebugMap(currentDebugMapData);
    }

    function exportMapJson() {
      const json = JSON.stringify(currentDebugMapData);
      navigator.clipboard
        .writeText(json)
        .then(() => {
          alert("Level Data copied in memory");
        })
        .catch((err) => {
          console.error("Copy error", err);
          alert("Copy error");
        });
    }

    // --- Fin fonctions éditeur ---

    function createFirework(x, y) {
      const color = "hsl(" + Math.random() * 360 + ", 100%, 50%)";
      // Adaptation nombre de particules selon qualité
      const particleCount = CONFIG.GRAPHICS.PARTICLE_COUNT;

      for (let i = 0; i < particleCount; i++) {
        const angle = Math.random() * Math.PI * 2;
        // Vitesse explosive
        const speed = Math.random() * 8 + 2;

        particles.push({
          x: x,
          y: y,
          velX: Math.cos(angle) * speed,
          velY: Math.sin(angle) * speed,
          color: color,
          size: Math.random() * 4 + 2,
          drag: 0.96,
          gravity: 0.2,
          alpha: 1.0,
          decay: Math.random() * 0.02 + 0.01,
        });
      }
    }

    function updateParticles(timeScale = 1) {
      if (particles.length === 0) return;

      const ctx = confettiCanvas.getContext("2d");
      // Effacer avec légère trainée possible si on utilisait fillRect avec alpha,
      // mais ici clearRect pour netteté
      ctx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);

      for (let i = particles.length - 1; i >= 0; i--) {
        let p = particles[i];

        // Physique
        p.velX *= Math.pow(p.drag, timeScale);
        p.velY *= Math.pow(p.drag, timeScale);
        p.velY += p.gravity * timeScale;
        p.x += p.velX * timeScale;
        p.y += p.velY * timeScale;

        // Disparition progressive
        p.alpha -= p.decay * timeScale;

        if (p.alpha <= 0) {
          particles.splice(i, 1);
          continue;
        }

        ctx.globalAlpha = p.alpha;
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalAlpha = 1.0;
    }

    // --- GESTION CAMERA ---
    // 0 = Isometric (Default), 1 = Pacmania (Perspective Iso)
    let viewMode = 0;
    let currentLookAt = new THREE.Vector3(0, 0, 0);

    // Variables pour l'interpolation sphérique
    const camSpherical = new THREE.Spherical();
    const targetSpherical = new THREE.Spherical();

    // UI HELPER: Update view icon
    function updateViewIcon() {
      const iconContainer = document.getElementById("view-icon");
      let svgContent = "";

      if (viewMode === 0) {
        // ISO Icon (Cube 3D)
        svgContent = `
                <svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                    <path d="M50 10 L90 30 L50 50 L10 30 Z" fill="#FFD700" stroke="#B8860B" stroke-width="2"/>
                    <path d="M10 30 L50 50 L50 90 L10 70 Z" fill="#DAA520" stroke="#B8860B" stroke-width="2"/>
                    <path d="M90 30 L90 70 L50 90 L50 50 Z" fill="#FFC125" stroke="#B8860B" stroke-width="2"/>
                    <text x="50" y="115" font-size="20" fill="white" text-anchor="middle" font-family="monospace" font-weight="bold">ISO</text>
                </svg>`;
      } else {
        // --- MODIFICATION : NOUVELLE ICÔNE TOP VIEW ---
        // Pacmania Icon (Désormais style "Vue de dessus" / Carte)
        svgContent = `
                <svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                    <!-- Face Supérieure (Grande pour montrer la vue de dessus) -->
                    <path d="M50 10 L90 40 L50 70 L10 40 Z" fill="#00FFFF" stroke="#008888" stroke-width="2"/>
                    <!-- Grille sur le dessus pour accentuer l'effet 'Carte' -->
                    <path d="M50 10 L50 70 M10 40 L90 40" stroke="#008888" stroke-width="1" fill="none"/>
                    
                    <!-- Faces Latérales (Plus petites) -->
                    <path d="M10 40 L50 70 L50 90 L10 60 Z" fill="#00AAAA" stroke="#008888" stroke-width="2"/>
                    <path d="M90 40 L50 70 L50 90 L90 60 Z" fill="#00DDDD" stroke="#008888" stroke-width="2"/>
                    
                    <text x="50" y="115" font-size="20" fill="white" text-anchor="middle" font-family="monospace" font-weight="bold">TOP</text>
                </svg>`;
      }
      iconContainer.innerHTML = svgContent;
    }

    // Configuration Fantômes
    const GHOST_DATA = CONFIG.GHOSTS;

    // --- AUDIO SYSTEM ---
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    const audioCtx = new AudioContext();

    // ------------------------------------------------------------------
    // ZONE 1 : INTEGREZ ICI LE CONTENU DE mdx_player.js
    // ------------------------------------------------------------------
    // NOTE: Comme je ne peux pas inclure le code de la librairie ici,
    var createMdxModule = (() => {
      var _scriptName = globalThis.document?.currentScript?.src; return async function (moduleArg = {}) {
        var moduleRtn; var Module = moduleArg; var ENVIRONMENT_IS_WEB = !!globalThis.window; var ENVIRONMENT_IS_WORKER = !!globalThis.WorkerGlobalScope; var ENVIRONMENT_IS_NODE = globalThis.process?.versions?.node && globalThis.process?.type != "renderer"; var arguments_ = []; var thisProgram = "./this.program"; var quit_ = (status, toThrow) => { throw toThrow }; if (typeof __filename != "undefined") { _scriptName = __filename } else if (ENVIRONMENT_IS_WORKER) { _scriptName = self.location.href } var scriptDirectory = ""; function locateFile(path) { if (Module["locateFile"]) { return Module["locateFile"](path, scriptDirectory) } return scriptDirectory + path } var readAsync, readBinary; if (ENVIRONMENT_IS_NODE) { var fs = require("fs"); scriptDirectory = __dirname + "/"; readBinary = filename => { filename = isFileURI(filename) ? new URL(filename) : filename; var ret = fs.readFileSync(filename); return ret }; readAsync = async (filename, binary = true) => { filename = isFileURI(filename) ? new URL(filename) : filename; var ret = fs.readFileSync(filename, binary ? undefined : "utf8"); return ret }; if (process.argv.length > 1) { thisProgram = process.argv[1].replace(/\\/g, "/") } arguments_ = process.argv.slice(2); quit_ = (status, toThrow) => { process.exitCode = status; throw toThrow } } else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) { try { scriptDirectory = new URL(".", _scriptName).href } catch { } { if (ENVIRONMENT_IS_WORKER) { readBinary = url => { var xhr = new XMLHttpRequest; xhr.open("GET", url, false); xhr.responseType = "arraybuffer"; xhr.send(null); return new Uint8Array(xhr.response) } } readAsync = async url => { if (isFileURI(url)) { return new Promise((resolve, reject) => { var xhr = new XMLHttpRequest; xhr.open("GET", url, true); xhr.responseType = "arraybuffer"; xhr.onload = () => { if (xhr.status == 200 || xhr.status == 0 && xhr.response) { resolve(xhr.response); return } reject(xhr.status) }; xhr.onerror = reject; xhr.send(null) }) } var response = await fetch(url, { credentials: "same-origin" }); if (response.ok) { return response.arrayBuffer() } throw new Error(response.status + " : " + response.url) } } } else { } var out = console.log.bind(console); var err = console.error.bind(console); var wasmBinary; var ABORT = false; var isFileURI = filename => filename.startsWith("file://"); var readyPromiseResolve, readyPromiseReject; var HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64; var HEAP64, HEAPU64; var runtimeInitialized = false; function updateMemoryViews() { var b = wasmMemory.buffer; HEAP8 = new Int8Array(b); HEAP16 = new Int16Array(b); Module["HEAPU8"] = HEAPU8 = new Uint8Array(b); HEAPU16 = new Uint16Array(b); HEAP32 = new Int32Array(b); HEAPU32 = new Uint32Array(b); Module["HEAPF32"] = HEAPF32 = new Float32Array(b); HEAPF64 = new Float64Array(b); HEAP64 = new BigInt64Array(b); HEAPU64 = new BigUint64Array(b) } function preRun() { if (Module["preRun"]) { if (typeof Module["preRun"] == "function") Module["preRun"] = [Module["preRun"]]; while (Module["preRun"].length) { addOnPreRun(Module["preRun"].shift()) } } callRuntimeCallbacks(onPreRuns) } function initRuntime() { runtimeInitialized = true; if (!Module["noFSInit"] && !FS.initialized) FS.init(); TTY.init(); wasmExports["j"](); FS.ignorePermissions = false } function postRun() { if (Module["postRun"]) { if (typeof Module["postRun"] == "function") Module["postRun"] = [Module["postRun"]]; while (Module["postRun"].length) { addOnPostRun(Module["postRun"].shift()) } } callRuntimeCallbacks(onPostRuns) } function abort(what) { Module["onAbort"]?.(what); what = "Aborted(" + what + ")"; err(what); ABORT = true; what += ". Build with -sASSERTIONS for more info."; var e = new WebAssembly.RuntimeError(what); readyPromiseReject?.(e); throw e } var wasmBinaryFile; function findWasmBinary() { return locateFile("mdx_player.wasm") } function getBinarySync(file) { if (file == wasmBinaryFile && wasmBinary) { return new Uint8Array(wasmBinary) } if (readBinary) { return readBinary(file) } throw "both async and sync fetching of the wasm failed" } async function getWasmBinary(binaryFile) { if (!wasmBinary) { try { var response = await readAsync(binaryFile); return new Uint8Array(response) } catch { } } return getBinarySync(binaryFile) } async function instantiateArrayBuffer(binaryFile, imports) { try { var binary = await getWasmBinary(binaryFile); var instance = await WebAssembly.instantiate(binary, imports); return instance } catch (reason) { err(`failed to asynchronously prepare wasm: ${reason}`); abort(reason) } } async function instantiateAsync(binary, binaryFile, imports) { if (!binary && !isFileURI(binaryFile) && !ENVIRONMENT_IS_NODE) { try { var response = fetch(binaryFile, { credentials: "same-origin" }); var instantiationResult = await WebAssembly.instantiateStreaming(response, imports); return instantiationResult } catch (reason) { err(`wasm streaming compile failed: ${reason}`); err("falling back to ArrayBuffer instantiation") } } return instantiateArrayBuffer(binaryFile, imports) } function getWasmImports() { var imports = { a: wasmImports }; return imports } async function createWasm() { function receiveInstance(instance, module) { wasmExports = instance.exports; assignWasmExports(wasmExports); updateMemoryViews(); return wasmExports } function receiveInstantiationResult(result) { return receiveInstance(result["instance"]) } var info = getWasmImports(); if (Module["instantiateWasm"]) { return new Promise((resolve, reject) => { Module["instantiateWasm"](info, (inst, mod) => { resolve(receiveInstance(inst, mod)) }) }) } wasmBinaryFile ??= findWasmBinary(); var result = await instantiateAsync(wasmBinary, wasmBinaryFile, info); var exports = receiveInstantiationResult(result); return exports } class ExitStatus { name = "ExitStatus"; constructor(status) { this.message = `Program terminated with exit(${status})`; this.status = status } } var callRuntimeCallbacks = callbacks => { while (callbacks.length > 0) { callbacks.shift()(Module) } }; var onPostRuns = []; var addOnPostRun = cb => onPostRuns.push(cb); var onPreRuns = []; var addOnPreRun = cb => onPreRuns.push(cb); var noExitRuntime = true; var stackRestore = val => __emscripten_stack_restore(val); var stackSave = () => _emscripten_stack_get_current(); var syscallGetVarargI = () => { var ret = HEAP32[+SYSCALLS.varargs >> 2]; SYSCALLS.varargs += 4; return ret }; var syscallGetVarargP = syscallGetVarargI; var PATH = { isAbs: path => path.charAt(0) === "/", splitPath: filename => { var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/; return splitPathRe.exec(filename).slice(1) }, normalizeArray: (parts, allowAboveRoot) => { var up = 0; for (var i = parts.length - 1; i >= 0; i--) { var last = parts[i]; if (last === ".") { parts.splice(i, 1) } else if (last === "..") { parts.splice(i, 1); up++ } else if (up) { parts.splice(i, 1); up-- } } if (allowAboveRoot) { for (; up; up--) { parts.unshift("..") } } return parts }, normalize: path => { var isAbsolute = PATH.isAbs(path), trailingSlash = path.slice(-1) === "/"; path = PATH.normalizeArray(path.split("/").filter(p => !!p), !isAbsolute).join("/"); if (!path && !isAbsolute) { path = "." } if (path && trailingSlash) { path += "/" } return (isAbsolute ? "/" : "") + path }, dirname: path => { var result = PATH.splitPath(path), root = result[0], dir = result[1]; if (!root && !dir) { return "." } if (dir) { dir = dir.slice(0, -1) } return root + dir }, basename: path => path && path.match(/([^\/]+|\/)\/*$/)[1], join: (...paths) => PATH.normalize(paths.join("/")), join2: (l, r) => PATH.normalize(l + "/" + r) }; var initRandomFill = () => { if (ENVIRONMENT_IS_NODE) { var nodeCrypto = require("crypto"); return view => nodeCrypto.randomFillSync(view) } return view => crypto.getRandomValues(view) }; var randomFill = view => { (randomFill = initRandomFill())(view) }; var PATH_FS = { resolve: (...args) => { var resolvedPath = "", resolvedAbsolute = false; for (var i = args.length - 1; i >= -1 && !resolvedAbsolute; i--) { var path = i >= 0 ? args[i] : FS.cwd(); if (typeof path != "string") { throw new TypeError("Arguments to path.resolve must be strings") } else if (!path) { return "" } resolvedPath = path + "/" + resolvedPath; resolvedAbsolute = PATH.isAbs(path) } resolvedPath = PATH.normalizeArray(resolvedPath.split("/").filter(p => !!p), !resolvedAbsolute).join("/"); return (resolvedAbsolute ? "/" : "") + resolvedPath || "." }, relative: (from, to) => { from = PATH_FS.resolve(from).slice(1); to = PATH_FS.resolve(to).slice(1); function trim(arr) { var start = 0; for (; start < arr.length; start++) { if (arr[start] !== "") break } var end = arr.length - 1; for (; end >= 0; end--) { if (arr[end] !== "") break } if (start > end) return []; return arr.slice(start, end - start + 1) } var fromParts = trim(from.split("/")); var toParts = trim(to.split("/")); var length = Math.min(fromParts.length, toParts.length); var samePartsLength = length; for (var i = 0; i < length; i++) { if (fromParts[i] !== toParts[i]) { samePartsLength = i; break } } var outputParts = []; for (var i = samePartsLength; i < fromParts.length; i++) { outputParts.push("..") } outputParts = outputParts.concat(toParts.slice(samePartsLength)); return outputParts.join("/") } }; var UTF8Decoder = globalThis.TextDecoder && new TextDecoder; var findStringEnd = (heapOrArray, idx, maxBytesToRead, ignoreNul) => { var maxIdx = idx + maxBytesToRead; if (ignoreNul) return maxIdx; while (heapOrArray[idx] && !(idx >= maxIdx)) ++idx; return idx }; var UTF8ArrayToString = (heapOrArray, idx = 0, maxBytesToRead, ignoreNul) => { var endPtr = findStringEnd(heapOrArray, idx, maxBytesToRead, ignoreNul); if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) { return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr)) } var str = ""; while (idx < endPtr) { var u0 = heapOrArray[idx++]; if (!(u0 & 128)) { str += String.fromCharCode(u0); continue } var u1 = heapOrArray[idx++] & 63; if ((u0 & 224) == 192) { str += String.fromCharCode((u0 & 31) << 6 | u1); continue } var u2 = heapOrArray[idx++] & 63; if ((u0 & 240) == 224) { u0 = (u0 & 15) << 12 | u1 << 6 | u2 } else { u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63 } if (u0 < 65536) { str += String.fromCharCode(u0) } else { var ch = u0 - 65536; str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023) } } return str }; var FS_stdin_getChar_buffer = []; var lengthBytesUTF8 = str => { var len = 0; for (var i = 0; i < str.length; ++i) { var c = str.charCodeAt(i); if (c <= 127) { len++ } else if (c <= 2047) { len += 2 } else if (c >= 55296 && c <= 57343) { len += 4; ++i } else { len += 3 } } return len }; var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => { if (!(maxBytesToWrite > 0)) return 0; var startIdx = outIdx; var endIdx = outIdx + maxBytesToWrite - 1; for (var i = 0; i < str.length; ++i) { var u = str.codePointAt(i); if (u <= 127) { if (outIdx >= endIdx) break; heap[outIdx++] = u } else if (u <= 2047) { if (outIdx + 1 >= endIdx) break; heap[outIdx++] = 192 | u >> 6; heap[outIdx++] = 128 | u & 63 } else if (u <= 65535) { if (outIdx + 2 >= endIdx) break; heap[outIdx++] = 224 | u >> 12; heap[outIdx++] = 128 | u >> 6 & 63; heap[outIdx++] = 128 | u & 63 } else { if (outIdx + 3 >= endIdx) break; heap[outIdx++] = 240 | u >> 18; heap[outIdx++] = 128 | u >> 12 & 63; heap[outIdx++] = 128 | u >> 6 & 63; heap[outIdx++] = 128 | u & 63; i++ } } heap[outIdx] = 0; return outIdx - startIdx }; var intArrayFromString = (stringy, dontAddNull, length) => { var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1; var u8array = new Array(len); var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length); if (dontAddNull) u8array.length = numBytesWritten; return u8array }; var FS_stdin_getChar = () => { if (!FS_stdin_getChar_buffer.length) { var result = null; if (ENVIRONMENT_IS_NODE) { var BUFSIZE = 256; var buf = Buffer.alloc(BUFSIZE); var bytesRead = 0; var fd = process.stdin.fd; try { bytesRead = fs.readSync(fd, buf, 0, BUFSIZE) } catch (e) { if (e.toString().includes("EOF")) bytesRead = 0; else throw e } if (bytesRead > 0) { result = buf.slice(0, bytesRead).toString("utf-8") } } else if (globalThis.window?.prompt) { result = window.prompt("Input: "); if (result !== null) { result += "\n" } } else { } if (!result) { return null } FS_stdin_getChar_buffer = intArrayFromString(result, true) } return FS_stdin_getChar_buffer.shift() }; var TTY = { ttys: [], init() { }, shutdown() { }, register(dev, ops) { TTY.ttys[dev] = { input: [], output: [], ops }; FS.registerDevice(dev, TTY.stream_ops) }, stream_ops: { open(stream) { var tty = TTY.ttys[stream.node.rdev]; if (!tty) { throw new FS.ErrnoError(43) } stream.tty = tty; stream.seekable = false }, close(stream) { stream.tty.ops.fsync(stream.tty) }, fsync(stream) { stream.tty.ops.fsync(stream.tty) }, read(stream, buffer, offset, length, pos) { if (!stream.tty || !stream.tty.ops.get_char) { throw new FS.ErrnoError(60) } var bytesRead = 0; for (var i = 0; i < length; i++) { var result; try { result = stream.tty.ops.get_char(stream.tty) } catch (e) { throw new FS.ErrnoError(29) } if (result === undefined && bytesRead === 0) { throw new FS.ErrnoError(6) } if (result === null || result === undefined) break; bytesRead++; buffer[offset + i] = result } if (bytesRead) { stream.node.atime = Date.now() } return bytesRead }, write(stream, buffer, offset, length, pos) { if (!stream.tty || !stream.tty.ops.put_char) { throw new FS.ErrnoError(60) } try { for (var i = 0; i < length; i++) { stream.tty.ops.put_char(stream.tty, buffer[offset + i]) } } catch (e) { throw new FS.ErrnoError(29) } if (length) { stream.node.mtime = stream.node.ctime = Date.now() } return i } }, default_tty_ops: { get_char(tty) { return FS_stdin_getChar() }, put_char(tty, val) { if (val === null || val === 10) { out(UTF8ArrayToString(tty.output)); tty.output = [] } else { if (val != 0) tty.output.push(val) } }, fsync(tty) { if (tty.output?.length > 0) { out(UTF8ArrayToString(tty.output)); tty.output = [] } }, ioctl_tcgets(tty) { return { c_iflag: 25856, c_oflag: 5, c_cflag: 191, c_lflag: 35387, c_cc: [3, 28, 127, 21, 4, 0, 1, 0, 17, 19, 26, 0, 18, 15, 23, 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] } }, ioctl_tcsets(tty, optional_actions, data) { return 0 }, ioctl_tiocgwinsz(tty) { return [24, 80] } }, default_tty1_ops: { put_char(tty, val) { if (val === null || val === 10) { err(UTF8ArrayToString(tty.output)); tty.output = [] } else { if (val != 0) tty.output.push(val) } }, fsync(tty) { if (tty.output?.length > 0) { err(UTF8ArrayToString(tty.output)); tty.output = [] } } } }; var mmapAlloc = size => { abort() }; var MEMFS = { ops_table: null, mount(mount) { return MEMFS.createNode(null, "/", 16895, 0) }, createNode(parent, name, mode, dev) { if (FS.isBlkdev(mode) || FS.isFIFO(mode)) { throw new FS.ErrnoError(63) } MEMFS.ops_table ||= { dir: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr, lookup: MEMFS.node_ops.lookup, mknod: MEMFS.node_ops.mknod, rename: MEMFS.node_ops.rename, unlink: MEMFS.node_ops.unlink, rmdir: MEMFS.node_ops.rmdir, readdir: MEMFS.node_ops.readdir, symlink: MEMFS.node_ops.symlink }, stream: { llseek: MEMFS.stream_ops.llseek } }, file: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr }, stream: { llseek: MEMFS.stream_ops.llseek, read: MEMFS.stream_ops.read, write: MEMFS.stream_ops.write, mmap: MEMFS.stream_ops.mmap, msync: MEMFS.stream_ops.msync } }, link: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr, readlink: MEMFS.node_ops.readlink }, stream: {} }, chrdev: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr }, stream: FS.chrdev_stream_ops } }; var node = FS.createNode(parent, name, mode, dev); if (FS.isDir(node.mode)) { node.node_ops = MEMFS.ops_table.dir.node; node.stream_ops = MEMFS.ops_table.dir.stream; node.contents = {} } else if (FS.isFile(node.mode)) { node.node_ops = MEMFS.ops_table.file.node; node.stream_ops = MEMFS.ops_table.file.stream; node.usedBytes = 0; node.contents = null } else if (FS.isLink(node.mode)) { node.node_ops = MEMFS.ops_table.link.node; node.stream_ops = MEMFS.ops_table.link.stream } else if (FS.isChrdev(node.mode)) { node.node_ops = MEMFS.ops_table.chrdev.node; node.stream_ops = MEMFS.ops_table.chrdev.stream } node.atime = node.mtime = node.ctime = Date.now(); if (parent) { parent.contents[name] = node; parent.atime = parent.mtime = parent.ctime = node.atime } return node }, getFileDataAsTypedArray(node) { if (!node.contents) return new Uint8Array(0); if (node.contents.subarray) return node.contents.subarray(0, node.usedBytes); return new Uint8Array(node.contents) }, expandFileStorage(node, newCapacity) { var prevCapacity = node.contents ? node.contents.length : 0; if (prevCapacity >= newCapacity) return; var CAPACITY_DOUBLING_MAX = 1024 * 1024; newCapacity = Math.max(newCapacity, prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0); if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256); var oldContents = node.contents; node.contents = new Uint8Array(newCapacity); if (node.usedBytes > 0) node.contents.set(oldContents.subarray(0, node.usedBytes), 0) }, resizeFileStorage(node, newSize) { if (node.usedBytes == newSize) return; if (newSize == 0) { node.contents = null; node.usedBytes = 0 } else { var oldContents = node.contents; node.contents = new Uint8Array(newSize); if (oldContents) { node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes))) } node.usedBytes = newSize } }, node_ops: { getattr(node) { var attr = {}; attr.dev = FS.isChrdev(node.mode) ? node.id : 1; attr.ino = node.id; attr.mode = node.mode; attr.nlink = 1; attr.uid = 0; attr.gid = 0; attr.rdev = node.rdev; if (FS.isDir(node.mode)) { attr.size = 4096 } else if (FS.isFile(node.mode)) { attr.size = node.usedBytes } else if (FS.isLink(node.mode)) { attr.size = node.link.length } else { attr.size = 0 } attr.atime = new Date(node.atime); attr.mtime = new Date(node.mtime); attr.ctime = new Date(node.ctime); attr.blksize = 4096; attr.blocks = Math.ceil(attr.size / attr.blksize); return attr }, setattr(node, attr) { for (const key of ["mode", "atime", "mtime", "ctime"]) { if (attr[key] != null) { node[key] = attr[key] } } if (attr.size !== undefined) { MEMFS.resizeFileStorage(node, attr.size) } }, lookup(parent, name) { if (!MEMFS.doesNotExistError) { MEMFS.doesNotExistError = new FS.ErrnoError(44); MEMFS.doesNotExistError.stack = "<generic error, no stack>" } throw MEMFS.doesNotExistError }, mknod(parent, name, mode, dev) { return MEMFS.createNode(parent, name, mode, dev) }, rename(old_node, new_dir, new_name) { var new_node; try { new_node = FS.lookupNode(new_dir, new_name) } catch (e) { } if (new_node) { if (FS.isDir(old_node.mode)) { for (var i in new_node.contents) { throw new FS.ErrnoError(55) } } FS.hashRemoveNode(new_node) } delete old_node.parent.contents[old_node.name]; new_dir.contents[new_name] = old_node; old_node.name = new_name; new_dir.ctime = new_dir.mtime = old_node.parent.ctime = old_node.parent.mtime = Date.now() }, unlink(parent, name) { delete parent.contents[name]; parent.ctime = parent.mtime = Date.now() }, rmdir(parent, name) { var node = FS.lookupNode(parent, name); for (var i in node.contents) { throw new FS.ErrnoError(55) } delete parent.contents[name]; parent.ctime = parent.mtime = Date.now() }, readdir(node) { return [".", "..", ...Object.keys(node.contents)] }, symlink(parent, newname, oldpath) { var node = MEMFS.createNode(parent, newname, 511 | 40960, 0); node.link = oldpath; return node }, readlink(node) { if (!FS.isLink(node.mode)) { throw new FS.ErrnoError(28) } return node.link } }, stream_ops: { read(stream, buffer, offset, length, position) { var contents = stream.node.contents; if (position >= stream.node.usedBytes) return 0; var size = Math.min(stream.node.usedBytes - position, length); if (size > 8 && contents.subarray) { buffer.set(contents.subarray(position, position + size), offset) } else { for (var i = 0; i < size; i++)buffer[offset + i] = contents[position + i] } return size }, write(stream, buffer, offset, length, position, canOwn) { if (buffer.buffer === HEAP8.buffer) { canOwn = false } if (!length) return 0; var node = stream.node; node.mtime = node.ctime = Date.now(); if (buffer.subarray && (!node.contents || node.contents.subarray)) { if (canOwn) { node.contents = buffer.subarray(offset, offset + length); node.usedBytes = length; return length } else if (node.usedBytes === 0 && position === 0) { node.contents = buffer.slice(offset, offset + length); node.usedBytes = length; return length } else if (position + length <= node.usedBytes) { node.contents.set(buffer.subarray(offset, offset + length), position); return length } } MEMFS.expandFileStorage(node, position + length); if (node.contents.subarray && buffer.subarray) { node.contents.set(buffer.subarray(offset, offset + length), position) } else { for (var i = 0; i < length; i++) { node.contents[position + i] = buffer[offset + i] } } node.usedBytes = Math.max(node.usedBytes, position + length); return length }, llseek(stream, offset, whence) { var position = offset; if (whence === 1) { position += stream.position } else if (whence === 2) { if (FS.isFile(stream.node.mode)) { position += stream.node.usedBytes } } if (position < 0) { throw new FS.ErrnoError(28) } return position }, mmap(stream, length, position, prot, flags) { if (!FS.isFile(stream.node.mode)) { throw new FS.ErrnoError(43) } var ptr; var allocated; var contents = stream.node.contents; if (!(flags & 2) && contents && contents.buffer === HEAP8.buffer) { allocated = false; ptr = contents.byteOffset } else { allocated = true; ptr = mmapAlloc(length); if (!ptr) { throw new FS.ErrnoError(48) } if (contents) { if (position > 0 || position + length < contents.length) { if (contents.subarray) { contents = contents.subarray(position, position + length) } else { contents = Array.prototype.slice.call(contents, position, position + length) } } HEAP8.set(contents, ptr) } } return { ptr, allocated } }, msync(stream, buffer, offset, length, mmapFlags) { MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false); return 0 } } }; var FS_modeStringToFlags = str => { var flagModes = { r: 0, "r+": 2, w: 512 | 64 | 1, "w+": 512 | 64 | 2, a: 1024 | 64 | 1, "a+": 1024 | 64 | 2 }; var flags = flagModes[str]; if (typeof flags == "undefined") { throw new Error(`Unknown file open mode: ${str}`) } return flags }; var FS_getMode = (canRead, canWrite) => { var mode = 0; if (canRead) mode |= 292 | 73; if (canWrite) mode |= 146; return mode }; var asyncLoad = async url => { var arrayBuffer = await readAsync(url); return new Uint8Array(arrayBuffer) }; var FS_createDataFile = (...args) => FS.createDataFile(...args); var getUniqueRunDependency = id => id; var runDependencies = 0; var dependenciesFulfilled = null; var removeRunDependency = id => { runDependencies--; Module["monitorRunDependencies"]?.(runDependencies); if (runDependencies == 0) { if (dependenciesFulfilled) { var callback = dependenciesFulfilled; dependenciesFulfilled = null; callback() } } }; var addRunDependency = id => { runDependencies++; Module["monitorRunDependencies"]?.(runDependencies) }; var preloadPlugins = []; var FS_handledByPreloadPlugin = async (byteArray, fullname) => { if (typeof Browser != "undefined") Browser.init(); for (var plugin of preloadPlugins) { if (plugin["canHandle"](fullname)) { return plugin["handle"](byteArray, fullname) } } return byteArray }; var FS_preloadFile = async (parent, name, url, canRead, canWrite, dontCreateFile, canOwn, preFinish) => { var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent; var dep = getUniqueRunDependency(`cp ${fullname}`); addRunDependency(dep); try { var byteArray = url; if (typeof url == "string") { byteArray = await asyncLoad(url) } byteArray = await FS_handledByPreloadPlugin(byteArray, fullname); preFinish?.(); if (!dontCreateFile) { FS_createDataFile(parent, name, byteArray, canRead, canWrite, canOwn) } } finally { removeRunDependency(dep) } }; var FS_createPreloadedFile = (parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) => { FS_preloadFile(parent, name, url, canRead, canWrite, dontCreateFile, canOwn, preFinish).then(onload).catch(onerror) }; var FS = { root: null, mounts: [], devices: {}, streams: [], nextInode: 1, nameTable: null, currentPath: "/", initialized: false, ignorePermissions: true, filesystems: null, syncFSRequests: 0, readFiles: {}, ErrnoError: class { name = "ErrnoError"; constructor(errno) { this.errno = errno } }, FSStream: class { shared = {}; get object() { return this.node } set object(val) { this.node = val } get isRead() { return (this.flags & 2097155) !== 1 } get isWrite() { return (this.flags & 2097155) !== 0 } get isAppend() { return this.flags & 1024 } get flags() { return this.shared.flags } set flags(val) { this.shared.flags = val } get position() { return this.shared.position } set position(val) { this.shared.position = val } }, FSNode: class { node_ops = {}; stream_ops = {}; readMode = 292 | 73; writeMode = 146; mounted = null; constructor(parent, name, mode, rdev) { if (!parent) { parent = this } this.parent = parent; this.mount = parent.mount; this.id = FS.nextInode++; this.name = name; this.mode = mode; this.rdev = rdev; this.atime = this.mtime = this.ctime = Date.now() } get read() { return (this.mode & this.readMode) === this.readMode } set read(val) { val ? this.mode |= this.readMode : this.mode &= ~this.readMode } get write() { return (this.mode & this.writeMode) === this.writeMode } set write(val) { val ? this.mode |= this.writeMode : this.mode &= ~this.writeMode } get isFolder() { return FS.isDir(this.mode) } get isDevice() { return FS.isChrdev(this.mode) } }, lookupPath(path, opts = {}) { if (!path) { throw new FS.ErrnoError(44) } opts.follow_mount ??= true; if (!PATH.isAbs(path)) { path = FS.cwd() + "/" + path } linkloop: for (var nlinks = 0; nlinks < 40; nlinks++) { var parts = path.split("/").filter(p => !!p); var current = FS.root; var current_path = "/"; for (var i = 0; i < parts.length; i++) { var islast = i === parts.length - 1; if (islast && opts.parent) { break } if (parts[i] === ".") { continue } if (parts[i] === "..") { current_path = PATH.dirname(current_path); if (FS.isRoot(current)) { path = current_path + "/" + parts.slice(i + 1).join("/"); nlinks--; continue linkloop } else { current = current.parent } continue } current_path = PATH.join2(current_path, parts[i]); try { current = FS.lookupNode(current, parts[i]) } catch (e) { if (e?.errno === 44 && islast && opts.noent_okay) { return { path: current_path } } throw e } if (FS.isMountpoint(current) && (!islast || opts.follow_mount)) { current = current.mounted.root } if (FS.isLink(current.mode) && (!islast || opts.follow)) { if (!current.node_ops.readlink) { throw new FS.ErrnoError(52) } var link = current.node_ops.readlink(current); if (!PATH.isAbs(link)) { link = PATH.dirname(current_path) + "/" + link } path = link + "/" + parts.slice(i + 1).join("/"); continue linkloop } } return { path: current_path, node: current } } throw new FS.ErrnoError(32) }, getPath(node) { var path; while (true) { if (FS.isRoot(node)) { var mount = node.mount.mountpoint; if (!path) return mount; return mount[mount.length - 1] !== "/" ? `${mount}/${path}` : mount + path } path = path ? `${node.name}/${path}` : node.name; node = node.parent } }, hashName(parentid, name) { var hash = 0; for (var i = 0; i < name.length; i++) { hash = (hash << 5) - hash + name.charCodeAt(i) | 0 } return (parentid + hash >>> 0) % FS.nameTable.length }, hashAddNode(node) { var hash = FS.hashName(node.parent.id, node.name); node.name_next = FS.nameTable[hash]; FS.nameTable[hash] = node }, hashRemoveNode(node) { var hash = FS.hashName(node.parent.id, node.name); if (FS.nameTable[hash] === node) { FS.nameTable[hash] = node.name_next } else { var current = FS.nameTable[hash]; while (current) { if (current.name_next === node) { current.name_next = node.name_next; break } current = current.name_next } } }, lookupNode(parent, name) { var errCode = FS.mayLookup(parent); if (errCode) { throw new FS.ErrnoError(errCode) } var hash = FS.hashName(parent.id, name); for (var node = FS.nameTable[hash]; node; node = node.name_next) { var nodeName = node.name; if (node.parent.id === parent.id && nodeName === name) { return node } } return FS.lookup(parent, name) }, createNode(parent, name, mode, rdev) { var node = new FS.FSNode(parent, name, mode, rdev); FS.hashAddNode(node); return node }, destroyNode(node) { FS.hashRemoveNode(node) }, isRoot(node) { return node === node.parent }, isMountpoint(node) { return !!node.mounted }, isFile(mode) { return (mode & 61440) === 32768 }, isDir(mode) { return (mode & 61440) === 16384 }, isLink(mode) { return (mode & 61440) === 40960 }, isChrdev(mode) { return (mode & 61440) === 8192 }, isBlkdev(mode) { return (mode & 61440) === 24576 }, isFIFO(mode) { return (mode & 61440) === 4096 }, isSocket(mode) { return (mode & 49152) === 49152 }, flagsToPermissionString(flag) { var perms = ["r", "w", "rw"][flag & 3]; if (flag & 512) { perms += "w" } return perms }, nodePermissions(node, perms) { if (FS.ignorePermissions) { return 0 } if (perms.includes("r") && !(node.mode & 292)) { return 2 } else if (perms.includes("w") && !(node.mode & 146)) { return 2 } else if (perms.includes("x") && !(node.mode & 73)) { return 2 } return 0 }, mayLookup(dir) { if (!FS.isDir(dir.mode)) return 54; var errCode = FS.nodePermissions(dir, "x"); if (errCode) return errCode; if (!dir.node_ops.lookup) return 2; return 0 }, mayCreate(dir, name) { if (!FS.isDir(dir.mode)) { return 54 } try { var node = FS.lookupNode(dir, name); return 20 } catch (e) { } return FS.nodePermissions(dir, "wx") }, mayDelete(dir, name, isdir) { var node; try { node = FS.lookupNode(dir, name) } catch (e) { return e.errno } var errCode = FS.nodePermissions(dir, "wx"); if (errCode) { return errCode } if (isdir) { if (!FS.isDir(node.mode)) { return 54 } if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) { return 10 } } else { if (FS.isDir(node.mode)) { return 31 } } return 0 }, mayOpen(node, flags) { if (!node) { return 44 } if (FS.isLink(node.mode)) { return 32 } else if (FS.isDir(node.mode)) { if (FS.flagsToPermissionString(flags) !== "r" || flags & (512 | 64)) { return 31 } } return FS.nodePermissions(node, FS.flagsToPermissionString(flags)) }, checkOpExists(op, err) { if (!op) { throw new FS.ErrnoError(err) } return op }, MAX_OPEN_FDS: 4096, nextfd() { for (var fd = 0; fd <= FS.MAX_OPEN_FDS; fd++) { if (!FS.streams[fd]) { return fd } } throw new FS.ErrnoError(33) }, getStreamChecked(fd) { var stream = FS.getStream(fd); if (!stream) { throw new FS.ErrnoError(8) } return stream }, getStream: fd => FS.streams[fd], createStream(stream, fd = -1) { stream = Object.assign(new FS.FSStream, stream); if (fd == -1) { fd = FS.nextfd() } stream.fd = fd; FS.streams[fd] = stream; return stream }, closeStream(fd) { FS.streams[fd] = null }, dupStream(origStream, fd = -1) { var stream = FS.createStream(origStream, fd); stream.stream_ops?.dup?.(stream); return stream }, doSetAttr(stream, node, attr) { var setattr = stream?.stream_ops.setattr; var arg = setattr ? stream : node; setattr ??= node.node_ops.setattr; FS.checkOpExists(setattr, 63); setattr(arg, attr) }, chrdev_stream_ops: { open(stream) { var device = FS.getDevice(stream.node.rdev); stream.stream_ops = device.stream_ops; stream.stream_ops.open?.(stream) }, llseek() { throw new FS.ErrnoError(70) } }, major: dev => dev >> 8, minor: dev => dev & 255, makedev: (ma, mi) => ma << 8 | mi, registerDevice(dev, ops) { FS.devices[dev] = { stream_ops: ops } }, getDevice: dev => FS.devices[dev], getMounts(mount) { var mounts = []; var check = [mount]; while (check.length) { var m = check.pop(); mounts.push(m); check.push(...m.mounts) } return mounts }, syncfs(populate, callback) { if (typeof populate == "function") { callback = populate; populate = false } FS.syncFSRequests++; if (FS.syncFSRequests > 1) { err(`warning: ${FS.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`) } var mounts = FS.getMounts(FS.root.mount); var completed = 0; function doCallback(errCode) { FS.syncFSRequests--; return callback(errCode) } function done(errCode) { if (errCode) { if (!done.errored) { done.errored = true; return doCallback(errCode) } return } if (++completed >= mounts.length) { doCallback(null) } } for (var mount of mounts) { if (mount.type.syncfs) { mount.type.syncfs(mount, populate, done) } else { done(null) } } }, mount(type, opts, mountpoint) { var root = mountpoint === "/"; var pseudo = !mountpoint; var node; if (root && FS.root) { throw new FS.ErrnoError(10) } else if (!root && !pseudo) { var lookup = FS.lookupPath(mountpoint, { follow_mount: false }); mountpoint = lookup.path; node = lookup.node; if (FS.isMountpoint(node)) { throw new FS.ErrnoError(10) } if (!FS.isDir(node.mode)) { throw new FS.ErrnoError(54) } } var mount = { type, opts, mountpoint, mounts: [] }; var mountRoot = type.mount(mount); mountRoot.mount = mount; mount.root = mountRoot; if (root) { FS.root = mountRoot } else if (node) { node.mounted = mount; if (node.mount) { node.mount.mounts.push(mount) } } return mountRoot }, unmount(mountpoint) { var lookup = FS.lookupPath(mountpoint, { follow_mount: false }); if (!FS.isMountpoint(lookup.node)) { throw new FS.ErrnoError(28) } var node = lookup.node; var mount = node.mounted; var mounts = FS.getMounts(mount); for (var [hash, current] of Object.entries(FS.nameTable)) { while (current) { var next = current.name_next; if (mounts.includes(current.mount)) { FS.destroyNode(current) } current = next } } node.mounted = null; var idx = node.mount.mounts.indexOf(mount); node.mount.mounts.splice(idx, 1) }, lookup(parent, name) { return parent.node_ops.lookup(parent, name) }, mknod(path, mode, dev) { var lookup = FS.lookupPath(path, { parent: true }); var parent = lookup.node; var name = PATH.basename(path); if (!name) { throw new FS.ErrnoError(28) } if (name === "." || name === "..") { throw new FS.ErrnoError(20) } var errCode = FS.mayCreate(parent, name); if (errCode) { throw new FS.ErrnoError(errCode) } if (!parent.node_ops.mknod) { throw new FS.ErrnoError(63) } return parent.node_ops.mknod(parent, name, mode, dev) }, statfs(path) { return FS.statfsNode(FS.lookupPath(path, { follow: true }).node) }, statfsStream(stream) { return FS.statfsNode(stream.node) }, statfsNode(node) { var rtn = { bsize: 4096, frsize: 4096, blocks: 1e6, bfree: 5e5, bavail: 5e5, files: FS.nextInode, ffree: FS.nextInode - 1, fsid: 42, flags: 2, namelen: 255 }; if (node.node_ops.statfs) { Object.assign(rtn, node.node_ops.statfs(node.mount.opts.root)) } return rtn }, create(path, mode = 438) { mode &= 4095; mode |= 32768; return FS.mknod(path, mode, 0) }, mkdir(path, mode = 511) { mode &= 511 | 512; mode |= 16384; return FS.mknod(path, mode, 0) }, mkdirTree(path, mode) { var dirs = path.split("/"); var d = ""; for (var dir of dirs) { if (!dir) continue; if (d || PATH.isAbs(path)) d += "/"; d += dir; try { FS.mkdir(d, mode) } catch (e) { if (e.errno != 20) throw e } } }, mkdev(path, mode, dev) { if (typeof dev == "undefined") { dev = mode; mode = 438 } mode |= 8192; return FS.mknod(path, mode, dev) }, symlink(oldpath, newpath) { if (!PATH_FS.resolve(oldpath)) { throw new FS.ErrnoError(44) } var lookup = FS.lookupPath(newpath, { parent: true }); var parent = lookup.node; if (!parent) { throw new FS.ErrnoError(44) } var newname = PATH.basename(newpath); var errCode = FS.mayCreate(parent, newname); if (errCode) { throw new FS.ErrnoError(errCode) } if (!parent.node_ops.symlink) { throw new FS.ErrnoError(63) } return parent.node_ops.symlink(parent, newname, oldpath) }, rename(old_path, new_path) { var old_dirname = PATH.dirname(old_path); var new_dirname = PATH.dirname(new_path); var old_name = PATH.basename(old_path); var new_name = PATH.basename(new_path); var lookup, old_dir, new_dir; lookup = FS.lookupPath(old_path, { parent: true }); old_dir = lookup.node; lookup = FS.lookupPath(new_path, { parent: true }); new_dir = lookup.node; if (!old_dir || !new_dir) throw new FS.ErrnoError(44); if (old_dir.mount !== new_dir.mount) { throw new FS.ErrnoError(75) } var old_node = FS.lookupNode(old_dir, old_name); var relative = PATH_FS.relative(old_path, new_dirname); if (relative.charAt(0) !== ".") { throw new FS.ErrnoError(28) } relative = PATH_FS.relative(new_path, old_dirname); if (relative.charAt(0) !== ".") { throw new FS.ErrnoError(55) } var new_node; try { new_node = FS.lookupNode(new_dir, new_name) } catch (e) { } if (old_node === new_node) { return } var isdir = FS.isDir(old_node.mode); var errCode = FS.mayDelete(old_dir, old_name, isdir); if (errCode) { throw new FS.ErrnoError(errCode) } errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name); if (errCode) { throw new FS.ErrnoError(errCode) } if (!old_dir.node_ops.rename) { throw new FS.ErrnoError(63) } if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) { throw new FS.ErrnoError(10) } if (new_dir !== old_dir) { errCode = FS.nodePermissions(old_dir, "w"); if (errCode) { throw new FS.ErrnoError(errCode) } } FS.hashRemoveNode(old_node); try { old_dir.node_ops.rename(old_node, new_dir, new_name); old_node.parent = new_dir } catch (e) { throw e } finally { FS.hashAddNode(old_node) } }, rmdir(path) { var lookup = FS.lookupPath(path, { parent: true }); var parent = lookup.node; var name = PATH.basename(path); var node = FS.lookupNode(parent, name); var errCode = FS.mayDelete(parent, name, true); if (errCode) { throw new FS.ErrnoError(errCode) } if (!parent.node_ops.rmdir) { throw new FS.ErrnoError(63) } if (FS.isMountpoint(node)) { throw new FS.ErrnoError(10) } parent.node_ops.rmdir(parent, name); FS.destroyNode(node) }, readdir(path) { var lookup = FS.lookupPath(path, { follow: true }); var node = lookup.node; var readdir = FS.checkOpExists(node.node_ops.readdir, 54); return readdir(node) }, unlink(path) { var lookup = FS.lookupPath(path, { parent: true }); var parent = lookup.node; if (!parent) { throw new FS.ErrnoError(44) } var name = PATH.basename(path); var node = FS.lookupNode(parent, name); var errCode = FS.mayDelete(parent, name, false); if (errCode) { throw new FS.ErrnoError(errCode) } if (!parent.node_ops.unlink) { throw new FS.ErrnoError(63) } if (FS.isMountpoint(node)) { throw new FS.ErrnoError(10) } parent.node_ops.unlink(parent, name); FS.destroyNode(node) }, readlink(path) { var lookup = FS.lookupPath(path); var link = lookup.node; if (!link) { throw new FS.ErrnoError(44) } if (!link.node_ops.readlink) { throw new FS.ErrnoError(28) } return link.node_ops.readlink(link) }, stat(path, dontFollow) { var lookup = FS.lookupPath(path, { follow: !dontFollow }); var node = lookup.node; var getattr = FS.checkOpExists(node.node_ops.getattr, 63); return getattr(node) }, fstat(fd) { var stream = FS.getStreamChecked(fd); var node = stream.node; var getattr = stream.stream_ops.getattr; var arg = getattr ? stream : node; getattr ??= node.node_ops.getattr; FS.checkOpExists(getattr, 63); return getattr(arg) }, lstat(path) { return FS.stat(path, true) }, doChmod(stream, node, mode, dontFollow) { FS.doSetAttr(stream, node, { mode: mode & 4095 | node.mode & ~4095, ctime: Date.now(), dontFollow }) }, chmod(path, mode, dontFollow) { var node; if (typeof path == "string") { var lookup = FS.lookupPath(path, { follow: !dontFollow }); node = lookup.node } else { node = path } FS.doChmod(null, node, mode, dontFollow) }, lchmod(path, mode) { FS.chmod(path, mode, true) }, fchmod(fd, mode) { var stream = FS.getStreamChecked(fd); FS.doChmod(stream, stream.node, mode, false) }, doChown(stream, node, dontFollow) { FS.doSetAttr(stream, node, { timestamp: Date.now(), dontFollow }) }, chown(path, uid, gid, dontFollow) { var node; if (typeof path == "string") { var lookup = FS.lookupPath(path, { follow: !dontFollow }); node = lookup.node } else { node = path } FS.doChown(null, node, dontFollow) }, lchown(path, uid, gid) { FS.chown(path, uid, gid, true) }, fchown(fd, uid, gid) { var stream = FS.getStreamChecked(fd); FS.doChown(stream, stream.node, false) }, doTruncate(stream, node, len) { if (FS.isDir(node.mode)) { throw new FS.ErrnoError(31) } if (!FS.isFile(node.mode)) { throw new FS.ErrnoError(28) } var errCode = FS.nodePermissions(node, "w"); if (errCode) { throw new FS.ErrnoError(errCode) } FS.doSetAttr(stream, node, { size: len, timestamp: Date.now() }) }, truncate(path, len) { if (len < 0) { throw new FS.ErrnoError(28) } var node; if (typeof path == "string") { var lookup = FS.lookupPath(path, { follow: true }); node = lookup.node } else { node = path } FS.doTruncate(null, node, len) }, ftruncate(fd, len) { var stream = FS.getStreamChecked(fd); if (len < 0 || (stream.flags & 2097155) === 0) { throw new FS.ErrnoError(28) } FS.doTruncate(stream, stream.node, len) }, utime(path, atime, mtime) { var lookup = FS.lookupPath(path, { follow: true }); var node = lookup.node; var setattr = FS.checkOpExists(node.node_ops.setattr, 63); setattr(node, { atime, mtime }) }, open(path, flags, mode = 438) { if (path === "") { throw new FS.ErrnoError(44) } flags = typeof flags == "string" ? FS_modeStringToFlags(flags) : flags; if (flags & 64) { mode = mode & 4095 | 32768 } else { mode = 0 } var node; var isDirPath; if (typeof path == "object") { node = path } else { isDirPath = path.endsWith("/"); var lookup = FS.lookupPath(path, { follow: !(flags & 131072), noent_okay: true }); node = lookup.node; path = lookup.path } var created = false; if (flags & 64) { if (node) { if (flags & 128) { throw new FS.ErrnoError(20) } } else if (isDirPath) { throw new FS.ErrnoError(31) } else { node = FS.mknod(path, mode | 511, 0); created = true } } if (!node) { throw new FS.ErrnoError(44) } if (FS.isChrdev(node.mode)) { flags &= ~512 } if (flags & 65536 && !FS.isDir(node.mode)) { throw new FS.ErrnoError(54) } if (!created) { var errCode = FS.mayOpen(node, flags); if (errCode) { throw new FS.ErrnoError(errCode) } } if (flags & 512 && !created) { FS.truncate(node, 0) } flags &= ~(128 | 512 | 131072); var stream = FS.createStream({ node, path: FS.getPath(node), flags, seekable: true, position: 0, stream_ops: node.stream_ops, ungotten: [], error: false }); if (stream.stream_ops.open) { stream.stream_ops.open(stream) } if (created) { FS.chmod(node, mode & 511) } if (Module["logReadFiles"] && !(flags & 1)) { if (!(path in FS.readFiles)) { FS.readFiles[path] = 1 } } return stream }, close(stream) { if (FS.isClosed(stream)) { throw new FS.ErrnoError(8) } if (stream.getdents) stream.getdents = null; try { if (stream.stream_ops.close) { stream.stream_ops.close(stream) } } catch (e) { throw e } finally { FS.closeStream(stream.fd) } stream.fd = null }, isClosed(stream) { return stream.fd === null }, llseek(stream, offset, whence) { if (FS.isClosed(stream)) { throw new FS.ErrnoError(8) } if (!stream.seekable || !stream.stream_ops.llseek) { throw new FS.ErrnoError(70) } if (whence != 0 && whence != 1 && whence != 2) { throw new FS.ErrnoError(28) } stream.position = stream.stream_ops.llseek(stream, offset, whence); stream.ungotten = []; return stream.position }, read(stream, buffer, offset, length, position) { if (length < 0 || position < 0) { throw new FS.ErrnoError(28) } if (FS.isClosed(stream)) { throw new FS.ErrnoError(8) } if ((stream.flags & 2097155) === 1) { throw new FS.ErrnoError(8) } if (FS.isDir(stream.node.mode)) { throw new FS.ErrnoError(31) } if (!stream.stream_ops.read) { throw new FS.ErrnoError(28) } var seeking = typeof position != "undefined"; if (!seeking) { position = stream.position } else if (!stream.seekable) { throw new FS.ErrnoError(70) } var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position); if (!seeking) stream.position += bytesRead; return bytesRead }, write(stream, buffer, offset, length, position, canOwn) { if (length < 0 || position < 0) { throw new FS.ErrnoError(28) } if (FS.isClosed(stream)) { throw new FS.ErrnoError(8) } if ((stream.flags & 2097155) === 0) { throw new FS.ErrnoError(8) } if (FS.isDir(stream.node.mode)) { throw new FS.ErrnoError(31) } if (!stream.stream_ops.write) { throw new FS.ErrnoError(28) } if (stream.seekable && stream.flags & 1024) { FS.llseek(stream, 0, 2) } var seeking = typeof position != "undefined"; if (!seeking) { position = stream.position } else if (!stream.seekable) { throw new FS.ErrnoError(70) } var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn); if (!seeking) stream.position += bytesWritten; return bytesWritten }, mmap(stream, length, position, prot, flags) { if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) { throw new FS.ErrnoError(2) } if ((stream.flags & 2097155) === 1) { throw new FS.ErrnoError(2) } if (!stream.stream_ops.mmap) { throw new FS.ErrnoError(43) } if (!length) { throw new FS.ErrnoError(28) } return stream.stream_ops.mmap(stream, length, position, prot, flags) }, msync(stream, buffer, offset, length, mmapFlags) { if (!stream.stream_ops.msync) { return 0 } return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags) }, ioctl(stream, cmd, arg) { if (!stream.stream_ops.ioctl) { throw new FS.ErrnoError(59) } return stream.stream_ops.ioctl(stream, cmd, arg) }, readFile(path, opts = {}) { opts.flags = opts.flags || 0; opts.encoding = opts.encoding || "binary"; if (opts.encoding !== "utf8" && opts.encoding !== "binary") { abort(`Invalid encoding type "${opts.encoding}"`) } var stream = FS.open(path, opts.flags); var stat = FS.stat(path); var length = stat.size; var buf = new Uint8Array(length); FS.read(stream, buf, 0, length, 0); if (opts.encoding === "utf8") { buf = UTF8ArrayToString(buf) } FS.close(stream); return buf }, writeFile(path, data, opts = {}) { opts.flags = opts.flags || 577; var stream = FS.open(path, opts.flags, opts.mode); if (typeof data == "string") { data = new Uint8Array(intArrayFromString(data, true)) } if (ArrayBuffer.isView(data)) { FS.write(stream, data, 0, data.byteLength, undefined, opts.canOwn) } else { abort("Unsupported data type") } FS.close(stream) }, cwd: () => FS.currentPath, chdir(path) { var lookup = FS.lookupPath(path, { follow: true }); if (lookup.node === null) { throw new FS.ErrnoError(44) } if (!FS.isDir(lookup.node.mode)) { throw new FS.ErrnoError(54) } var errCode = FS.nodePermissions(lookup.node, "x"); if (errCode) { throw new FS.ErrnoError(errCode) } FS.currentPath = lookup.path }, createDefaultDirectories() { FS.mkdir("/tmp"); FS.mkdir("/home"); FS.mkdir("/home/web_user") }, createDefaultDevices() { FS.mkdir("/dev"); FS.registerDevice(FS.makedev(1, 3), { read: () => 0, write: (stream, buffer, offset, length, pos) => length, llseek: () => 0 }); FS.mkdev("/dev/null", FS.makedev(1, 3)); TTY.register(FS.makedev(5, 0), TTY.default_tty_ops); TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops); FS.mkdev("/dev/tty", FS.makedev(5, 0)); FS.mkdev("/dev/tty1", FS.makedev(6, 0)); var randomBuffer = new Uint8Array(1024), randomLeft = 0; var randomByte = () => { if (randomLeft === 0) { randomFill(randomBuffer); randomLeft = randomBuffer.byteLength } return randomBuffer[--randomLeft] }; FS.createDevice("/dev", "random", randomByte); FS.createDevice("/dev", "urandom", randomByte); FS.mkdir("/dev/shm"); FS.mkdir("/dev/shm/tmp") }, createSpecialDirectories() { FS.mkdir("/proc"); var proc_self = FS.mkdir("/proc/self"); FS.mkdir("/proc/self/fd"); FS.mount({ mount() { var node = FS.createNode(proc_self, "fd", 16895, 73); node.stream_ops = { llseek: MEMFS.stream_ops.llseek }; node.node_ops = { lookup(parent, name) { var fd = +name; var stream = FS.getStreamChecked(fd); var ret = { parent: null, mount: { mountpoint: "fake" }, node_ops: { readlink: () => stream.path }, id: fd + 1 }; ret.parent = ret; return ret }, readdir() { return Array.from(FS.streams.entries()).filter(([k, v]) => v).map(([k, v]) => k.toString()) } }; return node } }, {}, "/proc/self/fd") }, createStandardStreams(input, output, error) { if (input) { FS.createDevice("/dev", "stdin", input) } else { FS.symlink("/dev/tty", "/dev/stdin") } if (output) { FS.createDevice("/dev", "stdout", null, output) } else { FS.symlink("/dev/tty", "/dev/stdout") } if (error) { FS.createDevice("/dev", "stderr", null, error) } else { FS.symlink("/dev/tty1", "/dev/stderr") } var stdin = FS.open("/dev/stdin", 0); var stdout = FS.open("/dev/stdout", 1); var stderr = FS.open("/dev/stderr", 1) }, staticInit() { FS.nameTable = new Array(4096); FS.mount(MEMFS, {}, "/"); FS.createDefaultDirectories(); FS.createDefaultDevices(); FS.createSpecialDirectories(); FS.filesystems = { MEMFS } }, init(input, output, error) { FS.initialized = true; input ??= Module["stdin"]; output ??= Module["stdout"]; error ??= Module["stderr"]; FS.createStandardStreams(input, output, error) }, quit() { FS.initialized = false; for (var stream of FS.streams) { if (stream) { FS.close(stream) } } }, findObject(path, dontResolveLastLink) { var ret = FS.analyzePath(path, dontResolveLastLink); if (!ret.exists) { return null } return ret.object }, analyzePath(path, dontResolveLastLink) { try { var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink }); path = lookup.path } catch (e) { } var ret = { isRoot: false, exists: false, error: 0, name: null, path: null, object: null, parentExists: false, parentPath: null, parentObject: null }; try { var lookup = FS.lookupPath(path, { parent: true }); ret.parentExists = true; ret.parentPath = lookup.path; ret.parentObject = lookup.node; ret.name = PATH.basename(path); lookup = FS.lookupPath(path, { follow: !dontResolveLastLink }); ret.exists = true; ret.path = lookup.path; ret.object = lookup.node; ret.name = lookup.node.name; ret.isRoot = lookup.path === "/" } catch (e) { ret.error = e.errno } return ret }, createPath(parent, path, canRead, canWrite) { parent = typeof parent == "string" ? parent : FS.getPath(parent); var parts = path.split("/").reverse(); while (parts.length) { var part = parts.pop(); if (!part) continue; var current = PATH.join2(parent, part); try { FS.mkdir(current) } catch (e) { if (e.errno != 20) throw e } parent = current } return current }, createFile(parent, name, properties, canRead, canWrite) { var path = PATH.join2(typeof parent == "string" ? parent : FS.getPath(parent), name); var mode = FS_getMode(canRead, canWrite); return FS.create(path, mode) }, createDataFile(parent, name, data, canRead, canWrite, canOwn) { var path = name; if (parent) { parent = typeof parent == "string" ? parent : FS.getPath(parent); path = name ? PATH.join2(parent, name) : parent } var mode = FS_getMode(canRead, canWrite); var node = FS.create(path, mode); if (data) { if (typeof data == "string") { var arr = new Array(data.length); for (var i = 0, len = data.length; i < len; ++i)arr[i] = data.charCodeAt(i); data = arr } FS.chmod(node, mode | 146); var stream = FS.open(node, 577); FS.write(stream, data, 0, data.length, 0, canOwn); FS.close(stream); FS.chmod(node, mode) } }, createDevice(parent, name, input, output) { var path = PATH.join2(typeof parent == "string" ? parent : FS.getPath(parent), name); var mode = FS_getMode(!!input, !!output); FS.createDevice.major ??= 64; var dev = FS.makedev(FS.createDevice.major++, 0); FS.registerDevice(dev, { open(stream) { stream.seekable = false }, close(stream) { if (output?.buffer?.length) { output(10) } }, read(stream, buffer, offset, length, pos) { var bytesRead = 0; for (var i = 0; i < length; i++) { var result; try { result = input() } catch (e) { throw new FS.ErrnoError(29) } if (result === undefined && bytesRead === 0) { throw new FS.ErrnoError(6) } if (result === null || result === undefined) break; bytesRead++; buffer[offset + i] = result } if (bytesRead) { stream.node.atime = Date.now() } return bytesRead }, write(stream, buffer, offset, length, pos) { for (var i = 0; i < length; i++) { try { output(buffer[offset + i]) } catch (e) { throw new FS.ErrnoError(29) } } if (length) { stream.node.mtime = stream.node.ctime = Date.now() } return i } }); return FS.mkdev(path, mode, dev) }, forceLoadFile(obj) { if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true; if (globalThis.XMLHttpRequest) { abort("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.") } else { try { obj.contents = readBinary(obj.url) } catch (e) { throw new FS.ErrnoError(29) } } }, createLazyFile(parent, name, url, canRead, canWrite) { class LazyUint8Array { lengthKnown = false; chunks = []; get(idx) { if (idx > this.length - 1 || idx < 0) { return undefined } var chunkOffset = idx % this.chunkSize; var chunkNum = idx / this.chunkSize | 0; return this.getter(chunkNum)[chunkOffset] } setDataGetter(getter) { this.getter = getter } cacheLength() { var xhr = new XMLHttpRequest; xhr.open("HEAD", url, false); xhr.send(null); if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) abort("Couldn't load " + url + ". Status: " + xhr.status); var datalength = Number(xhr.getResponseHeader("Content-length")); var header; var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes"; var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip"; var chunkSize = 1024 * 1024; if (!hasByteServing) chunkSize = datalength; var doXHR = (from, to) => { if (from > to) abort("invalid range (" + from + ", " + to + ") or no bytes requested!"); if (to > datalength - 1) abort("only " + datalength + " bytes available! programmer error!"); var xhr = new XMLHttpRequest; xhr.open("GET", url, false); if (datalength !== chunkSize) xhr.setRequestHeader("Range", "bytes=" + from + "-" + to); xhr.responseType = "arraybuffer"; if (xhr.overrideMimeType) { xhr.overrideMimeType("text/plain; charset=x-user-defined") } xhr.send(null); if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) abort("Couldn't load " + url + ". Status: " + xhr.status); if (xhr.response !== undefined) { return new Uint8Array(xhr.response || []) } return intArrayFromString(xhr.responseText || "", true) }; var lazyArray = this; lazyArray.setDataGetter(chunkNum => { var start = chunkNum * chunkSize; var end = (chunkNum + 1) * chunkSize - 1; end = Math.min(end, datalength - 1); if (typeof lazyArray.chunks[chunkNum] == "undefined") { lazyArray.chunks[chunkNum] = doXHR(start, end) } if (typeof lazyArray.chunks[chunkNum] == "undefined") abort("doXHR failed!"); return lazyArray.chunks[chunkNum] }); if (usesGzip || !datalength) { chunkSize = datalength = 1; datalength = this.getter(0).length; chunkSize = datalength; out("LazyFiles on gzip forces download of the whole file when length is accessed") } this._length = datalength; this._chunkSize = chunkSize; this.lengthKnown = true } get length() { if (!this.lengthKnown) { this.cacheLength() } return this._length } get chunkSize() { if (!this.lengthKnown) { this.cacheLength() } return this._chunkSize } } if (globalThis.XMLHttpRequest) { if (!ENVIRONMENT_IS_WORKER) abort("Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc"); var lazyArray = new LazyUint8Array; var properties = { isDevice: false, contents: lazyArray } } else { var properties = { isDevice: false, url } } var node = FS.createFile(parent, name, properties, canRead, canWrite); if (properties.contents) { node.contents = properties.contents } else if (properties.url) { node.contents = null; node.url = properties.url } Object.defineProperties(node, { usedBytes: { get: function () { return this.contents.length } } }); var stream_ops = {}; for (const [key, fn] of Object.entries(node.stream_ops)) { stream_ops[key] = (...args) => { FS.forceLoadFile(node); return fn(...args) } } function writeChunks(stream, buffer, offset, length, position) { var contents = stream.node.contents; if (position >= contents.length) return 0; var size = Math.min(contents.length - position, length); if (contents.slice) { for (var i = 0; i < size; i++) { buffer[offset + i] = contents[position + i] } } else { for (var i = 0; i < size; i++) { buffer[offset + i] = contents.get(position + i) } } return size } stream_ops.read = (stream, buffer, offset, length, position) => { FS.forceLoadFile(node); return writeChunks(stream, buffer, offset, length, position) }; stream_ops.mmap = (stream, length, position, prot, flags) => { FS.forceLoadFile(node); var ptr = mmapAlloc(length); if (!ptr) { throw new FS.ErrnoError(48) } writeChunks(stream, HEAP8, ptr, length, position); return { ptr, allocated: true } }; node.stream_ops = stream_ops; return node } }; var UTF8ToString = (ptr, maxBytesToRead, ignoreNul) => ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead, ignoreNul) : ""; var SYSCALLS = { calculateAt(dirfd, path, allowEmpty) { if (PATH.isAbs(path)) { return path } var dir; if (dirfd === -100) { dir = FS.cwd() } else { var dirstream = SYSCALLS.getStreamFromFD(dirfd); dir = dirstream.path } if (path.length == 0) { if (!allowEmpty) { throw new FS.ErrnoError(44) } return dir } return dir + "/" + path }, writeStat(buf, stat) { HEAPU32[buf >> 2] = stat.dev; HEAPU32[buf + 4 >> 2] = stat.mode; HEAPU32[buf + 8 >> 2] = stat.nlink; HEAPU32[buf + 12 >> 2] = stat.uid; HEAPU32[buf + 16 >> 2] = stat.gid; HEAPU32[buf + 20 >> 2] = stat.rdev; HEAP64[buf + 24 >> 3] = BigInt(stat.size); HEAP32[buf + 32 >> 2] = 4096; HEAP32[buf + 36 >> 2] = stat.blocks; var atime = stat.atime.getTime(); var mtime = stat.mtime.getTime(); var ctime = stat.ctime.getTime(); HEAP64[buf + 40 >> 3] = BigInt(Math.floor(atime / 1e3)); HEAPU32[buf + 48 >> 2] = atime % 1e3 * 1e3 * 1e3; HEAP64[buf + 56 >> 3] = BigInt(Math.floor(mtime / 1e3)); HEAPU32[buf + 64 >> 2] = mtime % 1e3 * 1e3 * 1e3; HEAP64[buf + 72 >> 3] = BigInt(Math.floor(ctime / 1e3)); HEAPU32[buf + 80 >> 2] = ctime % 1e3 * 1e3 * 1e3; HEAP64[buf + 88 >> 3] = BigInt(stat.ino); return 0 }, writeStatFs(buf, stats) { HEAPU32[buf + 4 >> 2] = stats.bsize; HEAPU32[buf + 60 >> 2] = stats.bsize; HEAP64[buf + 8 >> 3] = BigInt(stats.blocks); HEAP64[buf + 16 >> 3] = BigInt(stats.bfree); HEAP64[buf + 24 >> 3] = BigInt(stats.bavail); HEAP64[buf + 32 >> 3] = BigInt(stats.files); HEAP64[buf + 40 >> 3] = BigInt(stats.ffree); HEAPU32[buf + 48 >> 2] = stats.fsid; HEAPU32[buf + 64 >> 2] = stats.flags; HEAPU32[buf + 56 >> 2] = stats.namelen }, doMsync(addr, stream, len, flags, offset) { if (!FS.isFile(stream.node.mode)) { throw new FS.ErrnoError(43) } if (flags & 2) { return 0 } var buffer = HEAPU8.slice(addr, addr + len); FS.msync(stream, buffer, offset, len, flags) }, getStreamFromFD(fd) { var stream = FS.getStreamChecked(fd); return stream }, varargs: undefined, getStr(ptr) { var ret = UTF8ToString(ptr); return ret } }; function ___syscall_fcntl64(fd, cmd, varargs) { SYSCALLS.varargs = varargs; try { var stream = SYSCALLS.getStreamFromFD(fd); switch (cmd) { case 0: { var arg = syscallGetVarargI(); if (arg < 0) { return -28 } while (FS.streams[arg]) { arg++ } var newStream; newStream = FS.dupStream(stream, arg); return newStream.fd } case 1: case 2: return 0; case 3: return stream.flags; case 4: { var arg = syscallGetVarargI(); stream.flags |= arg; return 0 } case 12: { var arg = syscallGetVarargP(); var offset = 0; HEAP16[arg + offset >> 1] = 2; return 0 } case 13: case 14: return 0 }return -28 } catch (e) { if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e; return -e.errno } } function ___syscall_ioctl(fd, op, varargs) { SYSCALLS.varargs = varargs; try { var stream = SYSCALLS.getStreamFromFD(fd); switch (op) { case 21509: { if (!stream.tty) return -59; return 0 } case 21505: { if (!stream.tty) return -59; if (stream.tty.ops.ioctl_tcgets) { var termios = stream.tty.ops.ioctl_tcgets(stream); var argp = syscallGetVarargP(); HEAP32[argp >> 2] = termios.c_iflag || 0; HEAP32[argp + 4 >> 2] = termios.c_oflag || 0; HEAP32[argp + 8 >> 2] = termios.c_cflag || 0; HEAP32[argp + 12 >> 2] = termios.c_lflag || 0; for (var i = 0; i < 32; i++) { HEAP8[argp + i + 17] = termios.c_cc[i] || 0 } return 0 } return 0 } case 21510: case 21511: case 21512: { if (!stream.tty) return -59; return 0 } case 21506: case 21507: case 21508: { if (!stream.tty) return -59; if (stream.tty.ops.ioctl_tcsets) { var argp = syscallGetVarargP(); var c_iflag = HEAP32[argp >> 2]; var c_oflag = HEAP32[argp + 4 >> 2]; var c_cflag = HEAP32[argp + 8 >> 2]; var c_lflag = HEAP32[argp + 12 >> 2]; var c_cc = []; for (var i = 0; i < 32; i++) { c_cc.push(HEAP8[argp + i + 17]) } return stream.tty.ops.ioctl_tcsets(stream.tty, op, { c_iflag, c_oflag, c_cflag, c_lflag, c_cc }) } return 0 } case 21519: { if (!stream.tty) return -59; var argp = syscallGetVarargP(); HEAP32[argp >> 2] = 0; return 0 } case 21520: { if (!stream.tty) return -59; return -28 } case 21537: case 21531: { var argp = syscallGetVarargP(); return FS.ioctl(stream, op, argp) } case 21523: { if (!stream.tty) return -59; if (stream.tty.ops.ioctl_tiocgwinsz) { var winsize = stream.tty.ops.ioctl_tiocgwinsz(stream.tty); var argp = syscallGetVarargP(); HEAP16[argp >> 1] = winsize[0]; HEAP16[argp + 2 >> 1] = winsize[1] } return 0 } case 21524: { if (!stream.tty) return -59; return 0 } case 21515: { if (!stream.tty) return -59; return 0 } default: return -28 } } catch (e) { if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e; return -e.errno } } function ___syscall_openat(dirfd, path, flags, varargs) { SYSCALLS.varargs = varargs; try { path = SYSCALLS.getStr(path); path = SYSCALLS.calculateAt(dirfd, path); var mode = varargs ? syscallGetVarargI() : 0; return FS.open(path, flags, mode).fd } catch (e) { if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e; return -e.errno } } var getHeapMax = () => 2147483648; var alignMemory = (size, alignment) => Math.ceil(size / alignment) * alignment; var growMemory = size => { var oldHeapSize = wasmMemory.buffer.byteLength; var pages = (size - oldHeapSize + 65535) / 65536 | 0; try { wasmMemory.grow(pages); updateMemoryViews(); return 1 } catch (e) { } }; var _emscripten_resize_heap = requestedSize => { var oldSize = HEAPU8.length; requestedSize >>>= 0; var maxHeapSize = getHeapMax(); if (requestedSize > maxHeapSize) { return false } for (var cutDown = 1; cutDown <= 4; cutDown *= 2) { var overGrownHeapSize = oldSize * (1 + .2 / cutDown); overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296); var newSize = Math.min(maxHeapSize, alignMemory(Math.max(requestedSize, overGrownHeapSize), 65536)); var replacement = growMemory(newSize); if (replacement) { return true } } return false }; function _fd_close(fd) { try { var stream = SYSCALLS.getStreamFromFD(fd); FS.close(stream); return 0 } catch (e) { if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e; return e.errno } } var doReadv = (stream, iov, iovcnt, offset) => { var ret = 0; for (var i = 0; i < iovcnt; i++) { var ptr = HEAPU32[iov >> 2]; var len = HEAPU32[iov + 4 >> 2]; iov += 8; var curr = FS.read(stream, HEAP8, ptr, len, offset); if (curr < 0) return -1; ret += curr; if (curr < len) break; if (typeof offset != "undefined") { offset += curr } } return ret }; function _fd_read(fd, iov, iovcnt, pnum) { try { var stream = SYSCALLS.getStreamFromFD(fd); var num = doReadv(stream, iov, iovcnt); HEAPU32[pnum >> 2] = num; return 0 } catch (e) { if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e; return e.errno } } var INT53_MAX = 9007199254740992; var INT53_MIN = -9007199254740992; var bigintToI53Checked = num => num < INT53_MIN || num > INT53_MAX ? NaN : Number(num); function _fd_seek(fd, offset, whence, newOffset) { offset = bigintToI53Checked(offset); try { if (isNaN(offset)) return 61; var stream = SYSCALLS.getStreamFromFD(fd); FS.llseek(stream, offset, whence); HEAP64[newOffset >> 3] = BigInt(stream.position); if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null; return 0 } catch (e) { if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e; return e.errno } } var doWritev = (stream, iov, iovcnt, offset) => { var ret = 0; for (var i = 0; i < iovcnt; i++) { var ptr = HEAPU32[iov >> 2]; var len = HEAPU32[iov + 4 >> 2]; iov += 8; var curr = FS.write(stream, HEAP8, ptr, len, offset); if (curr < 0) return -1; ret += curr; if (curr < len) { break } if (typeof offset != "undefined") { offset += curr } } return ret }; function _fd_write(fd, iov, iovcnt, pnum) { try { var stream = SYSCALLS.getStreamFromFD(fd); var num = doWritev(stream, iov, iovcnt); HEAPU32[pnum >> 2] = num; return 0 } catch (e) { if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e; return e.errno } } var getCFunc = ident => { var func = Module["_" + ident]; return func }; var writeArrayToMemory = (array, buffer) => { HEAP8.set(array, buffer) }; var stringToUTF8 = (str, outPtr, maxBytesToWrite) => stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite); var stackAlloc = sz => __emscripten_stack_alloc(sz); var stringToUTF8OnStack = str => { var size = lengthBytesUTF8(str) + 1; var ret = stackAlloc(size); stringToUTF8(str, ret, size); return ret }; var ccall = (ident, returnType, argTypes, args, opts) => { var toC = { string: str => { var ret = 0; if (str !== null && str !== undefined && str !== 0) { ret = stringToUTF8OnStack(str) } return ret }, array: arr => { var ret = stackAlloc(arr.length); writeArrayToMemory(arr, ret); return ret } }; function convertReturnValue(ret) { if (returnType === "string") { return UTF8ToString(ret) } if (returnType === "boolean") return Boolean(ret); return ret } var func = getCFunc(ident); var cArgs = []; var stack = 0; if (args) { for (var i = 0; i < args.length; i++) { var converter = toC[argTypes[i]]; if (converter) { if (stack === 0) stack = stackSave(); cArgs[i] = converter(args[i]) } else { cArgs[i] = args[i] } } } var ret = func(...cArgs); function onDone(ret) { if (stack !== 0) stackRestore(stack); return convertReturnValue(ret) } ret = onDone(ret); return ret }; var cwrap = (ident, returnType, argTypes, opts) => { var numericArgs = !argTypes || argTypes.every(type => type === "number" || type === "boolean"); var numericRet = returnType !== "string"; if (numericRet && numericArgs && !opts) { return getCFunc(ident) } return (...args) => ccall(ident, returnType, argTypes, args, opts) }; FS.createPreloadedFile = FS_createPreloadedFile; FS.preloadFile = FS_preloadFile; FS.staticInit(); { if (Module["noExitRuntime"]) noExitRuntime = Module["noExitRuntime"]; if (Module["preloadPlugins"]) preloadPlugins = Module["preloadPlugins"]; if (Module["print"]) out = Module["print"]; if (Module["printErr"]) err = Module["printErr"]; if (Module["wasmBinary"]) wasmBinary = Module["wasmBinary"]; if (Module["arguments"]) arguments_ = Module["arguments"]; if (Module["thisProgram"]) thisProgram = Module["thisProgram"]; if (Module["preInit"]) { if (typeof Module["preInit"] == "function") Module["preInit"] = [Module["preInit"]]; while (Module["preInit"].length > 0) { Module["preInit"].shift()() } } } Module["ccall"] = ccall; Module["cwrap"] = cwrap; Module["FS"] = FS; var _init_player, _generate_audio, _malloc, _cleanup_player, _free, __emscripten_stack_restore, __emscripten_stack_alloc, _emscripten_stack_get_current, memory, __indirect_function_table, wasmMemory; function assignWasmExports(wasmExports) { _init_player = Module["_init_player"] = wasmExports["k"]; _generate_audio = Module["_generate_audio"] = wasmExports["l"]; _malloc = Module["_malloc"] = wasmExports["m"]; _cleanup_player = Module["_cleanup_player"] = wasmExports["n"]; _free = Module["_free"] = wasmExports["o"]; __emscripten_stack_restore = wasmExports["p"]; __emscripten_stack_alloc = wasmExports["q"]; _emscripten_stack_get_current = wasmExports["r"]; memory = wasmMemory = wasmExports["i"]; __indirect_function_table = wasmExports["__indirect_function_table"] } var wasmImports = { c: ___syscall_fcntl64, g: ___syscall_ioctl, h: ___syscall_openat, d: _emscripten_resize_heap, a: _fd_close, f: _fd_read, e: _fd_seek, b: _fd_write }; function run() { if (runDependencies > 0) { dependenciesFulfilled = run; return } preRun(); if (runDependencies > 0) { dependenciesFulfilled = run; return } function doRun() { Module["calledRun"] = true; if (ABORT) return; initRuntime(); readyPromiseResolve?.(Module); Module["onRuntimeInitialized"]?.(); postRun() } if (Module["setStatus"]) { Module["setStatus"]("Running..."); setTimeout(() => { setTimeout(() => Module["setStatus"](""), 1); doRun() }, 1) } else { doRun() } } var wasmExports; wasmExports = await (createWasm()); run(); if (runtimeInitialized) { moduleRtn = Module } else { moduleRtn = new Promise((resolve, reject) => { readyPromiseResolve = resolve; readyPromiseReject = reject }) }
        ; return moduleRtn
      }
    })(); if (typeof exports === "object" && typeof module === "object") { module.exports = createMdxModule; module.exports.default = createMdxModule } else if (typeof define === "function" && define["amd"]) define([], () => createMdxModule);

    // Pour éviter les erreurs si vous testez sans coller le code, je définis un stub :
    if (typeof createMdxModule === 'undefined') {
      console.warn("WARNING : createMdxModule undefined.");
    }

    // ------------------------------------------------------------------
    // ZONE 2 : COPIEZ ICI LE CONTENU DE wasm_b64.txt
    // ------------------------------------------------------------------
    const WASM_BASE64 = "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AwUgABAsDQEgACgCEAsgACgCFCIEayACSQRAIAAgASACIAAoAiQRAQAaDAELAkACQCAAKAJQQQBIDQAgAkUNACACIQMDQCABIANqIgVBAWstAABBCkcEQCADQQFrIgMNAQwCCwsgACABIAMgACgCJBEBACADSQ0CIAIgA2shAiAAKAIUIQQMAQsgASEFCyAEIAUgAhArIAAgACgCFCACajYCFAsLCwsAIAAEQCAAEAkLC4ACAQN/An8CQAJAAkAgASIDQf8BcSIBBEAgAEEDcQRAA0AgAC0AACICRQ0FIAEgAkYNBSAAQQFqIgBBA3ENAAsLQYCChAggACgCACICayACckGAgYKEeHFBgIGChHhHDQEgAUGBgoQIbCEEA0BBgIKECCACIARzIgFrIAFyQYCBgoR4cUGAgYKEeEcNAiAAKAIEIQIgAEEEaiIBIQAgAkGAgoQIIAJrckGAgYKEeHFBgIGChHhGDQALDAILIAAQESAAagwDCyAAIQELA0AgASIALQAAIgJFDQEgAEEBaiEBIAIgA0H/AXFHDQALCyAACyIAQQAgAC0AACADQf8BcUYbC30BA38CQAJAIAAiAUEDcUUNACABLQAARQRAQQAPCwNAIAFBAWoiAUEDcUUNASABLQAADQALDAELA0AgASICQQRqIQFBgIKECCACKAIAIgNrIANyQYCBgoR4cUGAgYKEeEYNAAsDQCACIgFBAWohAiABLQAADQALCyABIABrC6gBAAJAIAFBgAhOBEAgAEQAAAAAAADgf6IhACABQf8PSQRAIAFB/wdrIQEMAgsgAEQAAAAAAADgf6IhAEH9FyABIAFB/RdPG0H+D2shAQwBCyABQYF4Sg0AIABEAAAAAAAAYAOiIQAgAUG4cEsEQCABQckHaiEBDAELIABEAAAAAAAAYAOiIQBB8GggASABQfBoTRtBkg9qIQELIAAgAUH/B2qtQjSGv6ILGgAgACgCTEEASARAIAAgARApDwsgACABECkL8AICAn8BfgJAIAJFDQAgACABOgAAIAAgAmoiA0EBayABOgAAIAJBA0kNACAAIAE6AAIgACABOgABIANBA2sgAToAACADQQJrIAE6AAAgAkEHSQ0AIAAgAToAAyADQQRrIAE6AAAgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgA2AgAgAyACIARrQXxxIgJqIgFBBGsgADYCACACQQlJDQAgAyAANgIIIAMgADYCBCABQQhrIAA2AgAgAUEMayAANgIAIAJBGUkNACADIAA2AhggAyAANgIUIAMgADYCECADIAA2AgwgAUEQayAANgIAIAFBFGsgADYCACABQRhrIAA2AgAgAUEcayAANgIAIAIgA0EEcUEYciIBayICQSBJDQAgAK1CgYCAgBB+IQUgASADaiEBA0AgASAFNwMYIAEgBTcDECABIAU3AwggASAFNwMAIAFBIGohASACQSBrIgJBH0sNAAsLC+YBAQN/IABFBEBBiPAAKAIAIgAEQCAAEBUhAQtBsOECKAIAIgAEQCAAEBUgAXIhAQtB9OECKAIAIgAEQANAIAAoAkwaIAAoAhQgACgCHEcEQCAAEBUgAXIhAQsgACgCOCIADQALCyABDwsgACgCTEEASCECAkACQCAAKAIUIAAoAhxGDQAgAEEAQQAgACgCJBEBABogACgCFA0AQX8hAQwBCyAAKAIEIgEgACgCCCIDRwRAIAAgASADa6xBASAAKAIoEQUAGgtBACEBIABBADYCHCAAQgA3AxAgAEIANwIEIAINAAsgAQtrAQJ/IAAoAkwaIAAQFRogACAAKAIMEQAAGiAALQAAQQFxRQRAIAAoAjghASAAKAI0IgIEQCACIAE2AjgLIAEEQCABIAI2AjQLIABB9OECKAIARgRAQfThAiABNgIACyAAKAJgEAkgABAJCws3AAJAIABBD0sNACABKAIIIgEoAsQERQ0AIAEgAEEkbGoiAEEANgIcIABBADYCDCAAQgA3AgQLCyoAIAIoAgAgAEEHdGpB5AhqQf8AIAFBACABQQBKGyIAIABB/wBOGzYCAAs/AgF/AX4CQCAArSICpyIBIAEgAEEBckGAgARJGyIBEAoiAEUNACAAQQRrLQAAQQNxRQ0AIABBACABEBQLIAAL3AEBAn8CQAJAIAEgACIDc0EDcQRAIAEtAAAhAgwBCyABQQNxBEADQCADIAEtAAAiAjoAACACRQ0DIANBAWohAyABQQFqIgFBA3ENAAsLQYCChAggASgCACICayACckGAgYKEeHFBgIGChHhHDQADQCADIAI2AgAgA0EEaiEDIAEiAkEEaiEBQYCChAggAigCBCICayACckGAgYKEeHFBgIGChHhGDQAL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IA1BnQg2AgAjAEEQayIFJAAgBSANNgIMQQAhAiMAQdABayIAJAAgACANNgLMASAAQaABaiIJQQBBKPwLACAAIAAoAswBNgLIAQJAQQAgAEHIAWogAEHQAGogCRAkQQBIDQBBxO8AKAIAQQBIQfjuAEH47gAoAgAiD0FfcTYCAAJ/AkACQEGo7wAoAgBFBEBBqO8AQdAANgIAQZTvAEEANgIAQYjvAEIANwMAQaTvACgCACECQaTvACAANgIADAELQYjvACgCAA0BC0F/QfjuABAsDQEaC0H47gAgAEHIAWogAEHQAGogAEGgAWoQJAshECACBH9B+O4AQQBBAEGc7wAoAgARAQAaQajvAEEANgIAQaTvACACNgIAQZTvAEEANgIAQYzvACgCABpBiO8AQgA3AwBBAAUgEAsaQfjuAEH47gAoAgAgD0EgcXI2AgANAAsgAEHQAWokACAFQRBqJABBACEAA0AgDiAAQQR0aiICKAIAIgUEQCAFEAkgAkEANgIACyACKAIEIgUEQCAFEAkgAkEANgIECyACQgA3AgggAEEBaiIAQYAMRw0ACwsgDUEQaiQAIAcQCSAOCzkAIAUoAgAgAEEHdGoiAEHECGogBDYCACAAQcAIaiADNgIAIABBvAhqIAI2AgAgAEG4CGogATYCAAsEACMACxAAIwAgAGtBcHEiACQAIAALBgAgACQACwQAQgALBABBAAvjCAEEf0Gk8AAoAgAEQEGo8AAoAgAiASgCACIAQQA2AswIIABBADYC4AggASgCACIAQQA2AswJIABBADYC4AkgASgCACIAQQA2AswKIABBADYC4AogASgCACIAQQA2AswLIABBADYC4AsgASgCACIAQQA2AswMIABBADYC4AwgASgCACIAQQA2AswNIABBADYC4A0gASgCACIAQQA2AswOIABBADYC4A4gASgCACIAQQA2AswPIABBADYC4A8gASgCACIAQQA2AiAgACgCmBBBAUYEQCABKAIAKAKkEEEIQQAQCAsgASgCACIAIAAoAoABQT9xIgI2AoABIAAoApgQQQFGBEAgASgCACgCpBBBICACEAgLIAEoAgAiAEEBNgIgIAAoApgQQQFGBEAgASgCACgCpBBBCEEBEAgLIAEoAgAiACAAKAKEAUE/cSICNgKEASAAKAKYEEEBRgRAIAEoAgAoAqQQ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dmo2AoABIAMgAygCgAIgAygCjAIgAygCiAIgAiADKAKUAkECdGooAgBqbEEBdmo2AoACIAMgAygCgAMgAygCjAMgAygCiAMgAiADKAKUA0ECdGooAgBqbEEBdmo2AoADDAILIAMgAygCACADKAIEajYCACADIAMoAoABIAMoAoQBajYCgAEgAyADKAKAAiADKAKEAmo2AoACIAMgAygCgAMgAygChANqNgKAAwwBCyADIAMoAgAgAygCBGo2AgAgAyADKAKAASADKAKEAWo2AoABIAMgAygCgAIgAygChAJqNgKAAiADIAMoAoADIAMoAoQDajYCgAMLIANBgARqIQMgCEEBayIIDQALQSAhBQJAIAQCfwJAAkAgBCIDKAKIIQ4DAwEAAQsDQAJAIAMoAmAiBw0AIANBBDYCRCADQQA2AgAgAyADLQBJIAQoAsAgIAMtAEh2QQdxai0A0BEgAygCUCICQX9zbEEEdSACaiICNgJQIAJBAEoNACADQQM2AkQgA0EANgJQCyADIAdBAnI2AmAgA0GAAWohAyAFQQFrIgUNAAtBAQwBCwNAAkAgAygCYCICRQ0AIAMgAkF9cSICNgJgIAINACADKAJEQQJJDQAgA0EBNgJECwJAIAMoAuABIgJFDQAgAyACQX1xIgI2AuABIAINACADKALEAUECSQ0AIANBATYCxAELIANBgAJqIQMgBUECayIFDQALQQALNgKIIQsgHkEBaiIeIAxHDQALCyAKKAIAIgYoArzyCAUgBAsNACAGKALg8ghBAEwNACAGKALk8ghBAEgNACAKKALwBEEATA0BA0BBgOMCQYDjAikDAEKt/tXk1IX9qNgAfkIBfCIhNwMAICFCIYinIQQCQCAKKAIAIgIoAuTyCEEjSg0AIAS3RAAAAAAAAMBAokQAAMD////fQaNEAAAAAAAAsMCg/AK3RAAAAAAAAPg/oiACKALg8gi3okQAAAAAAMBfQKP8AiEDQQAhBgNAIBEgCigC8ARODQEgCigC7AQgEUECdGogAzYCACARQQFqIREgBkEgIAIoAuTyCGtBBG1IIAZBAWohBg0ACwsgESAKKALwBEgNAAsMAQsgDEECdCIERQ0AIAooAuwEQQAgBPwLAAsgCkEEaiELIAxBAnQhCANAIAsgHUEkbGoiDigCACIEBEAgCigC7AQiBiAIaiEJIA4oAiAhAyAOKAIcIRFBACEPA0AgEUEATgRAIAooAuAEIQcgDigCCCEFA0AgBCIDQQRqIgQgAyAEIAVJIgIbIQQgD0EBIAIbIQ8gESAHayIRQQBODQALIA4oAgwgAygCAGxBgAFtIQMLA0AgEUEATg0BIAYgBigCACADajYCACAOKAIQIBFqIREgBkEEaiIGIAlJDQALCyAOQQAgAyAPQQFGIgMbNgIgIA5BACARIAMbNgIcIA5BACAEIAMbNgIACyAdQQFqIh1BEEcNAAsgDAJ/AkACQAJAIAooAtwEBEAgDEEASg0BQQIMBAsgDEEATA0CQQAhEQNAIAooAtAEIAooAuwEIBFBAnRqKAIAQQJtbEGAAW0iAyEGQQAhBAJAAn8CQAJAIAooAtQEQQFrDgIDAAELQQAMAQsgAwshBiADIQQLAkAgCigCACIDKAK88ghBAUcNACADKALA8ghBAUcNACARQQF0IgMgCigC/ARqLgEAQe4FbEGACG0gBGohBCAKKAL4BCADai4BAEHuBWxBgAhtIAZqIQYLIBFBAXQiAiAKKALoBGpB//8BQYCAfiAEIARBgIB+TBsiBCAEQf//AU4bQf//AUGAgH4gBiAGQYCAfkwbIgQgBEH//wFOG2oiA0ECbSIEQYCABGogBCADQX9IGyIEOgAAIAooAugEIAJqIARBCHY6AAEgEUEBaiIRIAxHDQALDAELQQAhDwNAIAooAtAEIA9BAnQiAiAKKALsBGooAgBBAm1sQYABbSIDIQZBACEEAkACfwJAAkAgCigC1ARBAWsOAgMAAQtBAAwBCyADCyEGIAMhBAsCQCAKKAIAIgMoArzyCEEBRw0AIAMoAsDyCEEBRw0AIA9BAXQiAyAKKAL8BGouAQBB7gVsQYAIbSAEaiEEIAooAvgEIANqLgEAQe4FbEGACG0gBmohBgsgCigC6AQgAmpB//8BQYCAfiAGIAZBgIB+TBsiAyADQf//AU4bIgM6AAAgCigC6AQgAmogA0EIdjoAASAKKALoBCACakH//wFBgIB+IAQgBEGAgH5MGyIEIARB//8BThsiBDoAAiAKKALoBCACaiAEQQh2OgADIA9BAWoiDyAMRw0ACwsgCigC3ARFDQBBAgwBC0EBC3QiBEUNACASIAooAugEIAT8CgAAC0GU8ABBlPAAKAIAIA1rIhY2AgAgDSAcaiIcIAFIDQALAkAgAUEATA0AQQEgAUEBdCIDIANBAUwbIgRBA3EhAkGQ8AAoAgAhDEEAIQEgA0EETgRAIARB/P///wdxIQNBACEWA0AgACABQQJ0aiAMIAFBAXRqLgEAskMAAAA4lDgCACAAIAFBAXIiBEECdGogDCAEQQF0ai4BALJDAAAAOJQ4AgAgACABQQJyIgRBAnRqIAwgBEEBdGouAQCyQwAAADiUOAIAIAAgAUEDciIEQQJ0aiAMIARBAXRqLgEAskMAAAA4lDgCACABQQRqIQEgFkEEaiIWIANHDQALIAJFDQELA0AgACABQQJ0aiAMIAFBAXRqLgEAskMAAAA4lDgCACABQQFqIQEgIEEBaiIgIAJHDQALCwvbZQMcfwh8An4jAEGACGsiEiQAQazwAEF/NgIAQajwAEEQEAoiAjYCAEGoEBAKIgEEQCABQQBBnBD8CwAgAUEANgKkECABQv+AgIAQNwKcEAsgAiABNgIAAkACQAJAIAFFDQBBIBAKIgEEQCABQgA3AhAgAUIANwIIIAFCADcCGCABQgA3AgAgAUEANgIQIAFBATYCCAsgAiABNgIEIAFFDQBBkAUQCiIBBEAgAUEAQfgE/AsAIAFCADcC0AQgAUF/NgLMBCABQgA3AtgEIAFCADcC4AQgAUIANwLoBCABQQA2AvAEIAFCADcC+AQgAUIANwKABSABQgA3AogFCyACIAE2AgggAQ0BCyACKAIIIgAEQCAAEA8gAkEANgIICyACKAIEIgAEQCAAEA8gAkEANgIEC0F/IRUgAigCACIARQ0BIAAQDyACQQA2AgAMAQtBnPAAAn9BACECAkBBnPMIEBkiBgRAAkAgABAtIgFFDQAgAUECEBMgARAnIQggAUEAEBMgCEEQahAKIQsgCARAIAtBACAI/AsACyALRQRAIAEQFgwBCyALIAggARAqIQQgARAWAkAgBCAIRw0AIAYgCzYCgAQgBiAINgKEBCAIQQNIDQAgBkGIBGohBAJAA0ACQCALIAIiAWoiAi0AACIOQQ1HDQAgAi0AAUEKRw0AIAItAAJBGkYNAgsgBCAFaiAOOgAAIAFBAWohAiAFIAVB/wdJaiEFIAEgCEgNAAtBAAwFC0EAIQIgBCAFakEAOgAAIAZBiBRqIgNBAEGACPwLACAGQQA2AtjkBCABQQNqIQVBACEOA0AgBSALaiIBLQAAIgQEQCAGQQE2AtjkBCADIA5qIAQ6AABBgAghDCACQQFBgAgtAAAiAgR/AkADQCABLQAAIgRFDQECQCACIARGDQAgAkEgciACIAJBwQBrQRpJGyAEIgJBIHIgAiACQcEAa0EaSRtGDQAgDC0AACECDAILIAFBAWohASAMLQABIQIgDEEBaiEMIAINAAtBACECCyACBUEACyICQSByIAIgAkHBAGtBGkkbIAEtAAAiAUEgciABIAFBwQBrQRpJG2sbIQIgDiAOQf8HSWohDiAFIAhIIAVBAWohBQ0BDAILCwJAIAYoAtjkBEEBRw0AIAINACADIA5qQa7gkcMHNgAACyAGIAVBAWoiAjYCiBwgBiABLQACIAIgC2oiBC0AAEEIdHIgAmoiBTYCjBwgBSAISg0AIAYgAS0ABCABLQADQQh0ciACaiIBNgKQHCABIAhKDQAgBkGQHGohDiAGIAEgC2otAABB6AFGIgE2AuDkBCAGQRBBCSABGzYC0BxBACEFA0AgDiAFQQJ0aiAEIAVBAXRqIgEtAAJBCHQgAS0AA3IgAmoiATYCACABIAhKDQEgBUEBaiIFIAYoAtAcSA0ACwwDCyALEAkLIAYQCQtBAAwBCyAGQQE2ArjyCCAGQoGAgIAQNwKw8gggBkGPCCkAADcAACAGQZQIKQAANwAFIAZBsggpAAA3AIACIAZBuggvAAA7AIgCIAYLIgQ2AgBBfyEVIARFDQAgBEGIDGpBvQgQGhogBEH/ADYC0PIIIARCATcCwPIIIARCgICAgBA3ArjyCCAEQoGAgIAQNwKw8gggBEIBNwLw8gggBEKDgICA0AA3AtTyCCAEQv+AgIDwDzcCyPIIIARCADcC6PIIIARBADYC1OQEQfDuACgCACEBIARCgICA+NOZs6Y+NwKU8wggBELNmbPu05mzpj83AozzCCAEQs2Zs+qDgICAPzcChPMIIAQgATYC+PIIIARCATcC/PIIQajwACgCACgCAEEBNgKgEAJAIAQoAoQEIgYgBCgCjBwiBUwNACAGIAVrQRtIDQAgBCgCgAQhCCAEQdQcaiELA0AgCyAFIAhqIgEtAABBpAJsaiICIAEtAAE2AsABIAIgAS0AAUEHcTYCCCACIAEtAAFBA3ZBB3E2AgQgAiABLQACNgIMIAIgAS0AAzYCxAEgAiABLQADQQ9xNgIwIAIgAS0AA0EEdkEHcTYCECACIAEtAAQ2AsgBIAIgAS0ABEEPcTYCNCACIAEtAARBBHZBB3E2AhQgAiABLQAFNgLMASACIAEtAAVBD3E2AjggAiABLQAFQQR2QQdxNgIYIAIgAS0ABjYC0AEgAiABLQAGQQ9xNgI8IAIgAS0ABkEEdkEHcTYCHCACIAEtAAc2AtQBIAIgAS0ABzYCQCACIAEtAAg2AtgBIAIgAS0ACDYCRCACIAEtAAk2AtwBIAIgAS0ACTYCSCACIAEtAAo2AuABIAIgAS0ACjYCTCACIAEtAAs2AuQBIAIgAS0AC0EfcTYCYCACIAEtAAtBBnY2AlAgAiABLQAMNgLoASACIAEtAAxBH3E2AmQgAiABLQAMQQZ2NgJUIAIgAS0ADTYC7AEgAiABLQANQR9xNgJoIAIgAS0ADUEGdjYCWCACIAEtAA42AvABIAIgAS0ADkEfcTYCbCACIAEtAA5BBnY2AlwgAiABLQAPNgL0ASACIAEtAA9BH3E2AoABIAIgAS0AD0EHdjYCcCACIAEtABA2AvgBIAIgAS0AEEEfcTYChAEgAiABLQAQQQd2NgJ0IAIgAS0AETYC/AEgAiABLQARQR9xNgKIASACIAEtABFBB3Y2AnggAiABLQASNgKAAiACIAEtABJBH3E2AowBIAIgAS0AEkEHdjYCfCACIAEtABM2AoQCIAIgAS0AE0EfcTYCkAEgAiABLQATQQZ2NgIgIAIgAS0AFDYCiAIgAiABLQAUQR9xNgKUASACIAEtABRBBnY2AiQgAiABLQAVNgKMAiACIAEtABVBH3E2ApgBIAIgAS0AFUEGdjYCKCACIAEtABY2ApACIAIgAS0AFkEfcTYCnAEgAiABLQAWQQZ2NgIsIAIgAS0AFzYClAIgAiABLQAXQQ9xNgKgASACIAEtABdBBHY2ArABIAIgAS0AGDYCmAIgAiABLQAYQQ9xNgKkASACIAEtABhBBHY2ArQBIAIgAS0AGTYCnAIgAiABLQAZQQ9xNgKoASACIAEtABlBBHY2ArgBIAIgAS0AGjYCoAIgAiABLQAaQQ9xNgKsASACIAEtABpBBHY2ArwBIAYgBUEbaiIFTA0BIAYgBWtBGkoNAAsLIARBADYC3OQEAkAgBCgC2OQEBEAgEkIANwP4ByASQgA3A/AHAkACf0H/ByECAkACQAJAAkAgACASIgFzQQNxDQBBASEFAkAgAEEDcUUNAANAIAEgAC0AACIFOgAAIAVFDQUgAUEBaiEBIAJBAWsiAkEARyEFIABBAWoiAEEDcUUNASACDQALCyAFRQ0CIAAtAABFDQMgAkEESQ0AA0BBgIKECCAAKAIAIgVrIAVyQYCBgoR4cUGAgYKEeEcNAiABIAU2AgAgAUEEaiEBIABBBGohACACQQRrIgJBA0sNAAsLIAJFDQELA0AgASAALQAAIgU6AAAgBUUNAiABQQFqIQEgAEEBaiEAIAJBAWsiAg0ACwtBACECCyABQQAgAhAUIBIQEUEBaiEAA0BBACAARQ0BGiASIABBAWsiAGoiAS0AAEEvRw0ACyABCyIABEAgAEEAOgABDAELIBJBADoAAAsgEiAEQYgUaiIBECUiAhAvIgANAQJAIAIgBEGIDGoQGiIAEBEiAkEATA0AIAAgAmoiAkEBay0AAEEvRg0AIAJBLzsAAAsgACABECUQLyIADQELQQAhACAEQQA2AtjkBAsgBEEBNgLc5ARBoPAAIAA2AgBBpPAAAn9BqPAAKAIAIgIoAgQiEyAANgIEIBMgBDYCAEEAIQEgAiIAKAIEIgJBADYCDCACKAIAIgRCADcC4PIIIARBADYC7OQEIARCyAE3AuTkBAJAAkAgBCgC0BwiBUEATARAQcgBIQIgACgCBCEBDAELIARBkBxqIQYgBEHw5ARqIQgDQCAIIAFB7CBsaiICQoGAgIAQNwIEIAYgAUECdGooAgAhCyACQgA3AiQgAkKDgICAgAE3AhwgAkIINwIUIAJCgICAgIAINwIMIAIgCzYCAAJAIAFBB00EQCABQQAgABAeIAJBADYCLCAAKAIAIAFBB3RqIgVB/AhqQQA2AgAgBUHMCGpBADYCACAEKALQHCEFDAELIAJBADYCLAsgAkIANwK0ICACQQA2AjAgAkIANwK8ICACQQA2AsQgIAJBADYC6CAgAkIANwLgICACQQA2AtggIAJCgICAgPAfNwLQICACQv8BNwLIICABQQFqIgEgBUgNAAsgACgCBCEBIAQoAuTkBCICQQJIDQELIAEoAgAgAjYC5OQECyATQQE2AggCfyATKAIAIQIgACgCCCIBQoGAgIAQNwLYBCACKAL48gghBCABQQA2AuQEIAEgAjYCACABIARBxNgCIAQbNgLgBCABAn8gASgCgAUiAkUEQCABQYAINgLwBEGAIAwBCyACEAkgAUEANgKABSABQYAINgLwBEGAIEGAECABKALcBEEBRhsLNgL0BCABKALoBCIFRQRAIAFBgCAQCiIFNgLoBAsgASgC7AQiAkUEQCABQYAgEAoiAjYC7AQLAn8CQCAFBEAgAgRAIAEoAvgEIgVFBEAgAUGAEBAKIgU2AvgECyABKAL8BCICRQRAIAFBgBAQCiICNgL8BAsgBQRAIAINAyAFEAkgASgC/AQhAgtBASACRQ0DGiACEAlBAQwECyAFEAkgASgC7AQhAgtBASACRQ0BGiACEAlBAQwCCyABQQE2AsQEIAEoAgAgASgC4AQ2AvjyCCAAKAIIIgFCADcCHCABQvD5gIAQNwIUIAFCgICAgIAQNwIMIAFCADcCBCABQgA3AiQgAUIANwIsIAFCADcCQCABQQE2AjwgAUKAgYCAgJ4PNwI0IAFCADcCSCABQgA3AlAgAUEBNgJgIAFCgIGAgICeDzcCWCABQgA3AmQgAUIANwJsIAFCADcCdCABQoCBgICAng83AnwgAUEBNgKEASABQgA3ApgBIAFCADcCkAEgAUIANwKIASABQoCBgICAng83AqABIAFBATYCqAEgAUIANwK8ASABQgA3ArQBIAFCADcCrAEgAUKAgYCAgJ4PNwLEASABQQE2AswBIAFCADcC4AEgAUIANwLYASABQgA3AtABIAFCgIGAgICeDzcC6AEgAUEBNgLwASABQgA3AvQBIAFCADcC/AEgAUIANwKEAiABQQE2ApQCIAFCgIGAgICeDzcCjAIgAUIANwKoAiABQgA3AqACIAFCADcCmAIgAUEBNgK4AiABQoCBgICAng83ArACIAFCADcCzAIgAUIANwLEAiABQgA3ArwCIAFBATYC3AIgAUKAgYCAgJ4PNwLUAiABQgA3AvACIAFCADcC6AIgAUIANwLgAiABQQE2AoADIAFCgIGAgICeDzcC+AIgAUIANwKUAyABQgA3AowDIAFCADcChAMgAUEBNgKkAyABQoCBgICAng83ApwDIAFCADcCuAMgAUIANwKwAyABQgA3AqgDIAFBATYCyAMgAUKAgYCAgJ4PNwLAAyABQgA3AtwDIAFCADcC1AMgAUIANwLMAyABQQE2AuwDIAFC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ASAANgIQIAEgADYCDCABIAA2AgggASAANgIEIAEgADYCACAMQQhqIgxBgAZHDQALIAdBuKECaiECIAcoArShAiEAQQAhDANAIAIgDEECdGoiASAANgIcIAEgADYCGCABIAA2AhQgASAANgIQIAEgADYCDCABIAA2AgggASAANgIEIAEgADYCACAMQQhqIgxBgAZHDQALIAdBuLkCaiECQQAhDANAIAIgDEECdGoiASAANgIcIAEgADYCGCABIAA2AhQgASAANgIQIAEgADYCDCABIAA2AgggASAANgIEIAEgADYCACAMQQhqIgxBgAZHDQALIAdBuNECaiECQQAhAUEAIQADQCACIABBAnRqIgUgBygCwNoCuEQAAAAAAACQP6IgAC0A8B+4okQAAAAAAACwPqJEAAAAAAAAkECiIAcoAsTaArijRAAAAAAAAPBAovwCIgY2AgAgBUEAIAZrNgKABCAAQQFqIgBBIEcNAAsDQCABQQJ0IgUgAmogBygCwNoCuEQAAAAAAACQP6IgAS0AkCC4okQAAAAAAACwPqJEAAAAAAAAkECiIAcoAsTaArijRAAAAAAAAPBAovwCIgY2AoABQQAhACAFIAdqQQAgBms2ArjWAiABQQFqIgFBIEcNAAsDQCAAQQJ0IgUgAmogBygCwNoCuEQAAAAAAACQP6IgAC0AsCC4okQAAAAAAACwPqJEAAAAAAAAkECiIAcoAsTaArijRAAAAAAAAPBAovwCIgY2AoACQQAhASAFIAdqQQAgBms2ArjXAiAAQQFqIgBBIEcNAAsDQCABQQJ0IgAgAmogBygCwNoCuEQAAAAAAACQP6IgAS0A0CC4okQAAAAAAACwPqJEAAAAAAAAkECiIAcoAsTaArijRAAAAAAAAPBAovwCIgU2AoADIAAgB2pBACAFazYCuNgCIAFBAWoiAUEgRw0ACyAHQaghaiEBQQAhAANAIAEgAEECdGpEAAAAAAAAkEAgALihRAAAAAAAAFBAoiAHKALA2gK4oyAHKALE2gK4okQAAAAAAADwQKL8AzYCACAAQQFqIgBBgAhHDQALIAdBqMEAaiEBQQAhAANAIAEgAEECdGpEAAAAAAAAcEAgALihRAAAAAAAAJBAoiAHKALA2gK4oyAHKALE2gK4okQAAAAAAADwQKL8AzYCACAAQQFqIgBBgAJHDQALIAdBuNkCaiEBIAcoAsDaArhEAAAAAAAAkD+iIAcoAsTaArijIR1BACEAA0AgASAAQQJ0aiAdRAAAAAAAAPBAQYAIIABBBXRruKP8AkEGdLei/AM2AgAgAEEBaiIAQR9HDQALIAdBADsBnCEgB0GAgAw2AswgIAcgHUQAAAAAAADwQKL8AzYCtNoCIAdEAAAAAICEjkEgBygCxNoCuCIdo/wDNgLYICAHRAAAAACAhO5BIB2j/AM2AsggIAcQLgsgAyAHNgKkEEEAIAdFDQAaIAQoAgAoAqQQEC4gA0KBgICA8A83ApgQIAQoAgAiAEEANgIgIAAoApgQQQFGBEAgBCgCACgCpBBBCEEAEAgLIAQoAgAiAEEBNgIgIAAoApgQQQFGBEAgBCgCACgCpBBBCEEBEAgLIAQoAgAiAEECNgIgIAAoApgQQQFGBEAgBCgCACgCpBBBCEECEAgLIAQoAgAiAEEDNgIgIAAoApgQQQFGBEAgBCgCACgCpBBBCEEDEAgLIAQoAgAiAEEENgIgIAAoApgQQQFGBEAgBCgCACgCpBBBCEEEEAgLIAQoAgAiAEEFNgIgIAAoApgQQQFGBEAgBCgCACgCpBBBCEEFEAgLIAQoAgAiAEEGNgIgIAAoApgQQQFGBEAgBCgCACgCpBBBCEEGEAgLIAQoAgAiAEEHNgIgIAAoApgQQQFGBEAgBCgCACgCpBBBCEEHEAgLIAQoAgAiAEEANgI8IAAoApgQQQFGBEAgBCgCACgCpBBBD0EAEAgLIAQoAgAiAEEANgJgIAAoApgQQQFGBEAgBCgCACgCpBBBGEEAEAgLIAQoAgAiAEEANgJkIAAoApgQQQFGBEAgBCgCACgCpBBBGUEAEAgLIAQoAgAiAEGAATYCZCAAKAKYEEEBRgRAIAQoAgAoAqQQQRlBgAEQCAsgBCgCACIAQQA2AmwgACgCmBBBAUYEQCAEKAIAKAKkEEEbQQAQCAtBACEAA0AgBCgCACIBIABBIHIiAkECdGpBwAE2AgAgASgCmBBBAUYEQCAEKAIAKAKkECACQcABEAgLIAQoAgAiASAAQShyIgJBAnRqQQA2AgAgASgCmBBBAUYEQCAEKAIAKAKkECACQQAQCAsgBCgCACIBIABBMHIiAkECdGpBADYCACABKAKYEEEBRgRAIAQoAgAoAqQQIAJBABAICyAEKAIAIgEgAEE4ciICQQJ0akEANgIAIAEoApgQQQFGBEAgBCgCACgCpBAgAkEAEAgLIABBAWoiAEEIRw0AC0EAIQADQCAEKAIAIgEgAEHAAHIiAkECdGpBADYCACABKAKYEEEBRgRAIAQoAgAoAqQQIAJBABAICyAEKAIAIgEgAEHgAHIiAkECdGpBADYCACABKAKYEEEBRgRAIAQoAgAoAqQQIAJBABAICyAEKAIAIgEgAEGAAXIiAkECdGpBADYCACABKAKYEEEBRgRAIAQoAgAoAqQQIAJBABAICyAEKAIAIgEgAEGgAXIiAkECdGpBADYCACABKAKYEEEBRgRAIAQoAgAoAqQQIAJBABAICyAEKAIAIgEgAEHAAXIiAkECdGpBADYCACABKAKYEEEBRgRAIAQoAgAoAqQQIAJBABAICyAEKAIAIgEgAEHgAXIiAkECdGpBADYCACABKAKYEEEBRgRAIAQoAgAoAqQQIAJBABAICyAAQQFqIgBBIEcNAAsgA0IANwL8CCADQgA3AtwIIANCADcCzAggA0IANwLUCCADQv////8PNwKMCSADQn83AoQJIANCADcC7AggA0KAgICAMDcC5AggA0IANwKYCCADQgA3AqAIIANCADcCqAggA0EANgKwCCADQgA3AsAIIANCADcCuAggA0KAgICA8A83AvQIIANCADcC3AkgA0IANwL8CSADQgA3AtQJIANCgICAgDA3AuQJIANCADcCzAkgA0L/////DzcCjAogA0J/NwKECiADQgA3AuwJIANBADYCsAkgA0IANwKoCSADQgA3AqAJIANCADcCmAkgA0IANwLACSADQgA3ArgJIANCADcC/AogA0IANwLcCiADQoCAgIDwDzcC9AkgA0EDNgLoCiADQgA3AswKIANCADcC1AogA0L/////DzcCjAsgA0J/NwKECyADQQA2AvQKIANCADcC7AogA0EANgLkCiADQQA2ArAKIANCADcCqAogA0IANwKgCiADQgA3ApgKIANCADcCwAogA0IANwK4CiADQgA3AvwLIANCADcC3AsgA0H/ADYC+AogA0EDNgLoCyADQgA3AtQLIANCADcCzAsgA0L/////DzcCjAwgA0J/NwKEDCADQQA2AvQLIANCADcC7AsgA0EANgLkCyADQQA2ArALIANCADcCqAsgA0IANwKgCyADQgA3ApgLIANCADcCwAsgA0IANwK4CyADQgA3AvwMIANCADcC3AwgA0H/ADYC+AsgA0EDNgLoDCADQgA3AtQMIANCADcCzAwgA0L/////DzcCjA0gA0J/NwKEDSADQQA2AvQMIANCADcC7AwgA0EANgLkDCADQQA2ArAMIANCADcCqAwgA0IANwKgDCADQgA3ApgMIANCADcCwAwgA0IANwK4DCADQgA3AvwNIANCADcC3A0gA0H/ADYC+AwgA0EDNgLoDSADQgA3AtQNIANCADcCzA0gA0L/////DzcCjA4gA0J/NwKEDiADQQA2AvQNIANCADcC7A0gA0EANgLkDSADQQA2ArANIANCADcCqA0gA0IANwKgDSADQgA3ApgNIANCADcCwA0gA0IANwK4DSADQgA3AvwOIANCADcC3A4gA0H/ADYC+A0gA0EDNgLoDiADQgA3AtQOIANCADcCzA4gA0L/////DzcCjA8gA0J/NwKEDyADQQA2AvQOIANCADcC7A4gA0EANgLkDiADQQA2ArAOIANCADcCqA4gA0IANwKgDiADQgA3ApgOIANCADcCwA4gA0IANwK4DiADQgA3AvwPIANCADcC3A8gA0H/ADYC+A4gA0EDNgLoDyADQgA3AtQPIANCADcCzA8gA0L/////DzcCjBAgA0J/NwKEECADQQA2AvQPIANCADcC7A8gA0EANgLkDyADQQA2ArAPIANCADcCqA8gA0IANwKgDyADQgA3ApgPIANCADcCwA8gA0IANwK4DyADQf8ANgL4DyADQQA2ApQIIANCADcCjAggA0IANwKECEEBC0UNABogE0H/ADYCHCATQgA3AhQgEwsiADYCACAARQ0AQQAhFUGU8ABBADYCAEGY8ABBAkEBQajwACgCACgCCCgC3ARBAUYbNgIACyASQYAIaiQAIBULOgBB2OICQdjhAjYCAEGw4gJBgIAENgIAQaziAkGQ7wY2AgBBkOICQSo2AgBBtOICQfTuACgCADYCAAsL+2QfAEGACAtULnBkeAAtKyAgIDBYMHgATmFnYXNha2ktTGluZQBzcmMvcGR4ZmlsZS5jAHJiAHJ3YQBIaXplbi1IYW1hAC4AKG51bGwpACVzIEVycm9yIDogJWQKAEHkCAv5AxIAAAAcAAAAJAAAACoAAAAuAAAAMwAAADYAAAA5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BnwGfQZ/BoAGggaDBoUGhgaIBokGiwaMBo4GjwaRBpIGlQaWBpgGmQabBpwGngafBqEGogakBqUGpwaoBqoGqwatBq4GsAaxBrMGtAa2BrcGuQa6BrwGvQa/BsAGwgbDBsYGxwbJBsoGzAbNBs8G0AbSBtQG1QbXBtgG2gbbBt0G3wbgBuIG4wblBuYG6AbpBusG7QbuBvAG8QbzBvQG9gb5BvoG/Ab9Bv8GAQcCBwQHBgcHBwkHCgcMBw4HDwcRBxMHFAcWBxcHGQcbBxwHHgcgByEHIwckByYHKAcpBysHLQcuBzAHMQczBzUHNgc4BzoHOwc9Bz4HQAdCB0MHRQdIB0kHSwdMB04HUAdRB1MHVQdXB1gHWgdcB10HXwdgB2MHZAdmB2cHaQdrB2wHbgdwB3IHcwd1B3cHeAd6B3sHfgd/B4EHgweFB4YHiAeKB4wHjQePB5EHkweUB5YHmAeaB5sHnQefB6EHogekB6YHqAepB6sHrQevB7AHsge0B7cHuAe6B7wHvge/B8EHwwfFB8YHyAfKB8wHzQfPB9EH0wfUB9YH2AfaB9sH3QffB+EH4wflB+YH6AfqB+wH7QfwB/EH8wf1B/cH+Qf7B/wH/wcACAIIBAgGCAgICggLCA4IDwgRCBMIFQgXCBkIGggdCB4IIAgiCCQIJggoCCkILAgtCC8IMQgzCDUINwg4CDsIPAg+CEAIQghECEYIRwhKCEsITQhPCFEIUwhVCFYIWQhbCF0IXghhCGIIZAhmCGkIaghsCG4IcAhyCHQIdQh4CHoIfAh9CIAIgQiDCIUIiQiKCIwIjgiQCJIIlAiVCJgImgicCJ0IoAihCKMIpQioCKoIrAiuCK8IsgizCLYIuAi6CLwIvgi/CMIIwwjGCMkIywjNCM8I0AjTCNQI1wjZCNsI3QjfCOAI4wjkCOcI6QjrCO0I7wjwCPMI9Aj3CPkI+wj9CP8IAAkDCQQJBwkLCQ0JDwkRCRIJFQkWCRkJGwkdCR8JIQkiCSUJJgkpCSwJLgkwCTIJMwk2CTcJOgk8CT4JQAlCCUMJRglHCUoJTglQCVIJVAlVCVgJWQlcCV4JYAliCWQJZwlqCWsJbglxCXMJdQl3CXgJewl8CX8JgQmDCYUJhwmKCY0JjgmRCZQJlgmYCZoJmwmeCZ8JogmkCaYJqAmqCa0JsAmxCbQJuAm6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";

    // --- VARIABLES SYSTEME MDX ---
    let mdxModule = null;
    let mdxScriptNode = null;
    let mdxWasmPtr = null;
    let isMdxPlaying = false;
    let isMdxInitialized = false;
    const MDX_BUFFER_SIZE = 4096;

    // --- UTILITAIRES MDX ---
    function base64ToUint8Array(base64) {
      if (!base64) return new Uint8Array(0);
      const binaryString = window.atob(base64);
      const len = binaryString.length;
      const bytes = new Uint8Array(len);
      for (let i = 0; i < len; i++) {
        bytes[i] = binaryString.charCodeAt(i);
      }
      return bytes;
    }

    async function decompressGzip(compressedBytes) {
      // Polyfill minimal ou utilisation API native
      if ('DecompressionStream' in window) {
        const ds = new DecompressionStream('gzip');
        const writer = ds.writable.getWriter();
        writer.write(compressedBytes);
        writer.close();
        const response = new Response(ds.readable);
        return await response.arrayBuffer();
      } else {
        console.error("DecompressionStream not supported by this browser.");
        return new ArrayBuffer(0);
      }
    }

    async function initMdxSystem() {
      if (isMdxInitialized) return;
      if (typeof createMdxModule === 'undefined' || !WASM_BASE64) return;

      try {
        console.log("[MDX] decoding WASM binary...");
        const wasmBinary = base64ToUint8Array(WASM_BASE64);

        console.log("[MDX] Emscripten module init...");
        mdxModule = await createMdxModule({
          wasmBinary: wasmBinary,
          print: (text) => console.log("[MDX C] " + text),
          printErr: (text) => console.error("[MDX C Err] " + text)
        });

        isMdxInitialized = true;
        console.log("[MDX] WASM ready.");

      } catch (e) {
        console.error("[MDX] CRITICAL INIT ERROR: " + e.message);
      }
    }

    async function startMdxPlayback(sound) {
      if (isMdxPlaying || !isMdxInitialized) return;

      // Reprendre le contexte Audio du jeu s'il est suspendu
      if (audioCtx.state === 'suspended') await audioCtx.resume();

      try {
        console.log("[MDX] Decoding and decompressing MDX music...");
        if (!sound || !sound.base64) throw new Error("no music provided");

        const compressedMusic = base64ToUint8Array(sound.base64);
        const musicData = await decompressGzip(compressedMusic);
        console.log(`[MDX] Music uncompressed : ${musicData.byteLength} octets`);

        // Écriture dans le FS virtuel
        mdxModule.FS.writeFile("/song.mdx", new Uint8Array(musicData));

        // For the first music, drums samples are needed, hence load them:
        if (sound.musicName === 'musicBlockTown') {
          console.log("[PDX] Decoding and decompressing MDX music...");
          const compressedDrums = base64ToUint8Array(BLOCK_TOWN_SOUND_PDX_BASE64);
          const drumsData = await decompressGzip(compressedDrums);
          console.log(`[PDX] Drums samples uncompressed : ${drumsData.byteLength} octets`);

          // Écriture dans le FS virtuel
          mdxModule.FS.writeFile("/alp.pdx", new Uint8Array(drumsData));
          console.log("[PDX] Drums samples ready.");
        }
        let res =null;
        if (sound.musicName === 'musicBlockTown') {
          res = mdxModule.ccall('init_player', 'number', ['string', 'string'], ["/song.mdx"], ["/alp.mdx"]);
        } else {
          res = mdxModule.ccall('init_player', 'number', ['string'], ["/song.mdx"]);
        }
        if (res !== 0) throw new Error("Erreur init_player code: " + res);

        console.log("[MDX] Start playing!");

        // Allocation mémoire audio si pas fait
        if (!mdxWasmPtr) {
          mdxWasmPtr = mdxModule._malloc(MDX_BUFFER_SIZE * 2 * 4); // Stereo Float32
        }

        // Création du noeud de script
        // Note: ScriptProcessor est déprécié mais nécessaire pour ce type d'intégration WASM simple sans Worklet complexe
        mdxScriptNode = audioCtx.createScriptProcessor(MDX_BUFFER_SIZE, 0, 2);

        mdxScriptNode.onaudioprocess = (e) => {
          const outputL = e.outputBuffer.getChannelData(0);
          const outputR = e.outputBuffer.getChannelData(1);

          // Générer l'audio dans la mémoire WASM
          mdxModule._generate_audio(mdxWasmPtr, MDX_BUFFER_SIZE);

          // Récupérer les données depuis la mémoire WASM (Float32Array)
          const wasmFloats = mdxModule.HEAPF32.subarray(
            mdxWasmPtr / 4,
            mdxWasmPtr / 4 + (MDX_BUFFER_SIZE * 2)
          );

          // Copier dans les buffers WebAudio
          for (let i = 0; i < MDX_BUFFER_SIZE; i++) {
            outputL[i] = wasmFloats[i * 2];
            outputR[i] = wasmFloats[i * 2 + 1];
          }
        };

        // Connecter au volume global puis à la destination
        const gainNode = audioCtx.createGain();
        gainNode.gain.value = sound.soundLevel; // Utiliser le volume défini dans le jeu
        mdxScriptNode.connect(gainNode);
        gainNode.connect(audioCtx.destination);

        isMdxPlaying = true;
        currentMusicKey = "MDX_TRACK"; // Pour garder la compatibilité avec la logique UI

      } catch (e) {
        console.error("[MDX] Reading error: " + e.message);
        isMdxPlaying = false;
      }
    }

    function stopMdxPlayback() {
      if (mdxScriptNode) {
        try {
          mdxScriptNode.disconnect();
          mdxScriptNode.onaudioprocess = null; // Nettoyage
        } catch (e) { }
        mdxScriptNode = null;
      }
      isMdxPlaying = false;
      currentMusicKey = null;
    }

    // Music gathered from https://chiptune.app/?q=pacmania and have been processed this way : gzip -8 -c music.MDX | base64
    const BLOCK_TOWN_SOUND_BASE64 = "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";
    const BLOCK_TOWN_SOUND_PDX_BASE64 = "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";
    const PACMAN_S_PARK_SOUND_BASE64 = "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";
    const SANDBOX_LAND_SOUN_BASE64 = "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";
    const JUNGLY_STEPS_SOUND_BASE64 = "H4sICLt/fmkAA1BNNC5NRFgApVRNbBtFFF7/xNnd2Fj4PVeJt5KdSGgHIcShJY0qhBuhHEACtQJxAQmVItQqKpVCDzUHnGxjlCKuICEDJoGSFOM4TtwYd+VuiGUsQ8QJceXCkQMGCUdaN2FmN3a8zrp1xc7u22/mfW/e+96sfXbyublPX5x86fnJCLnw+DvnL1+4EonMnVEuKVeVy8rbyrRyjc5mlHeVt5QryszcmUjkzVhEuaVsK3/5xBAn/sahY8z9lHt3YMuzwJ8XkuKvu/v7f94bbrr0WS6J8ejLyeAAe7+SDLqTQfbG1tyybsPzJKGT1x1H/Tb7d8wHuvy2c2Pf4MPv00c9nvre37v790aaLk7/cHEkE1oMLUvp0DJ9GziUljowW5faWDL40sF6f3zJEmvmau0zYom17mOX67BOybKnXS6pXU/IJhfj3C/X0f176bKrrd9cdnlHbPog/Y/+P4gv9cjV2Qf72O68R/v2cN/V/flSH9/G4Xn17qGlTq7e/If+GEJNV9MZj3aMY/r16lI8ekKlRiwStnaxuhiPDv8wHveUzjUdFnZwA+QCyhtILTHxOsqbSNaBWoZvI8kBtXKO4iBZAzmP8hq2bdNl2dBujOsLXCOjZeb1D7jGurY+r19nr0Qjr+Xnufr+qV5C4mMVJqV8Lj7aKGr0Ll6kDnf56Wm1W0j0dFuAKcYQYNigKckQ0GHz2CmmDxnRMNNR0AqGjpJWYjpUTU007mp3mY6Jnjqi8YHyWaqk8p65OFNZmi6Px8cammbe2gstPTNG+XLbbh6cyMG5HJ5FC69ZpPSjY4jpoIUbOra1baajolUSjR1tp6VDojqMimj5XEomS0S+SWKGJSvkmmHlNImtEJKWySqJpYm8SkhOjjFL5DyJGZYU5BizRL5DYgVC7sikREhjS6P3VvHBtdqNS/pHWb7pFFSx6eCz4gESskLTyZtIbCOhk9flbcWK+sImz28z3ybzmYhFMsSzNWFbsHp78OiaWBT4CpsXWRxDQpFVZiKxjYQDL9+x1kKtWHGL53eYZ4t5rIhnSGijIzyhyztU35PpwR4/8oF2jAl99hef9yeft+rzlqVQOURvqVHWygnjY3jiM8QvAL5EWAL4mn5r8A3CCuC3AN8hrELTCWsI6wh5hE2A77FHntMqqKgCFLFIHyiwgVnIUluEDGboE4++pt/g1IAND7OBQ17rZzOqz2pAB0IJSlhCI1CFDdygtoQ5zAVydNPX9RsWGjCSSkmUhiWgNMhBd70n63s/9tE5747PV/N6Kz7J6Bu92/9Rg59jIIWwiPAVBm6yxi0j3MJAOhjIINXddNIKAxsIt6lKDBSDPdI8VoUqVgEqWKEPlNkwdJbpgtkls3HVgA0P1cAhr6NxPwMdCDWoYQ2NwCrtkEZtjbaoFCiZjbPQgJGqyJpZxRrrJe2oTeOqdW74pP/E+46rkhwcTYbfCLsHB3mOXv/+0WiMPON3OBzcUJjjwt6w95OPU6kwxamU3x+a8A+6BripqSnOSy8PvVjUq/SSnvXzDid3ik4fDYfDlPwI53a7/dR1/Em/0+l2yB7B9fsxH3P5Z0VR9CcSif8AZzHnlp0LAAA=";
    const AUDIENCE_BASE64 = "H4sICPN/fmkAA1BNMC5NRFgAjVL/axtlHH7vcpe7S5tLNtOVpq1NU2zTpK42S1K/TNsypVPsNhjUFoKkSdDb6bbkCg6FNfZ+6a8KGp2/jAobU0wgoRM7mV9mFXXz2/8ggrAfLP1lkOtT3zfpclEr9ODlns/zPp/n89y976mpY8uXZqZOPDsVCGWGzy2czZwPBJYnlyfNl8yU+aqZpcgwFynOm4uMDwTSrwfMj8xb5l9ul58IfxAf9wE/7bjq2BFOCheFqvD7vZ2du9vE4rbIBKmtbKgSUk9CW0SuUFv+1UOrMWjHkcvXVm6zKgRtGLmZDc9+dRYfQGoYWgS5k9+qMlIT0N6od/3Gqhi008gt1VbusOq+jjnYOlbZOlY1dRYXsGf9K7vcmom5N3XyPrP3IRWBdgS5+e9dAlIj0BLIJX9geBTaBHIv/8jwbvdthndz3mF4HFqSzXjzJ1Y9Bi3zs3wAqSegvfKLfLCRgQbo9WySezvbAjsDQmrF1YEgFgZwpgP5RMnrxEIQZ3zIx1bVfpt39zf5D33ROn8I+fGyW7H59qDNq7Z+tSds+9DvbfJtAy3+DTJ+jZrUmY/bBj5xhUuDznpYbjfsCllvl5GOQh+HcYqdb/ph6IdhTH/FcBj6EIzJdbVFQyc2NZ5WjcX333BTIgb9cRinv2NNh6GPwjj+dYvZDXUfGnYx/jF1P8n+V0OTIR2BHoZx7KYiID0CPQLj6S/oueojMJ750iXarYpoZ2J4FPoYjOduMfwI9CMwnv9GOoD0GPQ4jBMb9Co0I/R467+Xt3j6f8VasSJ6kPGXpBAyPWtSAw8xrFjcYNXpqTpD12W1Kg1dly0+xLZFLzLdFfmpimI5ZutdLyDT+5kzWTcW7xuXBC+y3RWF6bjZsugtSxNlyeLnK5KKrL/kDCHbsybXsdTAzC/b+6nzRWQfXJce2iTbDnoH7vJEFsifRy0HV3uroL6rFBJFuuibr10iONuJi/7P2+f2VpeoskwXffN4rQtLXTzOHaoqESz511zBvZuuuArxq7TpCmu60IVC16M434mC/ybr2CQk6uknF7jQ8AyZK869w3GizNFnK7YV5xpb4aFJMjf7futWgh/xiCLHdQ8SMp9MJt9Ti293trmV6Y54wnHUE81H+d4OQvr6fH2SdPkyvfvk4ANOp9AwDPpi/5klNgz9exj+DefY0/bIBQAA";
    const GAME_OVER_SOUND_BASE64 = "H4sICM9/fmkAA1BNNS5NRFgAbZBNaxNhEMdnkzbN5m2T2HbXvuBSfElim2ZN1QaVpFiQHpSCUPoGabJBsIm1NvHgQbZZ8Sq0qKAeQm9VsgeppSltpHjRb+DBT1DIwVAwKUknThLRQ3x4GOaZ//P/zTCTYzfTb26P3ZkYE12yeynyQH4oiulQOiSq99QFNaHG0iF1SX2sxtRHzboYfSKq79Uv6k+rqQd0DuiEKXgJPxgX85TJMt91XLlWK5y0VfVHcK3yCrLmUVzo2bJexYW+XD3yWfEs5Tvc5ZxzpKADow0OmSO4UcrNFlZz7UqgCOXaif6Pf6DuifBZ2xWMEGVmy05J77bd24aR/n/uYGl/vrC6b1JGinDSXtXDEUDlLek2mDhkxvesnRh146KEK948N41RFy76cGVoz+HHxWFcGdylLtELOfsISbtzShAIo2vB5Dknyh6M+zEpHTimUHZjXMKkN0+++CVMDn82B1A+j/EhTHq2nVRxf5pRgjqCMS2wA3M3xlyY8GGK5pjCmAcTfkxJBwT7W6exYm5MSJjy5okXO4eJi5hyfZxTQo01Gao6qDyHDTagsQLdDRO/wZ7WBgY2WX6TFT6wQpbqISXYSzN0VBmmPsMLmmHQQnsb10y8Zp7XzF2abVYzCpqlW5OU+/SVrTL06VuxsVyyPBsvZWDHpNQjyzeiUFlrFgNNKThZpK0xLs6o9zMevwThvnCYNZjWyW/8VT426pqSW/K2SHofRyn0nRLgDB1DJpOpv2scx7U1Jf4/UnsT6PINtQANo9zysg/6eQHC5LJaLBmHk3NMH89aOq5zNiCmCA0grK+t3Qp97dCXysesnmN80rJskEHoEu5Sq9f8O7uVWpl+A4BOJKspAwAA";
    const HIGHSCORE_BASE64 = "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";

    // Digitalized sound gathered from https://sounds.spriters-resource.com/arcade/pacmania/asset/439130/ and have been converted,via https://convertio.co/ to opux - mono - 16KBPS -> base64
    const APPLAUSE_BASE64 = "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";
    const MUNCH_SOUND_BASE64 = "T2dnUwACAAAAAAAAAAACztB2AAAAAAIfId0BE09wdXNIZWFkAQE4AUAfAAAAAABPZ2dTAAAAAAAAAAAAAALO0HYBAAAAp3dXtAE/T3B1c1RhZ3MNAAAATGF2ZjU4Ljc2LjEwMAEAAAAeAAAAZW5jb2Rlcj1MYXZjNTguMTM0LjEwMCBsaWJvcHVzT2dnUwAESEUAAAAAAAACztB2AgAAAClFuRoTLC8lKisLDhAPJywuLh4REgsLCgiCW5MIHZ0RTVGk7eufhvx1f8qt2kPl80kPcMtLP+w5yuHxHfVIaawC/d/wCK+hHJpgtzhS0RyikVz1Pid+5FSuw6a1PpGp9qqIsgsX+1wPBcJwiJqbwXWuJEAIrDgERwOrmKblhHwMfHevBYsET3Ufh0H7Imx4XW7x+XXloF3CCKqHLXs5j0ffP3X7FS3YFl9YHwf6CimjOBivG5n7V3nKPNaRCHtvOz+wCKCEy8EEmQW2+kpfNdqqbWs7n/iuYp4AgAzoG5KNOZisp36Zh0/7y/bngAguewABMCKEL41QCAtLcn45ePEZtScYKKAICmVyh8FDA2zaYYstJpPWCAmG7O3fc+ZBKGI/uQ5ACJxRFCZ+R22/9jAVHPXJ/TcB6J4NknE7UznIDrzLSunbdI/oc6IQCKYX+mk54l4R1PDN4/q8Z0Ylrwo5Dd7v/nR6Es+W3F3ysZU7ETDtLjJjPmAIrDgAU7SNvNyGI+R3eXjq07jBDvlhmqNBs5h5ry6lhrZHxACN/2baLTp0Vhi8CKqHbqPHhawR0k19vCQYHOLRTM64fPxRwiUFNd79S9QiCbbgDRpt0x3pg5QO+ginhpIxAQfv6q0Kmlmja9rHhD0yUn7BEkISpZbYUQg0NUBIwhlvZScfVCyxjtGPCAzU+03c9Cia7Vb49GBH2xSQCAplcjqroj42DaAICYbsxXz/O8IKKAgJbs358d+WsYA=";
    const JUMP_SOUND_BASE64 = "T2dnUwACAAAAAAAAAAAdbt8xAAAAAFlSV1ABE09wdXNIZWFkAQE4AYC7AAAAAABPZ2dTAAAAAAAAAAAAAB1u3zEBAAAAfZFvSwE/T3B1c1RhZ3MNAAAATGF2ZjU4Ljc2LjEwMAEAAAAeAAAAZW5jb2Rlcj1MYXZjNTguMTM0LjEwMCBsaWJvcHVzT2dnUwAEaCYAAAAAAAAdbt8xAgAAAMOqXg0LKiYyNDAvNjo7LjB4g/iwHsQTqz3ScWZw0TQnqgIlffeTg0E+HnPTJWCL0xvJObwQeePVM4J4hIDiV1EEJTsABV68/3dQWTQaUKNZJbzIwgde5dDzWPcuzt3J+3izGsR58Bi/qR/LfBrxZPbm9DCEDJwjHFv4nxh4O3hrweTOo2Cj+P8UTKMu4ULptd+leLCl/pM1UnkH2UJPmKdf7xcqHPl9JID4tpGl9VO/91BXcEQttyUlYvBkNcpa4VQ8HXIEy3ivQyAALMR4oVPTnNCjnM9LDJBdMieSE7nMJwe4DIkAS7X3Hh1yjnsxRABJ8UslR3iyqE4kIzlu/m+2P+31l2hhP2SE8fIdcdkO99HXbtRz+8HfevbEmbzUTU1lGmMUeLS1R5OnHyBfe8w+8t7AOwQmyBrlPGeTt/tXmZSR4kr8oOwCCTre0Hk5eYHLdJwNMINrYQtmeLFa5ki9G7l0H8vvNO9qklSHjfFCob7lhEPIncZ8gacHXWE3LSC2XgH/BAkE76sYPlDjD4S5ABFmEHiwpStupUXgcnsWgk3VEv9xp2GHMoh38/JTN+mTRwFCWcBANdPbEJPUKHnhVcgbMr6qBddR8BVRH/dzeKoHQitXdFaupzNvjPCw5vn5YPAqaKP7BS04ExNDgwuikJcNT8JihdYZuU8Z2nit5AEL/aWy0/dQ0NV6iCWvRHD9Q97a4ewxpO75NtknYDN4LjPS6miRDL8Ya68bLQ==";
    const LAND_SOUND_BASE64 = "T2dnUwACAAAAAAAAAADLYVmmAAAAAGbUr1sBE09wdXNIZWFkAQE4AYC7AAAAAABPZ2dTAAAAAAAAAAAAAMthWaYBAAAAi8eepgE/T3B1c1RhZ3MNAAAATGF2ZjU4Ljc2LjEwMAEAAAAeAAAAZW5jb2Rlcj1MYXZjNTguMTM0LjEwMCBsaWJvcHVzT2dnUwAEyBAAAAAAAADLYVmmAgAAAOcYJ3cFJzsxHih4g/kNcQK69J8TCEmlBW3R7bWJ6oSTxCUm2oDs3EE8HnaToqByfsl4t3m1/AfPgUeNAtMGnY6z3eMSkH9wqvn+STr/3CWXdY5ZZA7+btYZvdhhBHgQSHN4jNgJxTt8VUXgPniEcYtQM6kCp6OIPOp0wLYPJPwM2S1YtA2qByPcjj/aoMBki23yW9TsKt2OqzzJ9q14Bm5iZfs52RX1ejw+FKtZgIRfMe+rmGSX3nxXdnx4BmrmgAnmjOW8FjRPxuMGOAG8tspjWiwdi71XOeovq3YdzD+v91Hl";
    const LIFE_LOSS_BASE64 = "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";
    const POWER_PELLET_OBTAIN_BASE64 = "T2dnUwACAAAAAAAAAABQVrKCAAAAAD03ThsBE09wdXNIZWFkAQE4AYC7AAAAAABPZ2dTAAAAAAAAAAAAAFBWsoIBAAAAlZ57wQE/T3B1c1RhZ3MNAAAATGF2ZjU4Ljc2LjEwMAEAAAAeAAAAZW5jb2Rlcj1MYXZjNTguMTM0LjEwMCBsaWJvcHVzT2dnUwAEmSwAAAAAAABQVrKCAgAAAMJcnj8MLSg0OTktNzIyNSUseIOcqlP4p9L3tpIfJrezh1x6sT8er3LGkP9DCHogj6a04QTW7zhyu9f1hHqfeLhbE4KTrrbq7JarMUH1/l74P63RVbTDhKTdLjRwgRrOo/mXN2yyn3i3ioGBSEtpXPmK1japEmIWqOAZHjMXhJpz5y2Ly7cJUE77XR9yzPLki5qQkxpCa0kmC+h4uHQ2GEtxQso3BGGYGdukKLsZBNT5ORuUbCJMC5uSH/PHQTxwRh0SJUz3s3HRAvuP6PLZkmMSqCd4typyqFnBXcElIuGEF83cVyUYZp+gCK461BtxeKeeBl0w+y3uzdr2tfKib6UfZEX6vu6406u6DNh4todvwYzP2N1L2qVIrV0lJZOqFiK9Q5DfpTY4IGTucHh/9E9fHoZmGS3kCy54of5hqFRbrwRnOLGhLf8KHt62vi/l3cJy738eiHI+4mEOUGkjyqPjzHpAG0gb+h7gHcWbL1e8eLeOqdVsKkBdL4z6B9HVZKaDksCSLyjU/E+oZ+LyUuWO7r56eoCfxwiZqe1DbSwUbul4uHSfIqUvhMBy8PyDpO0iv9kprox9wS9FT0gxlCeo+SwuFP1eq3ICBZ0HrZnmvPfNAHi/sW5xuNpfQX2uK1kui/L/C65kSOKwesWA8380CbBE+olUOOU3KrrZO9+eJUL416NdIhbEeLhkUdntu/NTvg+5r2yz7i78GSp0r7Lkv4Yh0YYqBeEWKcP4dHi4byVvp0l08lUMF09kUU9B2CD6Zqo1YKoWH3G5P08m/nxNTDcQ8P5xr0f/";
    const POWER_PELLET_BASE64 = "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";
    const GHOST_EATEN_BASE64 = "T2dnUwACAAAAAAAAAADoaHSzAAAAAOMEZnABE09wdXNIZWFkAQE4AYC7AAAAAABPZ2dTAAAAAAAAAAAAAOhodLMBAAAA6Dym4gE/T3B1c1RhZ3MNAAAATGF2ZjU4Ljc2LjEwMAEAAAAeAAAAZW5jb2Rlcj1MYXZjNTguMTM0LjEwMCBsaWJvcHVzT2dnUwAEI14AAAAAAADoaHSzAgAAAEI/l1saKCkqMScmMSUuLzc9NjMzNz8tNTs2PzUwMiN4g22wPAnCRi1YyxMxwoyJ45VsXAQg1of4CoM3CKiY7hTUmXHzJkvneLUCGeb2An1+bNow0cBmTF04EFhOZCJwmme1VPb0AlTIZ076CBQLurV4s9KuJnO8qpBoe8kvrtrrZf3Iv2QuvWvKR+PSvB/uJjKH2iBI8Q1JB3h4sfRNEfqrKoYR0iF8OXreBOHE4X0lFQ4MXNjvHDkrUel1vAr01cbrVkEmS2KGgAZReD9Y/aXhy3kLV9ebKE3NbgGFdGXlWARoB48fIlkgPLCYUObZ0JOJeD9eCXA35IOY7okVAV+3bjwoUgVRJv8vrj4dgrPqUtu0qVMT4Bh4taG9+ue/E0E8xuQZtahGdsv54uUxBGqpN/COn9z0sO3U26EFJtgCXkxpTgas+1gteAZtZnRxX5hTGAnYgmo9qn0I1dM+nrt45OmcunAN8EyncI+U7ng/XgyC57vGO2ZU2K5fLHrD3OvP15dCLsSDY45fJRuzy8cN2Y1awIW5/mcummh4lBCwuE9STerBCoF9sMlUKCuaYLu8WIx0mKl748dz7BUqSOQr4s2k5+AuOYSObXiz3LWXruABBsvfuekGAcDER9HyoHmEVcRRpiv7wA1I8M8BLxX2+qbvcL9c5IyXJB9bnyadPi14tLaTh3UfptBHmN4Y/OyGQAspuvF0DA5hiPVuo3af4so5jXeLgx431JJmcGV/VgoO5vsArwwrs3BT0JGteLCv10yxZoO27Opht+CtP+M+sr/wryj16ITa5vrW+O4i7jxGBh4Y77lSJ/NiFKcJ/DUt9zKyeKzNTJR3Y+HYzw5UWrvgWngD4kROTqfO2FzR+wXLNHjiLkh0Sy8s0zIADt8rYVJH04nWeL9GJET2KzHJ5hZ8mYbVc58QSsVIvXH/SivfXJTzODCIH1ciDsRIRWw24pOUaghIZGF1eLPk6lMH/85Ga6ZmTzRVihxOZyVEg/XaFDp1o9b9cbsECJaJuw0uBJ91uD8yQYe/dC5QF2d0zXi1lxYqscvHaYw+avOJS/oDzPTM+ob67KrGfaSJDdtNFxawsWC8SfFAEzaE7lgu5UyucbUFGUqvRj3C8XO8t3ivTTjR3VKpX4Y4hVSlVu1E6POonk2GqUyLj598OdGIMi2RLy+8/69Ar/UBt3iuJo4AZV4l3IrOEpS5+bjBvI+q7WtwDQr2CTwz1alLjGpx4F6lVwQMxXNd06HEZuNOwWJDeLQ3BTl+prDfmdpS4cmS7A4UUv7eEiTXdipeXMTv8ICd5SdI32fQcbk28tG7RmZ4XKwj9bfZwnMo1W14rtGRXIHmqA9dcd/987G+VimuTzrAU27r4nvEJhv5JC8qzcnINF0IZIqZ1B4WSiez2FPyKPJ4sv3Ty8yZ08rLBWRziaQbDBiKL/rcNRugfuAQArKgPBNpbxNUQ7KdqMPJ8MXycKjODuPogR+NoPksjkX/Rhd4vwk+ZvcLrHiFDilBdw+DMir1B+yevVvklxm+xZo8D+SSRUacdNo65U3qaj6WuXvl4Jzce3i+4xLOPWuN76NPaFHPzJvzFwAcAQLcMhl0cHNOUNfsxWN1rtqfnbVX/gJeJdlYO3i/h29PJzOTCNuA+GKb0fb9/K+jt+vBBHCyF3Q6Vbh9mWvXCOQaYVDhl8olcZPaQAlGeLWWQMAU2dW9Av+OGL8xwbpGtC7Vda20pXAVt3fPXxUuVOw=";
    const EXTRA_LIFE_SOUND_BASE64 = "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";

    const SOUNDS = {
      musicBlockTown: { base64: BLOCK_TOWN_SOUND_BASE64, buffer: null, source: null, format: "MDX", soundLevel: 0.4, musicName: "musicBlockTown" },
      pacmanS: { base64: PACMAN_S_PARK_SOUND_BASE64, buffer: null, format: "MDX", soundLevel: 0.6, musicName: "pacmanS" },
      sandboxLand: { base64: SANDBOX_LAND_SOUN_BASE64, buffer: null, format: "MDX", soundLevel: 0.6, musicName: "sandboxLand" },
      junglySteps: { base64: JUNGLY_STEPS_SOUND_BASE64, buffer: null, format: "MDX", soundLevel: 0.6, musicName: "junglySteps"  },
      audience: { base64: AUDIENCE_BASE64, buffer: null, source: null, format: "MDX", soundLevel: 1, musicName: "audience" },
      gameOver: { base64: GAME_OVER_SOUND_BASE64, buffer: null, format: "MDX", soundLevel: 1, musicName: "gameOver"  },
      highScore: { base64: HIGHSCORE_BASE64, buffer: null, format: "MDX", soundLevel: 1, musicName: "highScore"  },
      applause: { base64: APPLAUSE_BASE64, buffer: null, format: "OPUS", soundLevel: 1, musicName: "applause"  },
      munch: { base64: MUNCH_SOUND_BASE64, buffer: null, format: "OPUS", soundLevel: 1, musicName: "munch"  },
      jump: { base64: JUMP_SOUND_BASE64, buffer: null, format: "OPUS", soundLevel: 1, musicName: "jump"  },
      land: { base64: LAND_SOUND_BASE64, buffer: null, format: "OPUS", soundLevel: 1, musicName: "land"  },
      lifeLoss: { base64: LIFE_LOSS_BASE64, buffer: null, format: "OPUS", soundLevel: 1, musicName: "lifeLoss"  },
      powerPelletMusic: { base64: POWER_PELLET_BASE64, buffer: null, format: "OPUS", soundLevel: 1, musicName: "powerPelletMusic"  },
      powerPelletObtain: { base64: POWER_PELLET_OBTAIN_BASE64, buffer: null, format: "OPUS", soundLevel: 1, musicName: "powerPelletObtain"  },
      powerPelletMusic: { base64: POWER_PELLET_BASE64, buffer: null, format: "OPUS", soundLevel: 1, musicName: "powerPelletMusic"  },
      ghostEaten: { base64: GHOST_EATEN_BASE64, buffer: null, format: "OPUS", soundLevel: 1, musicName: "ghostEaten"  },
      extraLife: { base64: EXTRA_LIFE_SOUND_BASE64, buffer: null, format: "OPUS", soundLevel: 0.75, musicName: "extraLife"  }
    };

    function decodeSound(key) {
      const data = SOUNDS[key];
      if (!data || !data.base64 || data.format === "MDX") return;

      try {
        const binaryString = window.atob(data.base64);
        const len = binaryString.length;
        const bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
          bytes[i] = binaryString.charCodeAt(i);
        }
        audioCtx.decodeAudioData(
          bytes.buffer,
          (buffer) => {
            data.buffer = buffer;
            console.log(`Sound '${key}' loaded.`);
          },
          (e) => console.error("Error decoding " + key, e),
        );
      } catch (e) {
        console.error("Error loading " + key, e);
      }
    }
    Object.keys(SOUNDS).forEach((key) => decodeSound(key));

    function playSound(key) {
      if (audioCtx.state === "suspended") audioCtx.resume();
      const data = SOUNDS[key];
      if (data && data.buffer) {
        const source = audioCtx.createBufferSource();
        source.buffer = data.buffer;
        source.connect(audioCtx.destination);
        source.start(0);
        return data.buffer.duration; // Retourne la durée
      }
      return 2.0; // Durée par défaut si pas chargé
    }

    // Fonctions d'interface

    function playGameOver() {
      stopMdxPlayback();
      startMdxPlayback(SOUNDS.gameOver);
    }

    function playHighScore() {
      stopMdxPlayback();
      startMdxPlayback(SOUNDS.highScore);
    }

    // --- NOUVEAU SYSTÈME DE MUSIQUE DYNAMIQUE ---
    let currentMusicKey = null;

    function getMusicKeyForLevel(level) {
      // Cycle sur 4 musiques : 0=BlockTown, 1=PacmanS, 2=Sandbox, 3=Jungly
      const idx = (level - 1) % 4;
      const keys = [
        "musicBlockTown",
        "pacmanS",
        "sandboxLand",
        "junglySteps",
      ];
      return keys[idx];
    }

    function playLevelMusic() {
      // Arrêter toute musique existante avant de lancer la nouvelle
      stopLevelMusic();
      const key = getMusicKeyForLevel(currentLevel);
      const data = SOUNDS[key];
      startMdxPlayback(data);
      currentMusicKey = key; // Mémoriser quelle musique joue
    }

    function stopLevelMusic() {
      stopMdxPlayback();
      currentMusicKey = null;
    }

    function playPowerPelletMusic() {
      if (audioCtx.state === "suspended") audioCtx.resume();
      const data = SOUNDS.powerPelletMusic;
      if (data && data.buffer && !data.source) {
        data.source = audioCtx.createBufferSource();
        data.source.buffer = data.buffer;
        data.source.loop = true;
        data.source.connect(audioCtx.destination);
        data.source.start(0);
      }
    }

    function stopPowerPelletMusic() {
      const data = SOUNDS.powerPelletMusic;
      if (data && data.source) {
        try {
          data.source.stop();
        } catch (e) { }
        data.source = null;
      }
    }

    function setDifficulty(level) {
      PACMAN_SPEED_NORMAL = Math.min(
        CONFIG.SPEEDS.PACMAN_NORMAL_BASE + level * 0.01,
        CONFIG.SPEEDS.PACMAN_NORMAL_MAX,
      );
      PACMAN_SPEED_EATING = Math.min(
        CONFIG.SPEEDS.PACMAN_EATING_BASE + level * 0.005,
        CONFIG.SPEEDS.PACMAN_EATING_MAX,
      );
      GHOST_SPEED = Math.min(
        CONFIG.SPEEDS.GHOST_NORMAL_BASE + level * 0.008,
        CONFIG.SPEEDS.GHOST_NORMAL_MAX,
      );
      POWER_PELLET_DURATION = Math.max(
        CONFIG.DURATIONS.POWER_PELLET_MIN,
        CONFIG.DURATIONS.POWER_PELLET_BASE - level * 500,
      );
      document.getElementById("level").innerText = level;
    }

    // --- HELPER : FLOU DU JEU ---
    // Active ou désactive la classe CSS qui floute le jeu
    function toggleBlur(enable) {
      const isHigh = CONFIG.GRAPHICS.QUALITY_TIER === "HIGH";

      // Nettoyer les classes
      document.body.classList.remove(
        "paused",
        "high-quality",
        "low-med-quality",
      );

      if (enable) {
        document.body.classList.add("paused");
        if (isHigh) document.body.classList.add("high-quality");
        else document.body.classList.add("low-med-quality");
      }
    }

    // --- HELPER : TEXTURE PROCÉDURALE LEGO (Grayscale pour multiplication) ---
    function createLegoStudTexture(baseColorHex) {
      const canvas = document.createElement("canvas");
      canvas.width = 128;
      canvas.height = 128; // Haute résolution pour le texte
      const ctx = canvas.getContext("2d");

      // Couleur de base de la brique
      ctx.fillStyle = baseColorHex;
      ctx.fillRect(0, 0, 128, 128);

      const studRadius = 20;
      const offsets = [
        [32, 32],
        [96, 32],
        [32, 96],
        [96, 96],
      ];

      // Check if base color is white (case-insensitive)
      const isWhite =
        (typeof baseColorHex === "string" &&
          baseColorHex.toLowerCase() === "#ffffff") ||
        baseColorHex === 0xffffff;

      offsets.forEach((pos) => {
        // 1. Ombre portée (Drop shadow)
        ctx.fillStyle = "rgba(0,0,0,0.35)";
        ctx.beginPath();
        ctx.arc(pos[0] + 8, pos[1] + 8, studRadius, 0, Math.PI * 2);
        ctx.fill();

        // 2. Face supérieure
        ctx.fillStyle = baseColorHex;
        ctx.beginPath();
        ctx.arc(pos[0], pos[1], studRadius * 0.92, 0, Math.PI * 2);
        ctx.fill();

        // 3. TEXTE "LEGO" (Logo gravé)
        ctx.font = "900 10px Arial, sans-serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";

        // Effet d'embossage pour le texte
        // Ombre
        ctx.fillStyle = "rgba(0,0,0,0.3)"; // Renforcé
        ctx.fillText("LEGO", pos[0] - 0.5, pos[1] - 0.5);

        // Highlight
        ctx.fillStyle = "rgba(255,255,255,0.3)";
        ctx.fillText("LEGO", pos[0] + 0.5, pos[1] + 0.5);

        // --- MODIFICATION : Corps du texte explicite pour le blanc ---
        if (isWhite) {
          ctx.fillStyle = "rgba(0,0,0,0.25)"; // Gris clair sur blanc
          ctx.fillText("LEGO", pos[0], pos[1]);
        }
      });

      const tex = new THREE.CanvasTexture(canvas);
      tex.anisotropy = 4;
      return tex;
    }

    function createSingleLegoStudLogoTexture() {
      const canvas = document.createElement("canvas");
      canvas.width = 64;
      canvas.height = 64;
      const ctx = canvas.getContext("2d");

      // Fond blanc pour multiplication par setColorAt
      ctx.fillStyle = "#ffffff";
      ctx.fillRect(0, 0, 64, 64);

      ctx.font = "bolder 14px Arial, sans-serif";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";

      // Effet de gravure (embossage inversé pour donner l'impression de creux/relief)

      // --- MODIFICATION : CONTRASTE RENFORCÉ ---

      // Ombre (Noir transparent) -> Plus fort pour être visible sur blanc
      ctx.fillStyle = "rgba(0,0,0,0.3)";
      ctx.fillText("LEGO", 32 - 1, 32 - 1);

      // Highlight (Blanc transparent)
      ctx.fillStyle = "rgba(255,255,255,0.5)";
      ctx.fillText("LEGO", 32 + 1, 32 + 1);

      // Corps principal (Gris transparent) -> Créera du gris sur blanc, et du rouge foncé sur rouge
      ctx.fillStyle = "rgba(0,0,0,0.25)";
      ctx.fillText("LEGO", 32, 32);

      const tex = new THREE.CanvasTexture(canvas);
      return tex;
    }

    function runBenchmark(renderer) {
      // Création d'une scène de test lourde (Stress Test CPU/GPU DrawCalls)
      const scene = new THREE.Scene();
      const cam = new THREE.PerspectiveCamera(75, 1, 0.1, 100);
      const geo = new THREE.BoxGeometry(1, 1, 1);
      const mat = new THREE.MeshBasicMaterial({ color: 0xff0000 });

      // On simule 6000 objets pour tester le goulot d'étranglement des draw calls
      // (Similaire à ce que le jeu fait avec les murs/studs non instanciés)
      const meshCount = 6000;
      const meshes = [];
      for (let i = 0; i < meshCount; i++) {
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.set(
          Math.random() * 20 - 10,
          Math.random() * 20 - 10,
          -Math.random() * 20,
        );
        scene.add(mesh);
        meshes.push(mesh);
      }

      // Préchauffe (Shader compilation)
      renderer.render(scene, cam);

      // Mesure
      const start = performance.now();
      renderer.render(scene, cam);
      const end = performance.now();
      const duration = end - start;

      // Cleanup
      meshes.forEach((m) => {
        scene.remove(m);
        // m.geometry et material sont partagés, pas besoin de dispose
      });
      geo.dispose();
      mat.dispose();

      console.log(`[BENCHMARK] Render time: ${duration.toFixed(2)}ms`);

      // Seuils empiriques
      if (duration < 12) return "HIGH"; // < 12ms frame time (très large pour 60fps)
      if (duration < 30) return "MEDIUM"; // < 30ms (un peu juste pour 60fps mais jouable)
      return "LOW"; // Machine lente
    }

    function configureGraphics(tier) {
      console.log(`[CONFIG] Applying Quality Tier: ${tier}`);
      CONFIG.GRAPHICS.QUALITY_TIER = tier;

      if (tier === "HIGH") {
        CONFIG.GRAPHICS.SEGMENTS = 32;
        CONFIG.GRAPHICS.USE_FLOOR_STUDS = true;
        CONFIG.GRAPHICS.USE_WALL_STUDS = true;
        CONFIG.GRAPHICS.SHADOW_MAP_SIZE = 2048;
        CONFIG.GRAPHICS.PARTICLE_COUNT = 150;
      } else if (tier === "MEDIUM") {
        CONFIG.GRAPHICS.SEGMENTS = 16;
        CONFIG.GRAPHICS.USE_FLOOR_STUDS = false; // Sol plat
        CONFIG.GRAPHICS.USE_WALL_STUDS = true;
        CONFIG.GRAPHICS.SHADOW_MAP_SIZE = 1024;
        CONFIG.GRAPHICS.PARTICLE_COUNT = 80;
      } else {
        // LOW
        CONFIG.GRAPHICS.SEGMENTS = 8;
        CONFIG.GRAPHICS.USE_FLOOR_STUDS = false;
        CONFIG.GRAPHICS.USE_WALL_STUDS = false; // Murs lisses (texture)
        CONFIG.GRAPHICS.SHADOW_MAP_SIZE = -1;
        CONFIG.GRAPHICS.PARTICLE_COUNT = 40;
      }
    }

    function init() {
      loadHighScores(); // Charger les scores au démarrage

      // --- INIT MDX ---
      initMdxSystem();

      // --- RENDERER INIT & BENCHMARK ---
      renderer = new THREE.WebGLRenderer({
        antialias: true,
        powerPreference: "high-performance",
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      renderer.domElement.id = "game-canvas";
      document.body.appendChild(renderer.domElement);

      // RUN BENCHMARK
      const qualityTier = runBenchmark(renderer);
      configureGraphics(qualityTier);

      // Afficher info sur l'écran
      document.getElementById("overlay-title").innerText = ""; // Clear
      const vInfo = document.getElementById("game-version");
      if (vInfo) vInfo.innerText += ` [${qualityTier}]`;

      scene = new THREE.Scene();
      scene.background = new THREE.Color(CONFIG.COLORS.BG_ISO);

      const aspect = window.innerWidth / window.innerHeight;

      // --- MODIFICATION CAMERA : ORTHOGRAPHIQUE ---
      const viewSize = CONFIG.CAMERA.VIEW_SIZE;
      camera = new THREE.OrthographicCamera(
        (viewSize * aspect) / -2,
        (viewSize * aspect) / 2,
        viewSize / 2,
        viewSize / -2,
        1,
        2000,
      );
      camera.position.set(
        viewMode_0_DEFAULT_OFFSET,
        viewMode_0_DEFAULT_OFFSET,
        viewMode_0_DEFAULT_OFFSET,
      );
      camera.lookAt(0, 0, 0);

      // Note: renderer déjà ajouté au DOM plus haut
      // document.body.appendChild(renderer.domElement);

      // --- DAY/NIGHT CYCLE LIGHTING ---
      ambientLight = new THREE.AmbientLight(0x666666);
      scene.add(ambientLight);

      // MODIFICATION: dirLight est maintenant global et on ajoute sa cible à la scène
      dirLight = new THREE.DirectionalLight(0xffffff, 0.9);
      dirLight.position.set(60, 120, 40);

      // Qualité ombres dynamique
      const shadowSize = CONFIG.GRAPHICS.SHADOW_MAP_SIZE;
      if (shadowSize != -1) {
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = shadowSize;
        dirLight.shadow.mapSize.height = shadowSize;
        // Augmentation légère de la zone d'ombre pour éviter le clipping sur les bords
        dirLight.shadow.camera.left = -150;
        dirLight.shadow.camera.right = 150;
        dirLight.shadow.camera.top = 150;
        dirLight.shadow.camera.bottom = -150;
        dirLight.shadow.bias = -0.0001;
        dirLight.shadow.normalBias = 0.08;
      }
      scene.add(dirLight);
      scene.add(dirLight.target); // IMPORTANT: Ajouter la cible pour qu'elle puisse bouger

      // --- PAC-MAN FLASHLIGHT (Pour la nuit) ---
      pacmanLight = new THREE.SpotLight(0xffffcc, 0); // Intensité 0 au début (jour)
      pacmanLight.angle = Math.PI / 6; // Angle de 30 degrés
      pacmanLight.penumbra = 0.3; // Douceur des bords
      pacmanLight.distance = TILE_SIZE * 8; // Portée d'environ 8 blocs
      pacmanLight.decay = 2;
      pacmanLight.castShadow = false; // Pas d'ombre pour perfs
      scene.add(pacmanLight);
      scene.add(pacmanLight.target);

      // Initial view icon
      updateViewIcon();
      initEditorPalette();
      startLevel(CONFIG.GAME.START_LEVEL);

      // --- INIT POST PROCESSING (CUSTOM TILT SHIFT) ---
      if (CONFIG.GRAPHICS.QUALITY_TIER === "HIGH") {
        initPostProcessing();
      }

      window.addEventListener("resize", onWindowResize, false);
      document.addEventListener("keydown", onKeyDown, false);

      onWindowResize(); // Force la taille du canvas dès le début
      animate();
    }

    function initPostProcessing() {
      // Création du Composer (chaîne d'effets)
      composer = new THREE.EffectComposer(renderer);

      // 1. Passe de rendu de base
      const renderPass = new THREE.RenderPass(scene, camera);
      composer.addPass(renderPass);

      // 2. Passe Custom Tilt-Shift
      // Remplace l'ancien BokehPass qui dépendait de la 3D
      tiltShiftPass = new THREE.ShaderPass(TiltShiftShader);
      tiltShiftPass.renderToScreen = true;
      composer.addPass(tiltShiftPass);

      console.log("[POST-PROCESSING] Custom Tilt-Shift Pass Initialized");
    }

    function clearLevel() {
      if (pacman) scene.remove(pacman);
      ghosts.forEach((g) => scene.remove(g));
      pellets.forEach((p) => scene.remove(p));
      walls.forEach((w) => scene.remove(w));
      ghosts = [];
      pellets = [];
      walls = [];
      pacman = null;
    }

    const ALL_MAPS = [
      null,
      LEVEL_1_MAP,
      LEVEL_2_MAP,
      LEVEL_3_MAP,
      LEVEL_4_MAP,
      LEVEL_5_MAP,
      LEVEL_6_MAP,
      LEVEL_7_MAP,
      LEVEL_8_MAP,
      LEVEL_9_MAP,
      LEVEL_10_MAP,
      LEVEL_11_MAP,
      LEVEL_12_MAP,
      LEVEL_13_MAP,
      LEVEL_14_MAP,
      LEVEL_15_MAP,
      LEVEL_16_MAP,
    ];

    function startLevel(levelIndex) {
      clearLevel();
      currentLevel = levelIndex;
      // ALTERNANCE PERSONNAGE (Pair = Ms Pacman, Impair = Pacman)
      isMsPacman = currentLevel % 2 === 0;

      setDifficulty(currentLevel);

      // 1. Récupération Config Niveau (Déduplication)
      const mapIdx = ((levelIndex - 1) % 16) + 1;
      const config =
        MAP_CONFIGS.find((c) => c.id === mapIdx) || MAP_CONFIGS[0];

      // 2. Setup Map
      let mapData = ALL_MAPS[mapIdx];

      if (!mapData) mapData = LEVEL_1_MAP; // Fallback
      currentMap = JSON.parse(JSON.stringify(mapData));

      // 3. Setup Globals
      houseEntrance = { ...config.house };
      const levelColors = config.colors.map((k) => CONFIG.COLORS[k]);

      createLevel(levelColors);
      createPacman();
      createGhosts();

      isGameOver = false;
      isGameRunning = false;

      // Reset Overlay UI elements
      document.getElementById("overlay").style.display = "flex";
      document.getElementById("highscore-screen").style.display = "none";
      document.getElementById("highscore-footer").style.display = "none";
      document.getElementById("initials-screen").style.display = "none";
      toggleBlur(true);

      // LOGIQUE D'AFFICHAGE TITRE / NIVEAU
      const titleEl = document.getElementById("overlay-title");
      const msgEl = document.getElementById("overlay-msg");
      const logoEl = document.getElementById("game-logo");

      titleEl.style.display = "block";
      msgEl.classList.remove("blinking");
      msgEl.classList.add("blinking"); // Restart blink
      msgEl.innerHTML = "PRESS SPACEBAR TO PLAY";

      if (levelIndex === 1) {
        // Écran Titre Principal (Attract Mode)
        gameState = STATE_TITLE;
        titleScreenTimer = performance.now(); // Reset timer pour le loop attract

        logoEl.style.display = "block"; // Afficher le logo
      } else {
        // Transition directe vers niveau suivant (Pas de boucle attract)
        gameState = STATE_GAME; // En attente de start (isGameRunning est false)

        titleEl.innerText = "LEVEL " + levelIndex;
        titleEl.style.color = "#FFD700";
        logoEl.style.display = "none"; // Cacher le logo pour voir le niveau derrière
      }

      if (pacman) {
        // Reset caméra position initiale (Iso)
        updateViewIcon();
        const offset = new THREE.Vector3(
          viewMode_0_DEFAULT_OFFSET,
          viewMode_0_DEFAULT_OFFSET,
          viewMode_0_DEFAULT_OFFSET,
        );
        const targetPos = pacman.position.clone().add(offset);
        camera.position.copy(targetPos);
        camera.lookAt(pacman.position);
        currentLookAt.copy(pacman.position);
      }
    }

    function startGame() {
      // Si on est en transition (confettis), on bloque les inputs
      if (isTransitioning) return;

      if (isGameOver) {
        // On ne sauvegarde pas ici car fait à la fin de l'anim de mort ou initiales
        startLevel(1);
        score = 0;
        lives = CONFIG.GAME.LIVES;
        nextLifeThreshold = CONFIG.GAME.NEXT_LIFE_THRESHOLD_START;
        document.getElementById("score").innerText = 0;
        document.getElementById("lives").innerText = lives;
        return;
      }

      // --- MODIFICATION : Condition assouplie ---
      // On lance le jeu si on n'est pas déjà en train de courir, même si on est déjà en STATE_GAME
      if (!isGameRunning && !isDying) {
        gameState = STATE_GAME;
        isGameRunning = true;
        if (audioCtx.state === "suspended") audioCtx.resume();
        document.getElementById("overlay").style.display = "none";
        document.getElementById("highscore-screen").style.display = "none";
        document.getElementById("highscore-footer").style.display = "none";
        document.getElementById("initials-screen").style.display = "none";

        // --- CHANGEMENT : Appel de la musique dynamique ---
        playLevelMusic();

        toggleBlur(false);

        // Démarrage automatique vers la gauche
        nextDir.set(-1, 0, 0);

        // Initialiser le timer jour/nuit
        dayNightStartTime = Date.now();
      }
    }

    function createLevel(levelColors) {
      const WALL_HEIGHT = CONFIG.PHYSICS.WALL_HEIGHT;
      totalPellets = 0;
      pelletsEatenCount = 0;

      // On calcule les dimensions et les offsets AVANT de générer le sol
      const mapWidth = currentMap[0].length;
      const mapHeight = currentMap.length;
      levelMapOffsetX = (mapWidth * TILE_SIZE) / 2;
      levelMapOffsetZ = (mapHeight * TILE_SIZE) / 2;
      const mapOffsetX = levelMapOffsetX;
      const mapOffsetZ = levelMapOffsetZ;

      const floorMat = new THREE.MeshPhongMaterial({
        color: 0x2e8b57,
        shininess: 30,
      });
      const floorGeo = new THREE.PlaneGeometry(
        CONFIG.GRAPHICS.FLOOR_SIZE,
        CONFIG.GRAPHICS.FLOOR_SIZE,
      );
      const floor = new THREE.Mesh(floorGeo, floorMat);
      floor.rotation.x = -Math.PI / 2;
      floor.position.set(0, -0.6, 0);
      floor.receiveShadow = true;
      walls.push(floor);
      scene.add(floor);

      // --- TENONS SOL (InstancedMesh) ---
      if (CONFIG.GRAPHICS.USE_FLOOR_STUDS) {
        const studLogoTex = createSingleLegoStudLogoTexture();
        const floorStudGeo = new THREE.CylinderGeometry(
          1.6,
          1.6,
          1.2,
          CONFIG.GRAPHICS.SEGMENTS / 2,
        ); // Moins de segments pour le sol
        const floorStudMat = new THREE.MeshPhongMaterial({
          color: 0x2e8b57,
          shininess: 30,
        });
        const floorStudMatTop = new THREE.MeshPhongMaterial({
          color: 0x2e8b57,
          map: studLogoTex,
          shininess: 30,
        });

        // CylinderGeometry materials: [side, top, bottom]
        const floorStudMaterials = [
          floorStudMat,
          floorStudMatTop,
          floorStudMat,
        ];

        const range = 40;
        const instanceCount = range * 2 * (range * 2) * 4;
        const floorStuds = new THREE.InstancedMesh(
          floorStudGeo,
          floorStudMaterials,
          instanceCount,
        );
        floorStuds.receiveShadow = true;
        floorStuds.castShadow = false;
        const dummy = new THREE.Object3D();
        let idx = 0;
        const studOffset = 2.5;
        const shiftX = mapOffsetX % TILE_SIZE;
        const shiftZ = mapOffsetZ % TILE_SIZE;

        for (let x = -range; x < range; x++) {
          for (let z = -range; z < range; z++) {
            const tx = x * (TILE_SIZE / 2) - shiftX + studOffset;
            const tz = z * (TILE_SIZE / 2) - shiftZ + studOffset;

            const offsets = [
              { x: tx - studOffset, z: tz - studOffset },
              { x: tx + studOffset, z: tz - studOffset },
              { x: tx - studOffset, z: tz + studOffset },
              { x: tx + studOffset, z: tz + studOffset },
            ];

            for (let off of offsets) {
              dummy.position.set(tx, 0, tz);
              dummy.updateMatrix();
              dummy.rotation.set(0, Math.PI / 2, 0);
              floorStuds.setMatrixAt(idx++, dummy.matrix);
            }
          }
        }
        dummy.rotation.set(0, 0, 0); // Reset rotation for other uses
        scene.add(floorStuds);
        walls.push(floorStuds);
      } else {
        const floorStudTex = createLegoStudTexture("#FFF");
        floorStudTex.wrapS = THREE.RepeatWrapping;
        floorStudTex.wrapT = THREE.RepeatWrapping;
        floorStudTex.repeat.set(
          CONFIG.GRAPHICS.FLOOR_SIZE / TILE_SIZE,
          CONFIG.GRAPHICS.FLOOR_SIZE / TILE_SIZE,
        );

        floorMat.map = floorStudTex;
        floorMat.needsUpdate = true;
      }

      // GÉOMÉTRIE & MATÉRIAUX MURS (OPTIMISÉ INSTANCED MESH)
      const wallBoxGeo = new THREE.BoxGeometry(
        TILE_SIZE,
        WALL_HEIGHT,
        TILE_SIZE,
      );

      // Texture de studs pour le mode MID/LOW ou Matériau sans texture pour HIGH
      let wallMatTop = null;
      let wallMatSide = new THREE.MeshPhongMaterial({
        color: 0xffffff,
        shininess: 60,
        specular: 0x555555,
      }); // Blanc neutre pour instancedColor

      let useTexturedStuds = !CONFIG.GRAPHICS.USE_WALL_STUDS;
      if (useTexturedStuds) {
        const studTex = createLegoStudTexture("#FFF"); // Blanc neutre pour multiplication
        wallMatTop = new THREE.MeshPhongMaterial({
          map: studTex,
          color: 0xffffff,
          shininess: 60,
        });
      } else {
        wallMatTop = wallMatSide;
      }

      // Material Array pour Box (Face Top = index 2)
      // [x+, x-, y+, y-, z+, z-]
      const wallMaterialsArray = [
        wallMatSide,
        wallMatSide,
        wallMatTop,
        wallMatSide,
        wallMatSide,
        wallMatSide,
      ];

      // 1. Lister les murs pour compter et preparer les Instances
      let wallCount = 0;
      const wallInstances = []; // {x, z, color}

      for (let z = 0; z < mapHeight; z++) {
        for (let x = 0; x < mapWidth; x++) {
          const type = currentMap[z][x];
          const posX = x * TILE_SIZE - mapOffsetX;
          const posZ = z * TILE_SIZE - mapOffsetZ;
          if (type === 1) {
            wallCount++;
            // Couleur aléatoire du niveau
            const randomColor =
              levelColors[Math.floor(Math.random() * levelColors.length)];
            wallInstances.push({
              x: posX,
              z: posZ,
              color: new THREE.Color(randomColor),
            });
          } else if (type === 0 || type === 2) {
            // GOMMES (Restent des Mesh simples pour gestion individuelle simple eat/hide)
            const isPower = type === 2;
            const geom = isPower
              ? new THREE.SphereGeometry(
                3,
                CONFIG.GRAPHICS.SEGMENTS,
                CONFIG.GRAPHICS.SEGMENTS,
              )
              : new THREE.SphereGeometry(
                1.5,
                CONFIG.GRAPHICS.SEGMENTS,
                CONFIG.GRAPHICS.SEGMENTS,
              );
            const mat = isPower
              ? new THREE.MeshPhongMaterial({
                color: 0xffd700,
                emissive: 0xffa500,
                shininess: 50,
              })
              : new THREE.MeshLambertMaterial({ color: 0xffd700 });

            const pellet = new THREE.Mesh(geom, mat);
            pellet.position.set(posX, isPower ? 3 : 2, posZ);
            pellet.userData = {
              active: true,
              gridX: x,
              gridZ: z,
              isPower: isPower,
            };

            // --- AJOUT OMBRES POUR LES GOMMES (Mode High uniquement) ---
            if (
              CONFIG.GRAPHICS.QUALITY_TIER === "HIGH" &&
              isPower === false
            ) {
              pellet.castShadow = true;
            }

            scene.add(pellet);
            pellets.push(pellet);
            totalPellets++;
          }
        }
      }

      // 2. Créer l'InstancedMesh pour les MURS
      if (wallCount > 0) {
        const wallMesh = new THREE.InstancedMesh(
          wallBoxGeo,
          wallMaterialsArray,
          wallCount,
        );
        wallMesh.castShadow = true;
        wallMesh.receiveShadow = true;

        const dummy = new THREE.Object3D();
        for (let i = 0; i < wallInstances.length; i++) {
          const inst = wallInstances[i];
          dummy.position.set(inst.x, WALL_HEIGHT / 2 - 0.6, inst.z);
          dummy.updateMatrix();
          wallMesh.setMatrixAt(i, dummy.matrix);
          wallMesh.setColorAt(i, inst.color);
        }
        scene.add(wallMesh);
        walls.push(wallMesh);

        // 3. Créer STUDS 3D (Seulement si HIGH)
        // On utilise aussi InstancedMesh, 4 studs par mur
        if (CONFIG.GRAPHICS.USE_WALL_STUDS) {
          const studLogoTex = createSingleLegoStudLogoTexture();
          const studGeo = new THREE.CylinderGeometry(
            1.6,
            1.6,
            1.2,
            CONFIG.GRAPHICS.SEGMENTS,
          );
          const studsCount = wallCount * 4;

          const studMatTop = new THREE.MeshPhongMaterial({
            map: studLogoTex,
            shininess: 60,
          });
          const studMaterials = [wallMatSide, studMatTop, wallMatSide];

          // On utilise le même matériau 'side' blanc pour être piloté par setColorAt
          const studMesh = new THREE.InstancedMesh(
            studGeo,
            studMaterials,
            studsCount,
          );
          studMesh.castShadow = true;
          studMesh.receiveShadow = true; // Studs projettent ombres sur high

          const studsPosOffsets = [
            { x: -2.5, z: -2.5 },
            { x: 2.5, z: -2.5 },
            { x: -2.5, z: 2.5 },
            { x: 2.5, z: 2.5 },
          ];
          let sIdx = 0;

          for (let i = 0; i < wallInstances.length; i++) {
            const inst = wallInstances[i];
            const baseY = WALL_HEIGHT / 2 - 0.6 + WALL_HEIGHT / 2 + 0.6; // Top of wall

            // Rotation aléatoire de la brique (0, 90, 180, 270°)
            const randomRot = (Math.floor(Math.random() * 4) * Math.PI) / 2;
            const cos = Math.cos(randomRot);
            const sin = Math.sin(randomRot);

            studsPosOffsets.forEach((off) => {
              const rx = off.x * cos - off.z * sin;
              const rz = off.x * sin + off.z * cos;

              dummy.position.set(inst.x + rx, baseY, inst.z + rz);
              dummy.rotation.set(0, randomRot, 0);
              dummy.updateMatrix();
              studMesh.setMatrixAt(sIdx, dummy.matrix);
              studMesh.setColorAt(sIdx, inst.color);
              sIdx++;
            });
          }
          dummy.rotation.set(0, 0, 0); // Reset pour les utilisations futures
          scene.add(studMesh);
          walls.push(studMesh);
        }
      }
    }

    // HELPERS
    function updatePacmanAppearance() {
      if (!pacman) return;
      if (pacman.bow) pacman.bow.visible = isMsPacman;
      if (pacman.mole) pacman.mole.visible = isMsPacman;
      if (pacman.lashes)
        pacman.lashes.forEach((l) => (l.visible = isMsPacman));
      // AJOUT : Visibilité des lèvres
      if (pacman.lipsTop) pacman.lipsTop.visible = isMsPacman;
      if (pacman.lipsBottom) pacman.lipsBottom.visible = isMsPacman;
    }

    function createPacman() {
      pacman = new THREE.Group();
      pacman.body = new THREE.Group();
      const sphereRadius = 3.5;
      const sphereSegments = CONFIG.GRAPHICS.SEGMENTS;
      const pacColor = 0xffff00;
      const mat = new THREE.MeshPhongMaterial({
        color: pacColor,
        shininess: 100,
        specular: 0xffffff,
      });
      // Stocker le matériau pour modification cycle jour/nuit
      pacman.userData = pacman.userData || {};
      pacman.userData.bodyMaterial = mat;

      // Matériau intérieur bouche (noir)
      const mouthInsideMat = new THREE.MeshBasicMaterial({
        color: 0x000000,
        side: THREE.DoubleSide,
      });

      // --- Hémisphère HAUT ---
      const topGeo = new THREE.SphereGeometry(
        sphereRadius,
        sphereSegments,
        sphereSegments,
        0,
        Math.PI * 2,
        0,
        Math.PI / 2,
      );
      pacman.topLip = new THREE.Group();
      pacman.topLip.add(new THREE.Mesh(topGeo, mat));
      const capGeo = new THREE.CircleGeometry(
        sphereRadius - 0.1,
        sphereSegments,
      );
      const topCap = new THREE.Mesh(capGeo, mouthInsideMat);
      topCap.rotation.x = Math.PI / 2;
      pacman.topLip.add(topCap);
      const bottomGeo = new THREE.SphereGeometry(
        sphereRadius,
        sphereSegments,
        sphereSegments,
        0,
        Math.PI * 2,
        Math.PI / 2,
        Math.PI / 2,
      );
      pacman.bottomLip = new THREE.Group();
      pacman.bottomLip.add(new THREE.Mesh(bottomGeo, mat));
      const bottomCap = new THREE.Mesh(capGeo, mouthInsideMat);
      bottomCap.rotation.x = -Math.PI / 2;
      pacman.bottomLip.add(bottomCap);

      // --- AJOUT : LANGUE ---
      // Forme de langue arrondie, rougeâtre, posée sur la lèvre inférieure
      const tongueGeo = new THREE.CircleGeometry(sphereRadius * 0.45, 16);
      const tongueMat = new THREE.MeshLambertMaterial({ color: 0x300000 }); // Rougeâtre
      const tongue = new THREE.Mesh(tongueGeo, tongueMat);

      // Orientation: À plat (-90° sur X comme le fond de la bouche)
      tongue.rotation.x = -Math.PI / 2;

      // Position:
      // Y = 0.1 (Légèrement au dessus du noir pour éviter le clignotement/z-fighting)
      // Z = 1.6 (Vers l'avant de la bouche pour être visible)
      tongue.position.set(0, 0.1, 1.2);

      // Forme un peu plus ovale
      tongue.scale.set(1.2, 1.1, 1);

      pacman.bottomLip.add(tongue);
      pacman.body.add(pacman.topLip);
      pacman.body.add(pacman.bottomLip);

      const eyeRadius = 0.55;
      const mouthAngle = 0.9;
      const eyeGeo = new THREE.CircleGeometry(
        eyeRadius,
        64,
        mouthAngle / 2,
        Math.PI * 2 - mouthAngle,
      );
      const pos = eyeGeo.attributes.position;
      const vec = new THREE.Vector3();
      const curvatureRadius = 3.65;
      const verticalScale = 1.8;
      for (let i = 0; i < pos.count; i++) {
        vec.fromBufferAttribute(pos, i);
        const effectiveX = vec.x;
        const effectiveY = vec.y * verticalScale;
        const distSq = effectiveX * effectiveX + effectiveY * effectiveY;
        if (distSq < curvatureRadius * curvatureRadius)
          vec.z =
            Math.sqrt(curvatureRadius * curvatureRadius - distSq) -
            curvatureRadius;
        pos.setXYZ(i, vec.x, vec.y, vec.z);
      }
      // Recalcul des normales pour que la lumière réagisse correctement à la nouvelle courbe
      eyeGeo.computeVertexNormals();

      const eyeMat = new THREE.MeshPhongMaterial({
        color: 0x000000,
        side: THREE.DoubleSide,
        specular: 0x333333,
        shininess: 20,
      });
      const eyeLeft = new THREE.Mesh(eyeGeo, eyeMat);
      const eyeRight = new THREE.Mesh(eyeGeo, eyeMat);
      eyeLeft.scale.set(1, verticalScale, 1);
      eyeRight.scale.set(1, verticalScale, 1);
      const vecLeft = new THREE.Vector3(1.0, 1.9, 2.4)
        .normalize()
        .multiplyScalar(3.65);
      const vecRight = new THREE.Vector3(-1.0, 1.9, 2.4)
        .normalize()
        .multiplyScalar(3.65);
      eyeLeft.position.copy(vecLeft);
      eyeRight.position.copy(vecRight);
      eyeLeft.lookAt(vecLeft.clone().multiplyScalar(2));
      eyeRight.lookAt(vecRight.clone().multiplyScalar(2));
      eyeLeft.rotation.z = Math.PI;
      eyeRight.rotation.z = 0;
      pacman.topLip.add(eyeLeft);
      pacman.topLip.add(eyeRight);

      // --- DEBUT MODIFICATIONS MS PACMAN ---

      // 1. CILS (Lashes) - MODIFIED
      pacman.lashes = [];
      const lashGeo = new THREE.BoxGeometry(0.12, 0.6, 0.05);
      const lashMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
      const addLashes = (eye, invertY) => {
        const g = new THREE.Group();
        const count = 5;
        for (let k = 0; k < count; k++) {
          const l = new THREE.Mesh(lashGeo, lashMat);
          const t = k / (count - 1);
          const angleStart = Math.PI / 1.2;
          const angleEnd = Math.PI / 2.8;
          const currentAngleMag = angleStart + (angleEnd - angleStart) * t;
          const angle = currentAngleMag * invertY;
          const r = 0.55;
          l.position.set(Math.cos(angle) * r, Math.sin(angle) * r, 0);
          l.rotation.z = angle - (Math.PI / 2) * invertY;
          g.add(l);
        }
        eye.add(g);
        return g;
      };
      pacman.lashes.push(addLashes(eyeLeft, -1));
      pacman.lashes.push(addLashes(eyeRight, 1));

      const bowGroup = new THREE.Group();
      const bowMat = new THREE.MeshPhongMaterial({
        color: 0xff0000,
        shininess: 80,
      });
      const bCenter = new THREE.Mesh(
        new THREE.SphereGeometry(0.9, 16, 16),
        bowMat,
      );
      const bLeft = new THREE.Mesh(
        new THREE.SphereGeometry(1.3, 16, 16),
        bowMat,
      );
      bLeft.position.set(-1.6, 0.4, 0);
      bLeft.scale.set(1, 0.8, 0.5);
      const bRight = new THREE.Mesh(
        new THREE.SphereGeometry(1.3, 16, 16),
        bowMat,
      );
      bRight.position.set(1.6, 0.4, 0);
      bRight.scale.set(1, 0.8, 0.5);
      bowGroup.add(bCenter, bLeft, bRight);
      bowGroup.position.set(0, 3.2, 0.8);
      bowGroup.rotation.x = -0.4;
      pacman.topLip.add(bowGroup);
      pacman.bow = bowGroup;

      // 3. GRAIN DE BEAUTÉ (Mole)
      const mole = new THREE.Mesh(
        new THREE.CircleGeometry(0.25, 12),
        new THREE.MeshBasicMaterial({ color: 0x000000 }),
      );
      // Sur la joue gauche (x < 0)
      const molePos = new THREE.Vector3(-2.2, 1.0, 2.4)
        .normalize()
        .multiplyScalar(3.55);
      mole.position.copy(molePos);
      mole.lookAt(molePos.clone().multiplyScalar(2));
      pacman.topLip.add(mole);
      pacman.mole = mole;
      updatePacmanAppearance();
      pacman.body.rotation.y = -Math.PI / 2;
      pacman.add(pacman.body);

      const mapOffsetX = levelMapOffsetX;
      const mapOffsetZ = levelMapOffsetZ;
      let startX = 10,
        startZ = 13;
      for (let z = 0; z < currentMap.length; z++) {
        for (let x = 0; x < currentMap[z].length; x++) {
          if (currentMap[z][x] === 7) {
            startX = x;
            startZ = z;
          }
        }
      }
      pacman.position.set(
        startX * TILE_SIZE - mapOffsetX,
        4,
        startZ * TILE_SIZE - mapOffsetZ,
      );
      pacman.gridPos = { x: startX, z: startZ };
      pacman.worldPosTarget = pacman.position.clone();

      // --- OMBRES PACMAN ---
      // Parcourir tous les enfants du groupe pour activer les ombres sur les Mesh
      pacman.traverse((child) => {
        if (child.isMesh) {
          child.castShadow = true;
          child.receiveShadow = true;
        }
      });

      scene.add(pacman);
    }

    function createGhosts() {
      const mapOffsetX = levelMapOffsetX;
      const mapOffsetZ = levelMapOffsetZ;

      // Trouver les positions de départ '8'
      const spawnPoints = [];
      for (let z = 0; z < currentMap.length; z++) {
        for (let x = 0; x < currentMap[z].length; x++) {
          if (currentMap[z][x] === 8) spawnPoints.push({ x, z });
        }
      }

      GHOST_DATA.forEach((data, index) => {
        const ghostGroup = new THREE.Group();

        // Postion depuis la map ou fallback défaut
        const spawn = spawnPoints[index % spawnPoints.length] || {
          x: 10,
          z: 10,
        };
        const bodyGeo = new THREE.CylinderGeometry(
          3,
          3,
          5,
          CONFIG.GRAPHICS.SEGMENTS,
          4,
        );
        const posAttribute = bodyGeo.attributes.position;
        const vertex = new THREE.Vector3();
        for (let i = 0; i < posAttribute.count; i++) {
          vertex.fromBufferAttribute(posAttribute, i);

          // Si on est tout en bas du cylindre
          if (vertex.y < -2.4) {
            const angle = Math.atan2(vertex.z, vertex.x);
            const wave = Math.sin(angle * 7);
            vertex.y += (wave + 1) * 0.4;
          }
          posAttribute.setXYZ(i, vertex.x, vertex.y, vertex.z);
        }
        // Recalculer les normales pour que la lumière réagisse bien aux ondulations
        bodyGeo.computeVertexNormals();

        const ghostMat = new THREE.MeshPhongMaterial({
          color: data.color,
          shininess: 60,
        });
        const body = new THREE.Mesh(bodyGeo, ghostMat);
        body.position.y = 2.5;
        const headGeo = new THREE.SphereGeometry(
          3.03,
          CONFIG.GRAPHICS.SEGMENTS,
          16,
          0,
          Math.PI * 2,
          0,
          Math.PI / 2,
        );
        const head = new THREE.Mesh(headGeo, ghostMat);
        head.position.y = 5;
        const eyeWhiteGeo = new THREE.SphereGeometry(1, 16, 16);
        const eyeWhiteMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
        const eyePupilGeo = new THREE.SphereGeometry(0.5, 16, 16);
        // MODIFICATION: MeshStandardMaterial pour supporter emissive (yeux luisants la nuit)
        const eyePupilMat = new THREE.MeshStandardMaterial({
          color: 0x000099,
          emissive: 0x0000ff, // Rouge quand émissif
          emissiveIntensity: 0 // Désactivé par défaut (jour)
        });
        const leftEye = new THREE.Group();
        const w1 = new THREE.Mesh(eyeWhiteGeo, eyeWhiteMat);
        const p1 = new THREE.Mesh(eyePupilGeo, eyePupilMat.clone()); // Clone pour pouvoir modifier individuellement
        p1.position.z = 0.7;
        leftEye.add(w1);
        leftEye.add(p1);
        leftEye.position.set(-1.2, 5, 2.2);
        const rightEye = new THREE.Group();
        const w2 = new THREE.Mesh(eyeWhiteGeo, eyeWhiteMat);
        ghostGroup.userData.eyes = [leftEye, rightEye];
        const p2 = new THREE.Mesh(eyePupilGeo, eyePupilMat.clone()); // Clone pour pouvoir modifier individuellement
        p2.position.z = 0.7;
        rightEye.add(w2);
        rightEye.add(p2);
        rightEye.position.set(1.2, 5, 2.2);

        // NOUVELLE LIGNE: Stocker les pupilles pour le cycle jour/nuit
        ghostGroup.userData.eyePupilMeshes = [p1, p2];
        ghostGroup.add(body);
        ghostGroup.add(head);
        ghostGroup.add(leftEye);
        ghostGroup.add(rightEye);
        ghostGroup.userData.eyes = [leftEye, rightEye];

        // --- MODIFICATION : AJOUT PAUPIERES (au lieu des sourcils) ---
        // Calotte sphérique un peu plus large que l'oeil, utilisant le même matériau que le fantôme
        const eyelidGeo = new THREE.SphereGeometry(
          1.05,
          16,
          16,
          0,
          Math.PI * 2,
          0,
          Math.PI / 3.2,
        );

        const leftEyelid = new THREE.Mesh(eyelidGeo, ghostMat);
        // On incline initialement vers l'arrière pour dégager l'oeil (rotation X négative)
        leftEyelid.rotation.x = -0.5;
        leftEye.add(leftEyelid);

        const rightEyelid = new THREE.Mesh(eyelidGeo, ghostMat);
        rightEyelid.rotation.x = -0.5;
        rightEye.add(rightEyelid);

        ghostGroup.userData.eyelids = {
          left: leftEyelid,
          right: rightEyelid,
        };

        ghostGroup.position.set(
          spawn.x * TILE_SIZE - mapOffsetX,
          0,
          spawn.z * TILE_SIZE - mapOffsetZ,
        );
        ghostGroup.gridPos = { x: spawn.x, z: spawn.z };
        ghostGroup.targetWorldPos = ghostGroup.position.clone();
        ghostGroup.currentDir = new THREE.Vector3(0, 0, 0);
        ghostGroup.traverse((child) => {
          if (child.isMesh) {
            child.castShadow = true;
            child.receiveShadow = true;
          }
        });
        ghostGroup.userData.originalColor = data.color;
        ghostGroup.userData.state = "IN_HOUSE";
        ghostGroup.userData.level = currentLevel;
        ghostGroup.userData.bodyMesh = body;
        ghostGroup.userData.headMesh = head;
        ghostGroup.userData.ghostMat = ghostMat;
        ghostGroup.add(rightEye);
        ghostGroup.userData.eyes = [leftEye, rightEye];
        ghostGroup.position.set(
          spawn.x * TILE_SIZE - mapOffsetX,
          0,
          spawn.z * TILE_SIZE - mapOffsetZ,
        );
        ghostGroup.gridPos = { x: spawn.x, z: spawn.z };
        ghostGroup.targetWorldPos = ghostGroup.position.clone();
        ghostGroup.currentDir = new THREE.Vector3(0, 0, 0);

        // --- OMBRES FANTÔMES ---
        // Appliquer l'ombre à tous les sous-éléments (corps, tête, yeux)
        ghostGroup.traverse((child) => {
          if (child.isMesh) {
            child.castShadow = true;
            child.receiveShadow = true;
          }
        });

        ghostGroup.userData.originalColor = data.color;
        ghostGroup.userData.state = "IN_HOUSE";
        ghostGroup.userData.level = currentLevel;
        ghostGroup.userData.bodyMesh = body;
        ghostGroup.userData.headMesh = head;
        ghostGroup.userData.ghostMat = ghostMat;
        scene.add(ghostGroup);
        ghosts.push(ghostGroup);
      });

      // Premier fantôme sort presque immédiatement
      ghostReleaseTimer = Date.now() + 1000;
    }

    // FONCTIONS DE DÉBOGAGE ET DESSIN MAP
    function drawDebugMap(mapData) {
      const canvas = document.getElementById("debug-canvas");
      const ctx = canvas.getContext("2d");
      const mapHeight = mapData.length;
      const mapWidth = mapData[0].length;
      const cellSize = Math.min(
        canvas.width / mapWidth,
        canvas.height / mapHeight,
      );
      const offsetX = (canvas.width - mapWidth * cellSize) / 2;
      const offsetY = (canvas.height - mapHeight * cellSize) / 2;
      ctx.fillStyle = "#000000";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      for (let y = 0; y < mapHeight; y++) {
        for (let x = 0; x < mapWidth; x++) {
          const type = mapData[y][x];
          const posX = offsetX + x * cellSize;
          const posY = offsetY + y * cellSize;
          switch (type) {
            case 1:
              ctx.fillStyle = "#0000FF";
              ctx.fillRect(posX, posY, cellSize, cellSize);
              ctx.strokeStyle = "#000099";
              ctx.strokeRect(posX, posY, cellSize, cellSize);
              break;
            case 0:
              ctx.fillStyle = "#000000";
              ctx.fillRect(posX, posY, cellSize, cellSize);
              break;
            case 2:
              ctx.fillStyle = "#000000";
              ctx.fillRect(posX, posY, cellSize, cellSize);
              ctx.fillStyle = "#FFFFFF";
              ctx.beginPath();
              ctx.arc(
                posX + cellSize / 2,
                posY + cellSize / 2,
                cellSize / 3,
                0,
                Math.PI * 2,
              );
              ctx.fill();
              break;
            case 6:
              ctx.fillStyle = "#FF00FF";
              ctx.globalAlpha = 0.5;
              ctx.fillRect(posX, posY, cellSize, cellSize);
              ctx.globalAlpha = 1.0;
              break;
            case 7:
              ctx.fillStyle = "#000000";
              ctx.fillRect(posX, posY, cellSize, cellSize);
              ctx.fillStyle = "#FFFF00";
              ctx.beginPath();
              ctx.arc(
                posX + cellSize / 2,
                posY + cellSize / 2,
                cellSize / 2.5,
                0,
                Math.PI * 2,
              );
              ctx.fill();
              break;
            case 8:
              ctx.fillStyle = "#000000";
              ctx.fillRect(posX, posY, cellSize, cellSize);
              ctx.fillStyle = "#FF0000";
              ctx.fillRect(
                posX + cellSize / 4,
                posY + cellSize / 4,
                cellSize / 2,
                cellSize / 2,
              );
              break;
            case 9:
              ctx.fillStyle = "#333333";
              ctx.fillRect(posX, posY, cellSize, cellSize);
              break;
          }
          if (isEditorMode) {
            ctx.strokeStyle = "#222";
            ctx.lineWidth = 0.5;
            ctx.strokeRect(posX, posY, cellSize, cellSize);
          }
        }
      }
    }

    function getMapDataForLevel(level) {
      const mapIdx = ((level - 1) % 16) + 1;
      return ALL_MAPS[mapIdx];
    }

    // --- UPDATE INITIALS UI ---
    function updateInitialsUI() {
      // Mise à jour des caractères
      for (let i = 0; i < 3; i++) {
        const el = document.getElementById("init-" + i);
        el.innerText = String.fromCharCode(initialsChars[i]);
        if (i === currentInitialIdx) el.classList.add("active");
        else el.classList.remove("active");
      }
    }

    function onKeyDown(event) {
      // --- GESTION SAISIE INITIALES ---
      if (gameState === STATE_INITIALS) {
        if (event.code === "ArrowUp") {
          initialsChars[currentInitialIdx]++;
          if (initialsChars[currentInitialIdx] > 90)
            initialsChars[currentInitialIdx] = 65; // Wrap Z -> A
          updateInitialsUI();
        } else if (event.code === "ArrowDown") {
          initialsChars[currentInitialIdx]--;
          if (initialsChars[currentInitialIdx] < 65)
            initialsChars[currentInitialIdx] = 90; // Wrap A -> Z
          updateInitialsUI();
        } else if (event.code === "ArrowLeft") {
          currentInitialIdx = (currentInitialIdx - 1 + 3) % 3;
          updateInitialsUI();
        } else if (event.code === "ArrowRight") {
          currentInitialIdx = (currentInitialIdx + 1) % 3;
          updateInitialsUI();
        } else if (event.code === "Enter" || event.code === "Space") {
          // Valider
          const finalName = String.fromCharCode(
            initialsChars[0],
            initialsChars[1],
            initialsChars[2],
          );

          // AJOUT: Sauvegarde avec le niveau actuel
          saveScore(finalName, score, currentLevel);

          // Aller à l'écran titre
          gameState = STATE_TITLE;
          stopMdxPlayback();
          titleScreenTimer = performance.now();
          document.getElementById("overlay").style.display = "flex";
          document.getElementById("highscore-screen").style.display = "none";
          document.getElementById("highscore-footer").style.display = "none";
          document.getElementById("initials-screen").style.display = "none";
          document.getElementById("info-screen").style.display = "none"; // Ensure hidden
          // S'assurer que le logo est visible
          document.getElementById("game-logo").style.display = "block";
          document.getElementById("overlay-msg").innerHTML =
            "PRESS SPACEBAR TO PLAY";
          document.getElementById("overlay-title").innerText = "";
        }
        return;
      }

      // --- GESTION DU MODE DEBUG (TOUCHE P) ---
      if (event.code === "KeyP") {
        isDebugMode = !isDebugMode;

        const overlay = document.getElementById("debug-overlay");

        if (isDebugMode) {
          isGameRunning = false;
          overlay.style.display = "flex";
          debugLevelIndex = currentLevel;
          document.getElementById("debug-level-num").innerText =
            debugLevelIndex;
          toggleBlur(true);
          currentDebugMapData = JSON.parse(
            JSON.stringify(getMapDataForLevel(debugLevelIndex)),
          );
          drawDebugMap(currentDebugMapData);
        } else {
          overlay.style.display = "none";
          if (isEditorMode) toggleEditorMode();
          toggleBlur(false);
          // On ne relance le mouvement QUE si on était déjà en cours de partie
          if (!isGameOver && !isDying && pacman && gameState === STATE_GAME)
            isGameRunning = true;
        }
        return;
      }
      if (event.code === "Semicolon") {
        isMsPacman = !isMsPacman;
        updatePacmanAppearance();
        return;
      }

      // GESTION RETOUR TITRE DEPUIS HIGH SCORE / INFO
      if (gameState === STATE_HIGHSCORE || gameState === STATE_INFO) {
        // Retour immédiat titre
        gameState = STATE_TITLE;
        titleScreenTimer = performance.now(); // Reset timer titre pour qu'il reste affiché un peu
        document.getElementById("highscore-screen").style.display = "none";
        document.getElementById("highscore-footer").style.display = "none";
        document.getElementById("info-screen").style.display = "none";
        document.getElementById("overlay").style.display = "flex";

        // Reset texte titre (au cas où il ait été changé par Game Over)
        document.getElementById("overlay-msg").innerHTML =
          "ESPACE POUR JOUER";
        document.getElementById("game-logo").style.display = "block"; // Réafficher le logo
        return;
      }

      if (isDebugMode && !isEditorMode) {
        if (event.code === "ArrowLeft") {
          debugLevelIndex--;
          if (debugLevelIndex < 1) debugLevelIndex = 16;
          document.getElementById("debug-level-num").innerText =
            debugLevelIndex;
          currentDebugMapData = JSON.parse(
            JSON.stringify(getMapDataForLevel(debugLevelIndex)),
          );
          drawDebugMap(currentDebugMapData);
        } else if (event.code === "ArrowRight") {
          debugLevelIndex++;
          if (debugLevelIndex > 16) debugLevelIndex = 1;
          document.getElementById("debug-level-num").innerText =
            debugLevelIndex;
          currentDebugMapData = JSON.parse(
            JSON.stringify(getMapDataForLevel(debugLevelIndex)),
          );
          drawDebugMap(currentDebugMapData);
        }
        return;
      }

      // --- DÉMARRAGE DU JEU ---
      // On ne peut démarrer QUE via Espace et si on n'est pas en mode debug
      if (!isGameRunning || isGameOver || gameState !== STATE_GAME) {
        if (event.code === "Space" && !isDebugMode) {
          startGame();
        }
        return;
      }
      if (
        ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", "Space"].indexOf(
          event.code,
        ) > -1
      )
        event.preventDefault();
      switch (event.code) {
        case "ArrowUp":
          nextDir.set(0, 0, -1);
          break;
        case "ArrowDown":
          nextDir.set(0, 0, 1);
          break;
        case "ArrowLeft":
          nextDir.set(-1, 0, 0);
          break;
        case "ArrowRight":
          nextDir.set(1, 0, 0);
          break;
        case "Space":
          if (!isJumping && !isBouncing && !isDying) {
            isJumping = true;
            jumpStartTime = Date.now();
            playSound("jump");
          }
          break;
        case "KeyV":
          viewMode = viewMode === 0 ? 1 : 0;
          updateViewIcon();
          onWindowResize();
          break;
      }
    }

    // Logic Helpers
    function updateEntityGridPos(entity) {
      entity.gridPos.x = Math.round(
        (entity.position.x + levelMapOffsetX) / TILE_SIZE,
      );
      entity.gridPos.z = Math.round(
        (entity.position.z + levelMapOffsetZ) / TILE_SIZE,
      );
    }

    function handleEntityTeleport(entity, dir) {
      const maxX = currentMap[0].length;
      let teleported = false;
      const gridX = entity.gridPos.x;
      const tile = getMapTile(gridX, entity.gridPos.z);

      if (tile === 6) {
        if (gridX <= 1 && dir.x < 0) {
          entity.position.x = (maxX - 2) * TILE_SIZE - levelMapOffsetX;
          entity.gridPos.x = maxX - 2;
          teleported = true;
        } else if (gridX >= maxX - 2 && dir.x > 0) {
          entity.position.x = 2 * TILE_SIZE - levelMapOffsetX;
          entity.gridPos.x = 2;
          teleported = true;
        }
      }

      if (!teleported) {
        if (gridX <= -1 && dir.x < 0) {
          entity.position.x = (maxX - 1) * TILE_SIZE - levelMapOffsetX;
          entity.gridPos.x = maxX - 1;
          teleported = true;
        } else if (gridX >= maxX && dir.x > 0) {
          entity.position.x = 0 * TILE_SIZE - levelMapOffsetX;
          entity.gridPos.x = 0;
          teleported = true;
        }
      }

      if (teleported) {
        if (entity.targetWorldPos) entity.targetWorldPos.x = entity.position.x;
        if (entity.worldPosTarget) entity.worldPosTarget.x = entity.position.x;
      }

      return teleported;
    }

    function getMapTile(x, z) {
      if (x < 0 || x >= currentMap[0].length) return 0;
      if (z < 0 || z >= currentMap.length) return 1;

      // Sécurité X (Hors map horizontal)
      const mapWidth = currentMap[0].length;
      if (x < 0) {
        // CORRECTION : On ne peut sortir à gauche QUE si la case d'entrée (0) est un TUNNEL (6)
        if (currentMap[z][0] === 6) return 0;
        return 1; // Sinon c'est un mur invisible
      }
      if (x >= mapWidth) {
        // Idem à droite
        if (currentMap[z][mapWidth - 1] === 6) return 0;
        return 1;
      }

      return currentMap[z][x];
    }

    function updatePacman(timeScale = 1) {
      const mapOffsetX = levelMapOffsetX;
      const mapOffsetZ = levelMapOffsetZ;
      const liveGridX = Math.round(
        (pacman.position.x + mapOffsetX) / TILE_SIZE,
      );
      const liveGridZ = Math.round(
        (pacman.position.z + mapOffsetZ) / TILE_SIZE,
      );
      const time = Date.now() * 0.015;
      const angle = Math.abs(Math.sin(time)) * 0.4;
      pacman.topLip.rotation.x = -angle;
      pacman.bottomLip.rotation.x = angle;
      let yOffset = 0;
      if (isJumping) {
        const elapsed = Date.now() - jumpStartTime;
        if (elapsed > JUMP_DURATION) {
          playSound("land");
          isJumping = false;
          isBouncing = true;
          bounceStartTime = Date.now();
        } else {
          const progress = elapsed / JUMP_DURATION;
          yOffset = Math.sin(progress * Math.PI) * JUMP_HEIGHT;
        }
      } else if (isBouncing) {
        const elapsed = Date.now() - bounceStartTime;
        if (elapsed > BOUNCE_DURATION) {
          isBouncing = false;
          yOffset = 0;
        } else {
          const progress = elapsed / BOUNCE_DURATION;
          yOffset = Math.sin(progress * Math.PI) * BOUNCE_HEIGHT;
        }
      }
      pacman.position.y = 4 + yOffset;

      // --- GESTION VITESSE ADAPTATIVE ---
      let currentSpeed = PACMAN_SPEED_NORMAL;
      if (Date.now() - eatingTimer < currentEatingDelay)
        currentSpeed = PACMAN_SPEED_EATING;

      const currentTile = getMapTile(liveGridX, liveGridZ);
      if (currentTile === 6) currentSpeed *= 0.6;
      if (currentDir.lengthSq() > 0 && nextDir.lengthSq() > 0) {
        if (nextDir.x === -currentDir.x && nextDir.z === -currentDir.z) {
          currentDir.copy(nextDir);
          lastMovingDir.copy(currentDir);
          pacman.worldPosTarget.x += currentDir.x * TILE_SIZE;
          pacman.worldPosTarget.z += currentDir.z * TILE_SIZE;
          const rotAngle = Math.atan2(currentDir.x, currentDir.z);
          pacman.body.rotation.y = rotAngle;
          nextDir.set(0, 0, 0);
        }
      }

      const moveStep = currentSpeed * timeScale;

      const distSq =
        Math.pow(pacman.position.x - pacman.worldPosTarget.x, 2) +
        Math.pow(pacman.position.z - pacman.worldPosTarget.z, 2);

      if (distSq < moveStep * moveStep) {
        pacman.position.x = pacman.worldPosTarget.x;
        pacman.position.z = pacman.worldPosTarget.z;
        updateEntityGridPos(pacman);
        handleEntityTeleport(pacman, currentDir);
        updateEntityGridPos(pacman);
        if (nextDir.lengthSq() > 0) {
          const nextTileType = getMapTile(
            pacman.gridPos.x + nextDir.x,
            pacman.gridPos.z + nextDir.z,
          );
          if (nextTileType !== 1 && nextTileType !== 8) {
            currentDir.copy(nextDir);
            lastMovingDir.copy(currentDir);
            const rotAngle = Math.atan2(currentDir.x, currentDir.z);
            pacman.body.rotation.y = rotAngle;
          }
        }
        if (currentDir.lengthSq() > 0) {
          const currentDirTileType = getMapTile(
            pacman.gridPos.x + currentDir.x,
            pacman.gridPos.z + currentDir.z,
          );
          if (currentDirTileType !== 1 && currentDirTileType !== 8) {
            pacman.worldPosTarget.x =
              pacman.position.x + currentDir.x * TILE_SIZE;
            pacman.worldPosTarget.z =
              pacman.position.z + currentDir.z * TILE_SIZE;
            const rotAngle = Math.atan2(currentDir.x, currentDir.z);
            pacman.body.rotation.y = rotAngle;
          } else {
            currentDir.set(0, 0, 0);
            pacman.worldPosTarget.copy(pacman.position);
          }
        }
      } else {
        const dir = new THREE.Vector3(
          pacman.worldPosTarget.x - pacman.position.x,
          0,
          pacman.worldPosTarget.z - pacman.position.z,
        ).normalize();
        pacman.position.x += dir.x * moveStep;
        pacman.position.z += dir.z * moveStep;
      }

      if (pacman.position.y < 5) {
        for (let i = 0; i < pellets.length; i++) {
          if (pellets[i].userData.active) {
            const dx = pacman.position.x - pellets[i].position.x;
            const dz = pacman.position.z - pellets[i].position.z;
            if (Math.sqrt(dx * dx + dz * dz) < 2) {
              pellets[i].userData.active = false;
              pellets[i].visible = false;
              pelletsEatenCount++;

              // --- LOGIQUE MANGER + VITESSE ---
              if (pellets[i].userData.isPower) {
                score += 50;
                playSound("powerPelletObtain");
                activatePowerMode();
                playPowerPelletMusic();
              } else {
                score += 10;
                playSound("munch");
              }

              // Vérifier la case SUIVANTE pour adapter la vitesse
              let hasNextPellet = false;
              if (currentDir.lengthSq() > 0) {
                // CORRECTION : On se base sur la gomme MANGÉE (pellets[i]) et non la position floue de Pacman
                const nx = Math.round(
                  pellets[i].userData.gridX + currentDir.x,
                );
                const nz = Math.round(
                  pellets[i].userData.gridZ + currentDir.z,
                );

                // On regarde si la case cible est un chemin (0) ou Power (2) ET contient une gomme active
                const type = getMapTile(nx, nz);
                if (type === 0 || type === 2) {
                  for (let k = 0; k < pellets.length; k++) {
                    if (
                      pellets[k].userData.active &&
                      pellets[k].userData.gridX === nx &&
                      pellets[k].userData.gridZ === nz
                    ) {
                      hasNextPellet = true;
                      break;
                    }
                  }
                }
              }

              // SI une gomme suit -> On reste lent (750ms de délai)
              // SINON (fin de chaîne) -> On accélère (90ms de délai)
              currentEatingDelay = hasNextPellet
                ? CONFIG.SPEEDS.EATING_DELAY_LONG
                : CONFIG.SPEEDS.EATING_DELAY_SHORT;
              eatingTimer = Date.now();

              if (score >= nextLifeThreshold) {
                lives++;
                nextLifeThreshold += CONFIG.GAME.NEXT_LIFE_THRESHOLD_STEP;
                document.getElementById("lives").innerText = lives;
                createFloatingScore("1UP", pacman.position);
                // AJOUT : Jouer le son
                playSound("extraLife");
              }
              document.getElementById("score").innerText = score;
              if (pelletsEatenCount >= totalPellets) gameWin();
            }
          }
        }
      }
    }

    // BFS Pathfinding générique (utilisé pour DEAD et LEAVING_HOUSE)
    function findPath(startX, startZ, targetX, targetZ) {
      if (Math.round(startX) === targetX && Math.round(startZ) === targetZ)
        return null;

      const startNode = {
        x: Math.round(startX),
        z: Math.round(startZ),
        path: [],
      };
      const queue = [startNode];
      const visited = new Set();
      visited.add(`${startNode.x},${startNode.z}`);
      let iterations = 0;
      while (queue.length > 0 && iterations < 1000) {
        iterations++;
        const current = queue.shift();
        if (current.x === targetX && current.z === targetZ)
          return current.path[0];
        const dirs = [
          { x: 0, z: -1 },
          { x: 0, z: 1 },
          { x: -1, z: 0 },
          { x: 1, z: 0 },
        ];
        for (let d of dirs) {
          let nx = current.x + d.x;
          const nz = current.z + d.z;
          // Utiliser le nouveau getMapTile sécurisé
          const key = `${nx},${nz}`;
          // getMapTile renvoie 1 (Mur) si hors map non-tunnel, donc pathfinding safe
          if (getMapTile(nx, nz) !== 1 && !visited.has(key)) {
            visited.add(key);
            queue.push({ x: nx, z: nz, path: [...current.path, d] });
          }
        }
      }
      return null;
    }

    function createFloatingScore(points, worldPos) {
      const div = document.createElement("div");
      div.className = "floating-score";
      div.innerText = points;
      document.body.appendChild(div);
      activeFloatingScores.push({
        div: div,
        worldPos: worldPos.clone().add(new THREE.Vector3(0, 5, 0)),
        startTime: Date.now(),
      });
    }

    function updateFloatingScores(timeScale = 1) {
      const now = Date.now();
      for (let i = activeFloatingScores.length - 1; i >= 0; i--) {
        const s = activeFloatingScores[i];
        const age = now - s.startTime;
        if (age > 1000) {
          if (s.div.parentNode) s.div.parentNode.removeChild(s.div);
          activeFloatingScores.splice(i, 1);
          continue;
        }
        s.worldPos.y += 0.05 * timeScale;

        // Projection
        const screenPos = s.worldPos.clone().project(camera);
        const x = (screenPos.x * 0.5 + 0.5) * window.innerWidth;
        const y = (-(screenPos.y * 0.5) + 0.5) * window.innerHeight;
        s.div.style.left = x + "px";
        s.div.style.top = y + "px";
        s.div.style.opacity = 1 - age / 1000;
      }
    }

    function activatePowerMode() {
      powerModeEndTime = Date.now() + POWER_PELLET_DURATION;
      ghostsEatenCount = 0;
      ghosts.forEach((g) => {
        if (g.userData.state !== "DEAD") {
          g.userData.state = "SCARED";
          g.userData.ghostMat.color.setHex(0x0000ff);
          g.userData.ghostMat.transparent = false;
          g.currentDir.negate();
          g.targetWorldPos.add(g.currentDir.multiplyScalar(TILE_SIZE));
        }
      });
    }

    function restoreGhost(ghost) {
      ghost.userData.state = "NORMAL";
      ghost.userData.ghostMat.color.setHex(ghost.userData.originalColor);
      ghost.userData.ghostMat.transparent = false;
      ghost.userData.ghostMat.opacity = 1.0;
      ghost.userData.bodyMesh.visible = true;
      ghost.userData.headMesh.visible = true;
      updateEntityGridPos(ghost);
      ghost.position.x = ghost.gridPos.x * TILE_SIZE - levelMapOffsetX;
      ghost.position.z = ghost.gridPos.z * TILE_SIZE - levelMapOffsetZ;
      ghost.targetWorldPos.copy(ghost.position);
      ghost.currentDir.set(0, 0, 0);
    }

    function reverseGhost(g) {
      if (g.userData.state === "DEAD") return;

      // CORRECTION ANTI-MUR : Vérifier si le recul ne nous met pas dans un mur
      // (Arrive si on vient de tourner à un coin)
      const potentialTarget = g.targetWorldPos
        .clone()
        .add(g.currentDir.clone().negate().multiplyScalar(TILE_SIZE));
      const gridX = Math.round((potentialTarget.x + levelMapOffsetX) / TILE_SIZE);
      const gridZ = Math.round((potentialTarget.z + levelMapOffsetZ) / TILE_SIZE);

      if (getMapTile(gridX, gridZ) === 1) {
        // Bloqué derrière ? On annule le demi-tour (On ignore la collision pour cette frame)
        return;
      }

      g.currentDir.negate();
      g.targetWorldPos.copy(potentialTarget);
    }

    function updateGhosts(timeScale = 1) {

      const now = Date.now();
      for (let i = 0; i < ghosts.length; i++) {
        for (let j = i + 1; j < ghosts.length; j++) {
          const g1 = ghosts[i];
          const g2 = ghosts[j];
          if (g1.userData.state === "DEAD" || g2.userData.state === "DEAD")
            continue;
          const dist = g1.position.distanceTo(g2.position);
          if (dist < 8) {
            // Distance un peu augmentée
            const cd1 = g1.userData.lastCollisionTime || 0;
            const cd2 = g2.userData.lastCollisionTime || 0;
            if (now - cd1 > 500 && now - cd2 > 500) {
              reverseGhost(g1);
              reverseGhost(g2);
              g1.userData.lastCollisionTime = now;
              g2.userData.lastCollisionTime = now;
              // --- BUMP ANIMATION ---
              g1.userData.isBumping = true;
              g1.userData.bumpStartTime = now;
              g2.userData.isBumping = true;
              g2.userData.bumpStartTime = now;
            }
          }
        }
      }

      // --- GESTION SORTIE MAISON ---
      if (Date.now() > ghostReleaseTimer) {
        const waitingGhost = ghosts.find(
          (g) => g.userData.state === "IN_HOUSE",
        );
        if (waitingGhost) {
          waitingGhost.userData.state = "LEAVING_HOUSE";
          ghostReleaseTimer = Date.now() + 1500;
        } // Délai réduit un peu
      }
      if (powerModeEndTime > 0 && now > powerModeEndTime) {
        stopPowerPelletMusic();
        powerModeEndTime = 0;
        ghostsEatenCount = 0;
        ghosts.forEach((g) => {
          if (g.userData.state === "SCARED") restoreGhost(g);
        });
      }

      ghosts.forEach((ghost) => {
        // --- ANIMATION VERTICALE ---
        // 1. Priorité au Bump (Rebond)
        if (ghost.userData.isBumping) {
          const bumpDuration = 400; // REDUIT de 2000 à 400ms pour un saut vif
          const elapsed = Date.now() - ghost.userData.bumpStartTime;
          if (elapsed < bumpDuration) {
            const progress = elapsed / bumpDuration;
            ghost.position.y = Math.sin(progress * Math.PI) * 4; // Hauteur 4
          } else {
            ghost.userData.isBumping = false;
            ghost.position.y = 0;
          }
        }
        // 2. Animation Maison (Gros Bobbing)
        else if (ghost.userData.state === "IN_HOUSE") {
          ghost.position.y = Math.abs(Math.sin(Date.now() / 300)) * 2;
          // On sort ici pour ne pas exécuter le mouvement X/Z
          updateEntityGridPos(ghost);
          return;
        }
        // 3. Animation de Flottement Standard (Pour fluidité)
        else {
          // Petit flottement constant pour ne pas qu'ils glissent au sol
          ghost.position.y = Math.sin(Date.now() / 200) * 0.5;
        }

        // Clignotement fin de Power Mode (< 20% temps restant)
        if (ghost.userData.state === "SCARED" && powerModeEndTime > 0) {
          const remaining = powerModeEndTime - Date.now();

          if (remaining < POWER_PELLET_DURATION * 0.1) {
            // ULTRA RAPIDE (< 10%) : Alerte finale
            if (Math.floor(Date.now() / 50) % 2 === 0)
              ghost.userData.ghostMat.color.setHex(
                ghost.userData.originalColor,
              );
            else ghost.userData.ghostMat.color.setHex(0x0000ff);
          } else if (remaining < POWER_PELLET_DURATION * 0.2) {
            // RAPIDE (< 20%)
            if (Math.floor(Date.now() / 100) % 2 === 0)
              ghost.userData.ghostMat.color.setHex(
                ghost.userData.originalColor,
              );
            else ghost.userData.ghostMat.color.setHex(0x0000ff);
          } else {
            // Normal (Bleu)
            ghost.userData.ghostMat.color.setHex(0x0000ff);
          }
        }

        // Vitesse Sortie Maison augmentée
        let activeSpeed = GHOST_SPEED;
        if (ghost.userData.state === "SCARED")
          activeSpeed = GHOST_SPEED_SCARED;
        if (ghost.userData.state === "DEAD") activeSpeed = GHOST_SPEED_DEAD;
        if (ghost.userData.state === "LEAVING_HOUSE")
          activeSpeed = GHOST_SPEED * 0.8; // Plus rapide (0.8 au lieu de 0.5)

        const currentTile = getMapTile(
          Math.round(ghost.gridPos.x),
          Math.round(ghost.gridPos.z),
        );
        if (currentTile === 6) activeSpeed *= 0.3;

        // --- NOUVEAU: RALENTISSEMENT VIRAGE (CORNERING) ---
        // Si le fantôme vient de tourner (timer actif), on réduit sa vitesse
        if (
          ghost.userData.corneringStart &&
          Date.now() - ghost.userData.corneringStart < 500
        ) {
          activeSpeed *= 0.75; // 25% de réduction de vitesse dans les virages
        }

        const moveStep = activeSpeed * timeScale;

        // --- COMPORTEMENT "DEAD" (Yeux rentrent à la maison par les couloirs) ---
        const distSq =
          Math.pow(ghost.position.x - ghost.targetWorldPos.x, 2) +
          Math.pow(ghost.position.z - ghost.targetWorldPos.z, 2);

        if (distSq < moveStep * moveStep) {
          ghost.position.x = ghost.targetWorldPos.x;
          ghost.position.z = ghost.targetWorldPos.z;
          updateEntityGridPos(ghost);
          handleEntityTeleport(ghost, ghost.currentDir);

          // --- SÉCURITÉ ANTI-GLITCH MUR ---
          // Si on est "arrivé" sur une case MUR (bug), on cherche la case libre la plus proche
          if (getMapTile(ghost.gridPos.x, ghost.gridPos.z) === 1) {
            const neighbors = [
              { x: 0, z: 1 },
              { x: 0, z: -1 },
              { x: 1, z: 0 },
              { x: -1, z: 0 },
            ];
            for (let n of neighbors) {
              if (
                getMapTile(ghost.gridPos.x + n.x, ghost.gridPos.z + n.z) !== 1
              ) {
                // Téléportation de secours
                ghost.gridPos.x += n.x;
                ghost.gridPos.z += n.z;
                ghost.position.x = ghost.gridPos.x * TILE_SIZE - levelMapOffsetX;
                ghost.position.z = ghost.gridPos.z * TILE_SIZE - levelMapOffsetZ;
                ghost.targetWorldPos.copy(ghost.position);
                break;
              }
            }
          }

          if (ghost.userData.state === "DEAD" && currentTile === 8) {
            restoreGhost(ghost);
            ghost.userData.state = "LEAVING_HOUSE";
            return;
          }
          let nextDir = null;

          if (ghost.userData.state === "DEAD") {
            // Pathfinding vers la maison (utilise la variable globale houseEntrance)
            nextDir = findPath(
              ghost.gridPos.x,
              ghost.gridPos.z,
              houseEntrance.x,
              houseEntrance.z,
            );
            if (!nextDir) {
              const dirs = [
                { x: 1, z: 0 },
                { x: -1, z: 0 },
                { x: 0, z: 1 },
                { x: 0, z: -1 },
              ];
              const validDirs = dirs.filter(
                (d) =>
                  getMapTile(ghost.gridPos.x + d.x, ghost.gridPos.z + d.z) !==
                  1,
              );
              if (validDirs.length > 0) nextDir = validDirs[0];
            }
          } else if (ghost.userData.state === "LEAVING_HOUSE") {
            const targetExitX = houseEntrance.x;
            const targetExitZ = houseEntrance.z;
            nextDir = findPath(
              ghost.gridPos.x,
              ghost.gridPos.z,
              targetExitX,
              targetExitZ,
            );
            if (
              (Math.round(ghost.gridPos.x) === targetExitX &&
                Math.round(ghost.gridPos.z) === targetExitZ) ||
              !nextDir
            )
              ghost.userData.state = "NORMAL";
          } else {
            const possibleDirs = [];
            const dirs = [
              { x: 1, z: 0 },
              { x: -1, z: 0 },
              { x: 0, z: 1 },
              { x: 0, z: -1 },
            ];
            dirs.forEach((d) => {
              if (
                getMapTile(ghost.gridPos.x + d.x, ghost.gridPos.z + d.z) !== 1
              ) {
                if (
                  !(
                    d.x === -ghost.currentDir.x &&
                    d.z === -ghost.currentDir.z &&
                    ghost.currentDir.lengthSq() > 0
                  )
                )
                  possibleDirs.push(d);
              }
            });
            if (possibleDirs.length === 0)
              dirs.forEach((d) => {
                if (
                  getMapTile(ghost.gridPos.x + d.x, ghost.gridPos.z + d.z) !==
                  1
                )
                  possibleDirs.push(d);
              });
            if (possibleDirs.length > 0) {
              nextDir =
                possibleDirs[Math.floor(Math.random() * possibleDirs.length)];
              let ghostIntelligenceLevel = 0.4 + ghost.userData.level * 0.02;
              ghostIntelligenceLevel =
                ghostIntelligenceLevel > 1 ? 1 : ghostIntelligenceLevel;
              if (
                ghost.userData.state === "NORMAL" &&
                Math.random() < ghostIntelligenceLevel
              ) {
                let bestDist = Infinity;
                const mapWidth = currentMap[0].length;
                possibleDirs.forEach((d) => {
                  const nextX = ghost.gridPos.x + d.x;
                  const nextZ = ghost.gridPos.z + d.z;
                  let dx = Math.abs(nextX - pacman.gridPos.x);
                  if (dx > mapWidth / 2) dx = mapWidth - dx;
                  const dz = nextZ - pacman.gridPos.z;
                  const dist = Math.sqrt(dx * dx + dz * dz);
                  if (dist < bestDist) {
                    bestDist = dist;
                    nextDir = d;
                  }
                });
              }
              // En mode SCARED : fuir Pacman
              if (ghost.userData.state === "SCARED" && Math.random() < 0.6) {
                let maxDist = -1;
                const mapWidth = currentMap[0].length;
                possibleDirs.forEach((d) => {
                  const nextX = ghost.gridPos.x + d.x;
                  const nextZ = ghost.gridPos.z + d.z;
                  let dx = Math.abs(nextX - pacman.gridPos.x);
                  if (dx > mapWidth / 2) dx = mapWidth - dx;
                  const dz = nextZ - pacman.gridPos.z;
                  const dist = Math.sqrt(dx * dx + dz * dz);
                  if (dist > maxDist) {
                    maxDist = dist;
                    nextDir = d;
                  }
                });
              }
            }
          }

          if (nextDir) {
            // --- DÉTECTION VIRAGE ---
            // Si le fantôme change de direction (angle de 90°), on active le ralentissement
            if (ghost.currentDir.lengthSq() > 0) {
              // Produit scalaire pour voir si c'est perpendiculaire (virage)
              const dot =
                ghost.currentDir.x * nextDir.x +
                ghost.currentDir.z * nextDir.z;
              // Si ~0, c'est un virage à 90°. (Si c'est -1 c'est demi-tour, si 1 c'est tout droit)
              if (Math.abs(dot) < 0.1) {
                ghost.userData.corneringStart = Date.now();
              }
            }

            ghost.currentDir.set(nextDir.x, 0, nextDir.z);
            ghost.targetWorldPos.x =
              (ghost.gridPos.x + nextDir.x) * TILE_SIZE - levelMapOffsetX;
            ghost.targetWorldPos.z =
              (ghost.gridPos.z + nextDir.z) * TILE_SIZE - levelMapOffsetZ;
            const rotAngle = Math.atan2(
              ghost.currentDir.x,
              ghost.currentDir.z,
            );
            ghost.rotation.y = rotAngle;
          }
        } else {
          const dx = ghost.targetWorldPos.x - ghost.position.x;
          const dz = ghost.targetWorldPos.z - ghost.position.z;
          // OPTIMIZATION: Use temp vector
          _tempVec.set(dx, 0, dz).normalize();
          if (Math.abs(dx) > 0.01 || Math.abs(dz) > 0.01) {
            const targetRot = Math.atan2(_tempVec.x, _tempVec.z);
            ghost.rotation.y = targetRot;
          }
          ghost.position.x += _tempVec.x * moveStep;
          ghost.position.z += _tempVec.z * moveStep;
        }
        const distToPacman = Math.sqrt(
          Math.pow(ghost.position.x - pacman.position.x, 2) +
          Math.pow(ghost.position.z - pacman.position.z, 2),
        );
        const isSafe = isJumping && pacman.position.y > 6;

        if (distToPacman < 4 && !isSafe) {
          if (
            ghost.userData.state === "NORMAL" ||
            ghost.userData.state === "LEAVING_HOUSE"
          )
            gameOver();
          else if (ghost.userData.state === "SCARED") {
            ghost.userData.state = "DEAD";
            ghost.userData.bodyMesh.visible = false;
            ghost.userData.headMesh.visible = false;
            playSound("ghostEaten");
            ghostsEatenCount++;
            const points = 150 + (ghostsEatenCount - 1) * 75;
            score += points;
            createFloatingScore(points, ghost.position);
            document.getElementById("score").innerText = score;
          }
        }

        // --- GESTION DES YEUX (Regard vers le haut quand Pacman saute par dessus) ---
        if (ghost.userData.eyes && ghost.userData.state !== "DEAD") {
          let targetRotX = 0;
          let targetRotY = 0;
          if (isJumping && distToPacman < 12) targetRotX = -Math.PI / 4.5;
          if (distToPacman < 30) {
            const dx = pacman.position.x - ghost.position.x;
            const dz = pacman.position.z - ghost.position.z;
            const angleToPacman = Math.atan2(dx, dz);
            let angleDiff = angleToPacman - ghost.rotation.y;
            while (angleDiff <= -Math.PI) angleDiff += Math.PI * 2;
            while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
            const maxEyeRot = Math.PI / 4.5;
            targetRotY = Math.max(-maxEyeRot, Math.min(maxEyeRot, angleDiff));
          }
          ghost.userData.eyes.forEach((eye) => {
            eye.rotation.x += (targetRotX - eye.rotation.x) * 0.15;
            eye.rotation.y += (targetRotY - eye.rotation.y) * 0.15;
          });
        }
        // --- GESTION DES EXPRESSIONS (PAUPIERES) ---
        if (ghost.userData.eyelids && ghost.userData.state !== "DEAD") {
          let targetZ = 0;
          // Inclinaison (Colère/Tristesse)
          let targetX = -0.5;
          // Ouverture (-0.5 = ouvert, 0 = plissé)

          if (distToPacman < 30) {
            // Proche
            if (ghost.userData.state === "SCARED") {
              // PEUR : Yeux "tristes" / \ et grands ouverts
              targetZ = 0.5;
              targetX = -0.6;
              // Très ouverts
            } else {
              // AGRESSIF : Yeux "froncés" \ / et plissés
              targetZ = -0.5;
              targetX = 0.1;
              // Un peu fermés/plissés
            }
          }

          const left = ghost.userData.eyelids.left;
          const right = ghost.userData.eyelids.right;

          // Oeil Gauche
          left.rotation.z += (targetZ - left.rotation.z) * 0.1;
          left.rotation.x += (targetX - left.rotation.x) * 0.1;

          // Oeil Droit (Symétrie Z)
          right.rotation.z += (-targetZ - right.rotation.z) * 0.1;
          right.rotation.x += (targetX - right.rotation.x) * 0.1;
        }
      });
    }

    function updateCamera(timeScale = 1) {
      let targetOffsetVec;
      const targetColor = _tempColor; // OPTIMIZATION: Reuse temp color

      // Le centre de la vue reste Pacman (légèrement surélevé)
      const centerPos = _tempVec.copy(pacman.position);
      centerPos.y = 4;

      // Cible du LookAt (toujours Pacman)
      const targetLookAt = _tempVec2.copy(centerPos);

      if (viewMode === 0) {
        // MODE 0: ISO (Vue de loin)
        targetColor.setHex(CONFIG.COLORS.BG_ISO);
        // Offset diagonal "Vue de dessus/coin"
        targetOffsetVec = _tempVec3.set(
          viewMode_0_DEFAULT_OFFSET,
          viewMode_0_DEFAULT_OFFSET,
          viewMode_0_DEFAULT_OFFSET,
        );
      } else {
        // MODE 1: PACMANIA (Vue arrière/haute)
        targetColor.setHex(CONFIG.COLORS.BG_ISO);
        const pOffset = CONFIG.CAMERA.PACMANIA_OFFSET;
        // Offset plus rasant (Z dominant)
        targetOffsetVec = _tempVec3.set(0, pOffset * 3, pOffset * 2);
      }

      // --- 1. GESTION COULEUR FOND ---
      scene.background.lerp(targetColor, 0.05 * timeScale);

      // --- 2. INTERPOLATION SPHÉRIQUE (Trajectoire en arc) ---

      // Vecteur actuel relatif (Caméra -> Pacman)
      const currentOffset = _tempVec4.copy(camera.position).sub(centerPos);

      // Conversion en coordonnées sphériques (Rayon, Phi, Theta)
      camSpherical.setFromVector3(currentOffset);
      targetSpherical.setFromVector3(targetOffsetVec);

      // Facteur de lissage
      const lerpFactor = 0.08 * timeScale;

      // Interpolation des composantes sphériques
      // Rayon (Distance)
      camSpherical.radius +=
        (targetSpherical.radius - camSpherical.radius) * lerpFactor;

      // Phi (Angle Vertical : 0 = Pôle Nord, PI = Pôle Sud)
      camSpherical.phi +=
        (targetSpherical.phi - camSpherical.phi) * lerpFactor;

      // Theta (Angle Horizontal : rotation autour de Y)
      // Gestion du passage 360° (Wrapping) pour prendre le chemin le plus court
      let dTheta = targetSpherical.theta - camSpherical.theta;
      if (dTheta > Math.PI) dTheta -= Math.PI * 2;
      if (dTheta < -Math.PI) dTheta += Math.PI * 2;
      camSpherical.theta += dTheta * lerpFactor;

      // Reconversion Sphérique -> Cartésien
      const newOffset = _tempVec5.setFromSpherical(camSpherical);

      // Application de la nouvelle position
      camera.position.copy(centerPos).add(newOffset);

      // --- 3. ORIENTATION ---
      // Lissage du point regardé
      currentLookAt.lerp(targetLookAt, 0.1 * timeScale);
      camera.lookAt(currentLookAt);

      // --- 4. AJOUT CORRECTIF OMBRES ---
      // La lumière suit Pacman pour que les ombres ne soient jamais coupées
      if (pacman && dirLight) {
        // OPTIMIZATION: Reuse static vector
        dirLight.position.copy(pacman.position).add(_tempLightOffset);
        dirLight.target.position.copy(pacman.position);
      }
    }

    // --- DAY/NIGHT CYCLE UPDATE ---
    function updateDayNightCycle(timeScale = 1) {
      if (!isGameRunning || isGameOver) return;

      const elapsed = Date.now() - dayNightStartTime;
      // Cycle sinusoïdal: 0 (jour) -> 1 (nuit) -> 0 (jour)
      dayNightCycle = (Math.sin((elapsed / DAY_NIGHT_DURATION) * Math.PI * 2 - Math.PI / 2) + 1) / 2;

      // Seuil pour considérer qu'il fait nuit (> 0.5)
      const wasNight = isNight;
      isNight = dayNightCycle > 0.5;

      // --- MISE À JOUR DES INTENSITÉS LUMINEUSES ---
      const dayAmbient = 1;
      const nightAmbient = 0.04;
      const dayDirectional = 0.9;
      const nightDirectional = 0.06;

      const ambientIntensity = THREE.MathUtils.lerp(dayAmbient, nightAmbient, dayNightCycle);
      const directionalIntensity = THREE.MathUtils.lerp(dayDirectional, nightDirectional, dayNightCycle);

      ambientLight.intensity = ambientIntensity;
      dirLight.intensity = directionalIntensity;

      // Adapt PAcman specular light according to day/light cycle
      if (pacman && pacman.userData && pacman.userData.bodyMaterial) {
        const mat = pacman.userData.bodyMaterial

        // Couleurs cibles (définies ici pour clarté, à sortir pour optimiser)
        const dayColor = new THREE.Color(0xffffff);  // Reflet blanc éclatant
        const nightColor = new THREE.Color(0x444444); // Reflet quasi inexistant

        // On copie la couleur de jour, et on "lerp" (interpole) vers la nuit
        mat.specular.copy(dayColor).lerp(nightColor, dayNightCycle);
      }

      // --- PAC-MAN FLASHLIGHT ---
      if (pacman && pacmanLight) {
        // La lampe s'active progressivement la nuit
        const flashlightIntensity = isNight ? Math.max(0, (dayNightCycle - 0.5) * 4) : 0;
        pacmanLight.intensity = flashlightIntensity;

        // Positionner la lampe sur Pac-Man
        pacmanLight.position.copy(pacman.position);
        pacmanLight.position.y += 6; // Un peu au-dessus

        // Orienter la lampe dans la direction de déplacement
        if (lastMovingDir.lengthSq() > 0) {
          _tempVec.copy(pacman.position).add(lastMovingDir.clone().multiplyScalar(TILE_SIZE * 2));
          _tempVec.y = 0;
          pacmanLight.target.position.copy(_tempVec);
        } else {
          // Par défaut, pointer vers l'avant
          _tempVec.copy(pacman.position);
          _tempVec.z -= TILE_SIZE * 2;
          _tempVec.y = 0;
          pacmanLight.target.position.copy(_tempVec);
        }
      }

      // --- YEUX LUISANTS DES FANTÔMES LA NUIT ---
      ghosts.forEach((ghost) => {
        if (ghost.userData.eyePupilMeshes && ghost.userData.state !== "DEAD") {
          ghost.userData.eyePupilMeshes.forEach((pupil) => {
            if (isNight) {
              // La nuit: yeux luisants avec emissive
              const glowIntensity = 0.3 + Math.sin(Date.now() / 300) * 0.1; // Pulsation
              pupil.material.emissive.setHex(0x0000ff);
              pupil.material.emissiveIntensity = glowIntensity;
            } else {
              // Le jour: pas de lueur
              pupil.material.emissiveIntensity = 0;
            }
          });
        }
      });
    }

    function gameOver() {
      if (isDying || isGameOver) return;
      isDying = true;

      // --- CHANGEMENT : Arrêt musique dynamique ---
      stopLevelMusic();
      stopPowerPelletMusic();
      deathDuration = playSound("lifeLoss") * 1000 + 500;
      deathStartTime = Date.now();
      if (lives === 0) {
        isGameRunning = false;
        playGameOver();
      }
    }

    // NOUVEAU : Fonction de Victoire avec transition auto
    function gameWin() {
      if (isTransitioning || isGameOver) return;
      isTransitioning = true;
      isGameRunning = false;

      // --- CHANGEMENT : Arrêt musique dynamique ---
      stopLevelMusic();
      stopPowerPelletMusic();
      playSound("applause");
      toggleBlur(true);
      const logo = document.getElementById("game-logo");
      if (logo) logo.style.display = "none";
      const title = document.getElementById("overlay-title");
      title.style.display = "block";
      title.innerText = "CONGRATULATIONS!";
      title.style.color = "#44FF44";
      const msg = document.getElementById("overlay-msg");
      msg.innerHTML = "LEVEL COMPLETED<br>SCORE: " + score;
      msg.classList.remove("blinking");
      msg.style.color = "#FFFFFF";
      document.getElementById("overlay").style.display = "flex";

      // Démarrer la Séquence de feux d'artifice

      // Premier feu immédiat au centre
      createFirework(window.innerWidth / 2, window.innerHeight / 2);
      let count = 0;
      const maxFireworks = 12;
      fireworkInterval = setInterval(() => {
        const x =
          Math.random() * window.innerWidth * 0.8 + window.innerWidth * 0.1;
        const y =
          Math.random() * window.innerHeight * 0.6 + window.innerHeight * 0.1;
        createFirework(x, y);
        count++;
        if (count >= maxFireworks) clearInterval(fireworkInterval);
      }, 400);
      setTimeout(() => {
        if (fireworkInterval) clearInterval(fireworkInterval);
        isTransitioning = false;
        particles = [];
        const ctx = confettiCanvas.getContext("2d");
        ctx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);
        startLevel(currentLevel + 1);
      }, 3500);
    }

    function updateDeathAnimation(timeScale = 1) {
      const elapsed = Date.now() - deathStartTime;

      // On utilise la durée dynamique calculée
      if (elapsed > deathDuration) {
        isDying = false;
        lives--;
        document.getElementById("lives").innerText = lives;

        if (lives > 0) {
          // --- ENCORE DES VIES ---
          resetPositions();
          isGameRunning = true;

          // --- CHANGEMENT : Relance musique dynamique ---
          playLevelMusic();
        } else {
          toggleBlur(true);
          deathDuration = 6000;
          deathStartTime = Date.now();

          // --- GAME OVER ---
          isGameOver = true;
          pacman.visible = false;
          const logo = document.getElementById("game-logo");
          if (logo) logo.style.display = "none";

          // Vérifier si High Score
          if (checkHighScore(score)) {
            gameState = STATE_INITIALS;
            document.getElementById("overlay").style.display = "none";
            document.getElementById("initials-screen").style.display = "flex";
            // Reset initiales
            initialsChars = [65, 65, 65];
            currentInitialIdx = 0;
            updateInitialsUI();
            playHighScore();
          } else {
            playGameOver();
            // Pas de High Score -> Écran Game Over classique
            const title = document.getElementById("overlay-title");
            title.style.display = "block";
            title.innerText = "GAME OVER";
            title.style.color = "#FF8888";
            document.getElementById("overlay-msg").innerText =
              "SCORE FINAL: " + score;
            document
              .getElementById("overlay-msg")
              .classList.remove("blinking");
            document.getElementById("overlay").style.display = "flex";
          }
        }
        return;
      }
      const progress = elapsed / 1000; // Animation visuelle sur 1 seconde max
      if (progress < 1.0) {
        const scale = 1 - progress;
        pacman.scale.set(scale, scale, scale);
        pacman.rotation.y += 0.2 * timeScale;
      } else {
        pacman.visible = false;
      }
    }

    function resetPositions() {
      const mapOffsetX = levelMapOffsetX;
      const mapOffsetZ = levelMapOffsetZ;
      for (let z = 0; z < currentMap.length; z++) {
        for (let x = 0; x < currentMap[z].length; x++) {
          if (currentMap[z][x] === 7) {
            pacman.position.set(
              x * TILE_SIZE - mapOffsetX,
              4,
              z * TILE_SIZE - mapOffsetZ,
            );
            pacman.gridPos = { x: x, z: z };
            pacman.worldPosTarget = pacman.position.clone();
            pacman.body.rotation.y = -Math.PI / 2;
            currentDir.set(0, 0, 0);
            nextDir.set(-1, 0, 0);
            lastMovingDir.set(-1, 0, 0);
            break;
          }
        }
      }
      pacman.visible = true;
      pacman.scale.set(1, 1, 1);
      pacman.rotation.set(0, 0, 0);
      const spawnPoints = [];
      for (let z = 0; z < currentMap.length; z++) {
        for (let x = 0; x < currentMap[z].length; x++) {
          if (currentMap[z][x] === 8) spawnPoints.push({ x, z });
        }
      }
      ghosts.forEach((g, index) => {
        const spawn = spawnPoints[index % spawnPoints.length] || {
          x: 10,
          z: 10,
        };
        g.position.set(
          spawn.x * TILE_SIZE - mapOffsetX,
          0,
          spawn.z * TILE_SIZE - mapOffsetZ,
        );
        g.gridPos = { x: spawn.x, z: spawn.z };
        g.targetWorldPos = g.position.clone();
        g.currentDir.set(0, 0, 0);
        g.rotation.y = 0;
        restoreGhost(g);
        g.userData.state = "IN_HOUSE";
      });
      ghostReleaseTimer = Date.now() + 1000;

      // Re-sync Camera immediately
      if (pacman) {
        const offset = new THREE.Vector3(
          viewMode_0_DEFAULT_OFFSET,
          viewMode_0_DEFAULT_OFFSET,
          viewMode_0_DEFAULT_OFFSET,
        );
        if (viewMode === 1) offset.set(0, 20, 20);
        currentLookAt.copy(pacman.position);
        if (viewMode === 0) {
          camera.position.copy(
            pacman.position
              .clone()
              .add(
                new THREE.Vector3(
                  viewMode_0_DEFAULT_OFFSET,
                  viewMode_0_DEFAULT_OFFSET,
                  viewMode_0_DEFAULT_OFFSET,
                ),
              ),
          );
          camera.lookAt(pacman.position);
        }
      }
    }

    function onWindowResize() {
      const aspect = window.innerWidth / window.innerHeight;

      // --- ADAPTATION ORTHOGRAPHIQUE ---
      const viewSize = CONFIG.CAMERA.VIEW_SIZE;
      camera.left = (-viewSize * aspect) / 2;
      camera.right = (viewSize * aspect) / 2;
      camera.top = viewSize / 2;
      camera.bottom = -viewSize / 2;

      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      if (composer) composer.setSize(window.innerWidth, window.innerHeight); // RESIZE COMPOSER
      confettiCanvas.width = window.innerWidth;
      confettiCanvas.height = window.innerHeight;

      // Mise à jour shader tilt shift
      if (tiltShiftPass) {
        tiltShiftPass.uniforms.screenSize.value.set(
          window.innerWidth,
          window.innerHeight,
        );
      }
    }

    let lastFrameTime = performance.now();
    const TARGET_FPS = 120;
    function animate() {
      requestAnimationFrame(animate);
      const now = performance.now();
      const dt = Math.min(now - lastFrameTime, 100);
      lastFrameTime = now;
      const timeScale = dt / (1000 / TARGET_FPS);

      // GESTION ETATS ECRANS
      if (gameState === STATE_TITLE) {
        // Vérifier timer
        if (now - titleScreenTimer > TITLE_DURATION && titleScreenTimer > 0) {
          // Switch to High Score
          gameState = STATE_HIGHSCORE;
          highScoreTimer = now; // Initialiser le timer High Score
          document.getElementById("overlay").style.display = "none";
          document.getElementById("highscore-screen").style.display = "flex";
          document.getElementById("highscore-footer").style.display = "flex";
        }
        // Initialiser le timer si première frame
        if (titleScreenTimer === 0) titleScreenTimer = now;
      } else if (gameState === STATE_HIGHSCORE) {
        const elapsed = now - highScoreTimer;
        const totalAnimTime = 3500 * MAX_SCORES;
        const waitTime = 3000; // Attente réduite avant passage info

        // Si l'animation est finie ET que le temps d'attente est écoulé
        if (elapsed > totalAnimTime + waitTime) {
          // --- CHANGEMENT : PASSAGE A L'ECRAN INFO ---
          gameState = STATE_INFO;
          infoScreenTimer = now;
          document.getElementById("highscore-screen").style.display = "none";
          document.getElementById("highscore-footer").style.display = "none";
          document.getElementById("info-screen").style.display = "flex";
        } else {
          renderHighScores(elapsed);
        }
      } else if (gameState === STATE_INFO) {
        // --- NOUVEL ETAT : INFO SCREEN ---
        const elapsed = now - infoScreenTimer;
        const infoDuration = 8000; // 8 secondes d'affichage

        if (elapsed > infoDuration) {
          // Retour à l'écran titre
          gameState = STATE_TITLE;
          titleScreenTimer = now;
          document.getElementById("info-screen").style.display = "none";
          document.getElementById("overlay").style.display = "flex";
          // Restaurer l'apparence de l'écran titre
          document.getElementById("overlay-msg").innerHTML =
            "PRESS SPACEBAR TO PLAY";
          document.getElementById("game-logo").style.display = "block";
        } else {
          renderInfoScreen(elapsed);
        }
      }

      updateParticles(timeScale);
      if (isDying) {
        updateDeathAnimation(timeScale);
        updateFloatingScores(timeScale);
      } else if (isGameRunning && !isGameOver) {
        updatePacman(timeScale);
        updateGhosts(timeScale);
        updateCamera(timeScale);
        if (CONFIG.GAME.ENABLE_NIGHT_DAY_CYCLE) updateDayNightCycle(timeScale); // Cycle jour/nuit
        updateFloatingScores(timeScale);
      }

      // --- LOGIQUE RENDU POST-PROCESSING ---
      // Actif SEULEMENT SI : Qualité HIGH ET Vue Isométrique (Mode 0) ET Composer prêt
      if (
        CONFIG.GRAPHICS.QUALITY_TIER === "HIGH" &&
        viewMode === 0 &&
        composer
      ) {
        composer.render();
      } else {
        renderer.render(scene, camera);
      }
    }

/**
 * MercuryFallback - Une simulation de batterie PCM8 pour Pac-Mania
 * Utilise l'API Web Audio pour synthétiser les sons sans fichiers externes.
 */
class MercuryFallback {
    constructor(bpm = 155) { // BPM approximatif de Block Town
        this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        this.bpm = bpm;
        this.isPlaying = false;
        this.nextNoteTime = 0;
        this.timerID = null;
        this.beatCount = 0;
        
        // Le motif rythmique de Pac-Mania (1 = Kick, 2 = Snare, 3 = HiHat)
        // C'est un rythme disco simple : Kick - Hat - Snare - Hat
        this.pattern = [1, 3, 2, 3]; 
    }

    // --- Synthèse Sonore (Le "Vibe" rétro) ---

    playKick(time) {
        const osc = this.audioCtx.createOscillator();
        const gain = this.audioCtx.createGain();
        
        osc.connect(gain);
        gain.connect(this.audioCtx.destination);

        // Une onde sinusoïdale qui chute rapidement en fréquence (Piuuum !)
        osc.frequency.setValueAtTime(150, time);
        osc.frequency.exponentialRampToValueAtTime(0.01, time + 0.5);

        gain.gain.setValueAtTime(1, time);
        gain.gain.exponentialRampToValueAtTime(0.01, time + 0.5);

        osc.start(time);
        osc.stop(time + 0.5);
    }

    playSnare(time) {
        // Bruit blanc pour le "Tchhh"
        const bufferSize = this.audioCtx.sampleRate;
        const buffer = this.audioCtx.createBuffer(1, bufferSize, this.audioCtx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
            data[i] = Math.random() * 2 - 1;
        }

        const noise = this.audioCtx.createBufferSource();
        noise.buffer = buffer;
        
        // Filtre passe-haut pour enlever les graves du bruit
        const filter = this.audioCtx.createBiquadFilter();
        filter.type = 'highpass';
        filter.frequency.value = 1000;
        
        const gain = this.audioCtx.createGain();
        
        noise.connect(filter);
        filter.connect(gain);
        gain.connect(this.audioCtx.destination);

        // Enveloppe courte et percutante
        gain.gain.setValueAtTime(0.5, time);
        gain.gain.exponentialRampToValueAtTime(0.01, time + 0.2);

        noise.start(time);
        noise.stop(time + 0.2);
        
        // Ajouter un petit "poc" tonal pour le corps de la caisse claire
        this.playTone(time, 200, 0.1); 
    }

    playHiHat(time) {
        // Similaire au snare mais plus aigu et plus court
        const bufferSize = this.audioCtx.sampleRate;
        const buffer = this.audioCtx.createBuffer(1, bufferSize, this.audioCtx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
            data[i] = Math.random() * 2 - 1;
        }

        const noise = this.audioCtx.createBufferSource();
        noise.buffer = buffer;

        const filter = this.audioCtx.createBiquadFilter();
        filter.type = 'highpass';
        filter.frequency.value = 5000; // Très aigu

        const gain = this.audioCtx.createGain();

        noise.connect(filter);
        filter.connect(gain);
        gain.connect(this.audioCtx.destination);

        gain.gain.setValueAtTime(0.3, time);
        gain.gain.exponentialRampToValueAtTime(0.01, time + 0.05); // Très court

        noise.start(time);
        noise.stop(time + 0.05);
    }

    playTone(time, freq, duration) {
        const osc = this.audioCtx.createOscillator();
        const gain = this.audioCtx.createGain();
        osc.connect(gain);
        gain.connect(this.audioCtx.destination);
        osc.frequency.value = freq;
        gain.gain.setValueAtTime(0.5, time);
        gain.gain.exponentialRampToValueAtTime(0.01, time + duration);
        osc.start(time);
        osc.stop(time + duration);
    }

    // --- Séquenceur (Le moteur rythmique) ---

    schedule() {
        const secondsPerBeat = 60.0 / this.bpm;
        const lookahead = 0.1; // 100ms d'avance pour planifier

        while (this.nextNoteTime < this.audioCtx.currentTime + lookahead) {
            this.playBeat(this.nextNoteTime);
            // On avance d'un quart de temps (noire)
            this.nextNoteTime += secondsPerBeat; 
        }
        
        if (this.isPlaying) {
            this.timerID = requestAnimationFrame(this.schedule.bind(this));
        }
    }

    playBeat(time) {
        // On boucle sur le pattern (0, 1, 2, 3...)
        const currentBeat = this.pattern[this.beatCount % this.pattern.length];
        
        if (currentBeat === 1) this.playKick(time);
        if (currentBeat === 2) this.playSnare(time);
        if (currentBeat === 3) this.playHiHat(time);
        
        this.beatCount++;
    }

    start() {
        if (this.isPlaying) return;
        
        // Important: Débloquer l'AudioContext sur une interaction utilisateur
        if (this.audioCtx.state === 'suspended') {
            this.audioCtx.resume();
        }

        this.isPlaying = true;
        this.beatCount = 0;
        this.nextNoteTime = this.audioCtx.currentTime + 0.1; // Petit délai de départ
        this.schedule();
    }

    stop() {
        this.isPlaying = false;
        cancelAnimationFrame(this.timerID);
    }
}

    init();
  </script>
</body>

</html>
